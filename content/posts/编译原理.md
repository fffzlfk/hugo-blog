---
title: "编译原理"
date: 2021-03-11T10:51:32+08:00
toc: true
draft: false
summary: "Compiler Principles" 
tags:
    - 编译原理
    - Academic
---

## 第一章 引言

### 语言之间的翻译

{{<image src="https://files.catbox.moe/wi466j.png" position="center" style="zoom: 30% ;">}}

### 编译器与解释器

#### 语言翻译两种基本形态

- 先翻译后执行
- 边翻译边执行

### 编译器的工作原理和基本组成

#### 通用程序设计语言的主要成分

**声明+定义**

#### 以阶段划分编译器

{{<image src="https://files.catbox.moe/javh21.png" position="center" style="zoom: 70% ;">}}

#### 编译器的分析/综合模式

{{<image src="https://files.catbox.moe/phca02.png" position="center" style="zoom: 80% ;">}}

## 第二章 词法分析

### 词法分析中的若干问题

#### 记号、模式与单词

| 单词的基本分类 | |
| -- | -- |
| 关键字（保留字） | key(key word, or reversed word) |
| 标识符 | id(identifier) |
| 字面量 | literal |
| 特殊符号 | ks(key symbol, or special symbol)|

**记号=记号的类别+记号的属性**

### 模式的形式化描述

#### 字符串与语言

- 定义2.1：语言$L$是**有限**字母表$\sum$上**有限**长度**字符串**的集合。

- 字符串：由字母表中的符号组成的任意有穷序列。
- 字符串的长度：字符串中的符号个数。

##### 字符串基本概念

| 表示、术语 | 举例 |
| -- | -- |
| $\|S\|$ | $\|abc\|= 3$ |
| $\varepsilon$ | $\| \varepsilon\| = 0$ |
| $S1S2$ | $"abc""def"="abcdef"$ |
| $S^n$（幂）| $"abc"^3 ="abcabcabc"$ |
| $S$的前缀 | $"abc"$的前缀可以是：$ε，a，ab, abc$ |
| $S$的后缀 | $"abc"$的后缀可以是：$ε，c，bc, abc$ |
| $S$的子串 | $"abc"$的子串可以是$ε，a，b, c, …$|
| $S$的真前缀 | $"abc"$的真前缀：$a, ab$ |
| $S$的真后缀 | $"abc"$的真后缀：$c, bc$ |
| $S$的真子串 | $"abc"$的真子串：$a, b, c, ab, bc $ |
| $S$的子序列 | $"abdf"$是$"abcdef"$的一个子序列（$S$中去掉$0$或若干个不一定连续的字符后形成的字符串）|
| $S$的逆转$S^R$ | $S=abc,S^R=cba$ |

##### 字符串集合的运算

| 表示、术语 | 意义 |
| -- | -- |
| $\varnothing$ | 空集合 |
| $\{\epsilon\}$ | 空串作为唯一元素的集合 |
| $X = L \cup M$ | 集合的并：$ X = \\{ s \| \in L\ or\ s \in M \\} $|
| $X = L \cap M$ | 集合的交：$ X = \\{ s \| \in L\ and\ s \in M \\} $|
| $X = L \cap M$ | 集合的连接：$ X = \\{ st \| \in L\ and\ s \in M\\} $|
| $X = L^0$ | 集合的连接：$ L^0 = \\{ \epsilon \\} $|
| $X = L^*$ | 集合的Kleene闭包：$X=L^0 \cup L^1 \cup L^2 \cup ... $ |
| $X = L^+$ | 集合的正闭包：$X=L^1 \cup L^2 \cup L^3 \cup ... $ |


#### 正规式与正规集

##### 正规式的递归定义

1. **$\epsilon$和$\varnothing$都是$\sum$上的正规式**，它表示$L(\epsilon)=\\{ \epsilon \\}$和$\varnothing$
2. 若$a$是$\sum$上的字符，**则$a$是正规式**，表示$L(a)=\\{a\\}$
3. 若正规式$r$和$s$分别表示$L(r)$和$L(s)$:
    - $r \| s$是正规式，表示集合$L(r)\cup L(s)$
    - $rs$ 是正规式，表示集合$L(r)L(s)$
    - $r^* $ 是正规式，表示集合 $(L(r))* $
    - $r$是正规式，表示集合仍是$L(r)$

##### 运算

- 运算符的优先级与结合性
    1. 三种运算均具有左结合性质
    2. 优先级从高到低排列顺序为：**闭包运算、连接运算、或运算**
- 正规式的等价：若正规式$P$和$Q$表示了同一个正规集，则称P和Q是等价的，记为$P=Q$
- 正规式等价的判定（证明）
    - 根据定义
    - 利用代数性质
        1. $ r|s = s|r $
        2. $r|(s|t) = (r|s)|t$
        3. $r(s|t) = rs|rt$
        4. $(s|t)r = sr|tr $
        5. $(rs)t = r(st)$
        6. $εr = rε = r$
        7. $r^* = (r+|ε) $
        8. $r^{\*\*} = r^* $

#### 记号的说明

例如：

```
relation = < | <= | <> | > | >= | =

id = (a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z
       |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z)
     (a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z
     |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z
     |0|1|2|3|4|5|6|7|8|9)*

num = (0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*
      (ε|.(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*)
      (ε|E(+|-|ε)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*)
```

- 简化正规式描述
    - 正闭包：$r^+ = rr^* = r^* r，r^* = r^+|ε$
    - 可缺省：$r?=r|ε$
    - 字符组：如$[abc]$，它等价于：$a|b|c$
    - 非字符组：$[^r]$
- 引入辅助定义
```
char              = [a-zA-Z]
digit             = [0-9]
digits            = digit+
optional_fraction = ( . digits )?
optional_exponent = ( E (+|-)? digits )?

id  = char ( char|digit )*
num = digits optional_fraction optional_exponent
```

### 记号的识别-有限自动机

#### 不确定的有限自动机（Nondeterministic Finite Automaton，NFA）

**定义**：$M=(S, \sum, move, s_0, F) $
- $S$是有限个状态(state)的集合
- $\sum$是有限个输入字符 包括 $ε$ 的集合
- $move(s_i, ch)=s_j$
- $s_0$是唯一的初态
- $F$是终态集

##### 直观的表示方式
1. 状态转换图
2. 状态转换矩阵
{{<image src="https://files.catbox.moe/7xnams.png" position="center" style="zoom: 60% ;">}}
{{<image src="https://files.catbox.moe/xlnj3y.png" position="center" style="zoom: 80% ;">}}

##### NFA存在的问题

1. 只有尝试了全部可能的路径，才能确定一个输入序列不被接受，而这些路径的条数随着路径长度的增长成指数增长
2. 识别过程中需要大量的回溯，时间复杂度升高且算法趋于复杂

#### 确定的有限自动机（Deterministic Finite Automaton，DFA）

**定义**：DFA是NFA的一个特例，其中
1. 没有状态具有$\epsilon$状态转移$(\epsilon -transition)$，即状态图中没有标记$\epsilon$的边
2. 对每个状态$s$和每个字符$a$，最多有一个下一状态

##### 模拟DFA算法

```pascal
s := s0; ch := nextchar;    -- 初值
while ch != eof             -- 循环
loop s := move(s, ch);
     ch := nextchar;
end loop;
if s in F
then return "yes"; else return "no";
end if;
```

### 从正规式到词法分析器

#### 构造词法分析器的方法和步骤

1. 用正规式描述模式
2. 构造NFA
3. 确定化（转换成等价的DFA）
4. 最小化（优化DFA）
5. 从优化后的DFA构造词法分析器

#### 从正规式到NFA

**Thompson算法**

1. 对$\epsilon$，$N(\epsilon)$：
{{<image src="https://files.catbox.moe/qv83fk.png" position="center" style="zoom: 30% ;">}}
2. 对于$\sum$上的每个字符$a$，$N(a)$：
{{<image src="https://files.catbox.moe/uie9rx.png" position="center" style="zoom: 30% ;">}}
3. 若$N(p)$和$N(q)$是正规式$p$和$q$的NFA
    1. 对于$p|q$，构造$N(p|q)$：{{<image src="https://files.catbox.moe/cn7ny1.png" position="center" style="zoom: 30% ;">}}
    2. 对于正规式$pq$，构造NFA $N(pq)$：{{<image src="https://files.catbox.moe/zexlif.png" position="center" style="zoom: 30% ;">}}
    3. 对于正规式$p^* $，构造NFA $N(p^{*})$：{{<image src="https://files.catbox.moe/hn9frb.png" position="center" style="zoom: 30% ;">}}

#### 从NFA到DFA

##### 并行方法

- $smove(S, a)$：从状态集$S$中的每个状态出发，经过标记为$a$的边直接到达的下一状态全体
- $\epsilon$-闭包：从状态T出发，经过若干次$\epsilon$转移到达的状态全体

**$\epsilon$-闭包 的定义**
1. T中的所有状态属于$\epsilon$-闭包
2. 如果$t$属于$\epsilon$-闭包(T)且$move(t, \epsilon)=u$，则$u$属于$\epsilon$-闭包(T)
3. 再无其它状态属于$\epsilon$-闭包(T)

**求$\epsilon$-闭包 的算法**

```pascal
function ε-闭包(T) is
begin
    for T中的每个状态t
    loop 加入t到U; push(t);
    end loop;
    while 栈不空
    loop pop(t);
        for 每个u=move(t, ε)
        loop if u不在U中 then 加入u到U中; push(u); endif;
        end loop;
    end loop;
    return U;
end ε-闭包;
```

**模拟NFA**

```pascal
S := ε-闭包({s0});              -- 所有可能初态的集合
a := nextchar;
while a != eof
loop
    S := ε-闭包(smove(S, a));   -- 所有下一状态的集合
    a := nextchar;
end loop;
if S and F != nil then return "yes"; else return "no";
end if;
```

##### 子集法构造DFA

```pascal
Dstates = {ε-闭包({s0})};       // Dstates中仅有一个状态且未标记
while Dstates有尚未标记的状态T
loop 标记T;
    for 每一个输入字符a
    loop U := ε-闭包(smove(T, a))
        if U 非空
        then Dtran[T, a] := U;
            if U 不在Dstates中
            then U作为尚未标记的状态加入Dstates;
            end if;
        end if;
    end loop;
end loop;
```

例如用上述算法构造(a|b)*abb的DFA：

{{<image src="https://files.catbox.moe/52hvlz.png" position="center" style="zoom: 40% ;">}}

```bash
ε-闭包({0}) = {0, 1, 2, 4, 7}*                  A
ε-闭包(smove(A, a)) = {3, 8, 6, 7, 1, 2, 4}*    B
ε-闭包(smove(A, b)) = {5, 6, 7, 1, 2, 4}*       C
ε-闭包(smove(B, a)) = {3, 8, 6, 7, 1, 2, 4}     B
ε-闭包(smove(B, b)) = {9, 5, 6, 7, 1, 2, 4}*    D
ε-闭包(smove(C, a)) = {3, 8, 6, 7, 1, 2, 4}     B
ε-闭包(smove(C, b)) = {5, 6, 7, 1, 2, 4}        C
ε-闭包(smove(D, a)) = {3, 8, 6, 7, 1, 2, 4}     B
ε-闭包(smove(D, b)) = {5, 10, 6, 7, 1, 2, 4}    E
ε-闭包(smove(E, a)) = {3, 8, 6, 7, 1, 2, 4}     B
ε-闭包(smove(E, b)) = {5, 6, 7, 1, 2, 4}        C
```
{{<image src="https://files.catbox.moe/act9lb.png" position="center" style="zoom: 40% ;">}}

#### 最小化DFA

**可区分**:对于DFA中的任何两个状态$t$和$s$，若从一状态出发接受输入字符串$\omega$，而从另一状态出发不接受$\omega$，则称 **$\omega$区分状态$t$和$s$**。如果存在某个能够区分状态$s$和状态$t$的串，那么它们是**可区分的**。

**最小化DFA算法**
1. 初始划分$\Pi=\\{S-F, F\\}, \Pi_{new} = \Pi$。$F$是终态集，$S-F$是非终态集
2. 应用下述过程构造新的划分$\Pi_{new}$:
    1. for $\Pi$的每一个组$G$
    2. loop 划分$G$, $G$的两个状态$s$和$t$在同一组中的充要条件是：
    $$\forall a \in \Sigma \forall G_i \in \Pi (move(s, a) \in G_i \leftrightarrow move(t, a) \in G_i)$$用新的划分组替代$G$, 形成新的划分$\Pi_{new}$;  
    end loop
3. 若$\Pi_{new}=\Pi$，令$\Pi_{final} = \Pi$，转4，否则令$\Pi = \Pi_{new}$并重复步骤2
4. 选代表并修改状态转移
5. 删除死状态，即不是终态且对所有输入字符均转向自身，或从初态不可到达的状态

#### 由DFA构造词法分析器

- 表驱动的词法分析器(自动生成)
- 直接编码的词法分析器

|   | 表驱动 | 直接编码 |
| -- | -- | -- |
| 分析器的速度  | 慢 | 快|
| 程序与模式的关系 | 无关| 有关 |
| 分析器的规模 | 较大 | 较小 |
| 适合编写的方法 | 工具生成| 手工编写 |


## 第三章 语法分析

### 基本术语

#### 语法分析器的作用

1. 根据词法分析器提供的记号流，为语法正确的输入**构造语法树**。
2. 检查输入中的语法（可能还包含词法错误），并调用出错处理器进行适当处理。

#### 语法错误的处理原则

##### 基本恢复策略

1. 紧急方式恢复：使用同步记号
2. 短语级恢复：采用串替换的方式
3. 出错产生式：捕获错误
4. 全局纠正

例：

```pascal
x := a + b
y := c + d;
```
- 紧急方式——丢弃b后若干记号，知道遇见+`x := a + b + d;`
- 短语级恢复——加入分号，使之成为一个赋值句`y := c + d;`

### 上下文无关法（Context Free Grammer，CFG）

#### CFG定义及表示

四元组$G=(N, T, P, S)$，其中
1. $N$——**非终结符**（Nonterminals）有限集合
2. $T$——**终结符**（Terminals）有限集合，$N \cup T = \emptyset $
3. $P$——**产生式**（Productions）有限集合，$A\rightarrow a$，其中$A \in N$(左部)，$a \in (N\cup T)^*$ (右部)，若$a = \epsilon$，则称$A \rightarrow \epsilon$为空产生式
4. $S$——$S$是非终结符，称为**开始符号**

##### 由产生式集表示CFG

- $E \rightarrow E + E$
- $E \rightarrow E * E$
- $E \rightarrow (E)$
- $E \rightarrow -E$
- $E \rightarrow id$

##### 终结符与非终结符书写上的约定

- 大写字母$A、B、C$表示非终结符
- 小写字母$a、b、c$表示终结符
- 小写希腊字母$\alpha、\beta、\delta $表示任意文法符号序列

#### CFG产生语言的基本方法——推导

- **直接推导**：$\alpha A \beta => \alpha \gamma \beta $
- **零布或多步推导**
- **至少一步推导**

##### 由CFG所产生的语言L(G)

$$L(G) = \\{ \omega | S \overset{+}{\Rightarrow} and \ \omega \in T^* \\} $$
$L(G)$称为**上下文无关语言**（Context Free Language, CFL）$\omega$成为句子，若$S \overset{*}{\Rightarrow} \alpha, \alpha \in (N \cup T)^{*} $，则称$\alpha$为$G$的一个**句型**。

##### 最左推导和最右推导（规范推导）

最左推导产生的句型称为**左句型**

### 推导与语法树

#### 语法树和抽象语法树

{{<image src="https://files.catbox.moe/fskbip.png" position="center" style="zoom: 80% ;">}}

#### 二义性与二义性的消除

- **二义性**：一个句子可能对应多棵语法树
    - 文法二义性：若文法$G$对同一句子产生不止一棵语法树，则称语法树$G$是二义的。或者说，若文法$G$对同一个句子存在两个不同的最左（最右）推导，则称文法$G$是二义的。
    - **语言的二义性**：如果产生上下文无关语言的每一个文法都是二义的，则此语言是二义的

- **二义性的消除**
    - 改写二义文法为非二义性文法
        1. 引入一个新的非终结符，增加一个子结构并提高一级优先级
        2. 递归非终结符在终结符左边，运算具有左结合性，否则具有右结合性
        {{<image src="https://files.catbox.moe/o3b2cj.png" position="center" style="zoom: 70% ;">}}
        消除“悬空else”问题  
        {{<image src="https://files.catbox.moe/9tosqb.png" position="center" style="zoom: 60% ;">}}
    - 为文法符号规定优先级和结合性
    - 修改语言的语法`end if`

### 语言与文法简介

#### 正规式与上下文无关法

##### 正规式到CFG的转换

- 若$0$为初态，则$A_0$为开始符号
- 对于$move(i,a)=j$，引入产生式$A_i→aA_j$
- 对于$move(i,ε)=j$，引入产生式$A_i→A_j$
- 若$i$是终态，则引入产生式$A_i →ε$。

{{<image src="https://files.catbox.moe/a0ttvr.png" position="center" style="zoom: 30% ;">}}

#### 上下文有关语言

- 不能用CFG描述的语言
    - $L1=\\{ \omega c \omega | \omega \in (a | b)^* \\}$标识符声明与引用一致性的抽象
    - $L2=\\{a^nb^mc^nd^m|n \ge 1\ and\ m \ge 1\\}$ 形参与实参一致性的抽象
    - $L3=\\{ a^nb^nc^n|n \ge 1\\}$ 计数问题的抽象
- 相近的CFL
    - $L1^{'}=\\{ \omega c \omega^r | \omega \in (a | b)^* \\} (S\rightarrow aSa\ |\ bSb\ |c)$
    - $L2^{'}=\\{ a^nb^mc^md^n|n\ge 1, m \ge 1\\} (S \rightarrow aSd\ | aAd\ A \rightarrow bAc\ |\ bc)$
    - $L2^{''}=\\{ a^nb^nc^md^m | n \ge 1, m \ge 1\\} (S \rightarrow AB\ A\rightarrow aAb\ |\ ab \ B\rightarrow cBd\ | cd) $
    - $ L3^{'}=\\{ a^mb^mc^m | m, n \ge 1\\}\ (S \rightarrow aAb | ab\  C\rightarrow cC|c)$

#### 形式语言与自动机简介

- 0型文法：若文法 $G=(N, T, P, S)$ 的每个产生式 $α→β$ 中 均有 $α∈(N∪T)^* $ 且至少含有一个非终结符 $β∈(N∪T)^*$则称 G 为 0 型文法 。
- 限制
    - $G $的任何产生式 $α→β$ ($S→ε$ 除外) 满足$ |α|≤|\beta |$
    - $G$ 的任何产生式形如 $A→β$ 其中 $A∈N\ β∈(N∪T)^*$
    - $G$ 的任何产生式形如 $A→a$ 或者 $A→aB$( 或者 $A→Ba$) 其中 $A$
和 $B$$∈N$ $a∈T$

| 文法 | 语言 | 自动机 |
| -- | -- | -- |
| 短语文法（0型） | 短语结构语言| 图灵机 |
| CSG（1型）| CSL | 线性界限自动机 |
| CFG（2型）| CFL | 下推自动机 |
| 正规文法 （3型）| 正规集 | 有限自动机 |

### 自上而下语法分析

#### 一般方法（试探＋回溯，边推导边匹配）

{{<image src="https://files.catbox.moe/imsqsp.png" position="center" style="zoom: 30% ;">}}