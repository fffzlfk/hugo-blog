---
title: "编译原理"
date: 2021-03-11T10:51:32+08:00
toc: true
draft: false
summary: "Compiler Principles" 
tags:
    - 编译原理
    - Academic
---

## 第一章 引言

### 语言之间的翻译

{{<image src="https://files.catbox.moe/wi466j.png" position="center" style="zoom: 30% ;">}}

### 编译器与解释器

#### 语言翻译两种基本形态

- 先翻译后执行
- 边翻译边执行

### 编译器的工作原理和基本组成

#### 通用程序设计语言的主要成分

**声明+定义**

#### 以阶段划分编译器

{{<image src="https://files.catbox.moe/javh21.png" position="center" style="zoom: 70% ;">}}

#### 编译器的分析/综合模式

{{<image src="https://files.catbox.moe/phca02.png" position="center" style="zoom: 80% ;">}}

## 第二章 词法分析

### 词法分析中的若干问题

#### 记号、模式与单词

| 单词的基本分类 | |
| -- | -- |
| 关键字（保留字） | key(key word, or reversed word) |
| 标识符 | id(identifier) |
| 字面量 | literal |
| 特殊符号 | ks(key symbol, or special symbol)|

**记号=记号的类别+记号的属性**

### 模式的形式化描述

#### 字符串与语言

- 定义2.1：语言$L$是**有限**字母表$\sum$上**有限**长度**字符串**的集合。

- 字符串：由字母表中的符号组成的任意有穷序列。
- 字符串的长度：字符串中的符号个数。

##### 字符串基本概念

| 表示、术语 | 举例 |
| -- | -- |
| $\|S\|$ | $\|abc\|= 3$ |
| $\varepsilon$ | $\| \varepsilon\| = 0$ |
| $S1S2$ | $"abc""def"="abcdef"$ |
| $S^n$（幂）| $"abc"^3 ="abcabcabc"$ |
| $S$的前缀 | $"abc"$的前缀可以是：$ε，a，ab, abc$ |
| $S$的后缀 | $"abc"$的后缀可以是：$ε，c，bc, abc$ |
| $S$的子串 | $"abc"$的子串可以是$ε，a，b, c, …$|
| $S$的真前缀 | $"abc"$的真前缀：$a, ab$ |
| $S$的真后缀 | $"abc"$的真后缀：$c, bc$ |
| $S$的真子串 | $"abc"$的真子串：$a, b, c, ab, bc $ |
| $S$的子序列 | $"abdf"$是$"abcdef"$的一个子序列（$S$中去掉$0$或若干个不一定连续的字符后形成的字符串）|
| $S$的逆转$S^R$ | $S=abc,S^R=cba$ |

##### 字符串集合的运算

| 表示、术语 | 意义 |
| -- | -- |
| $\varnothing$ | 空集合 |
| $\{\epsilon\}$ | 空串作为唯一元素的集合 |
| $X = L \cup M$ | 集合的并：$ X = \\{ s \| \in L\ or\ s \in M \\} $|
| $X = L \cap M$ | 集合的交：$ X = \\{ s \| \in L\ and\ s \in M \\} $|
| $X = L \cap M$ | 集合的连接：$ X = \\{ st \| \in L\ and\ s \in M\\} $|
| $X = L^0$ | 集合的连接：$ L^0 = \\{ \epsilon \\} $|
| $X = L^*$ | 集合的Kleene闭包：$X=L^0 \cup L^1 \cup L^2 \cup ... $ |
| $X = L^+$ | 集合的正闭包：$X=L^1 \cup L^2 \cup L^3 \cup ... $ |


#### 正规式与正规集

##### 正规式的递归定义

1. **$\epsilon$和$\varnothing$都是$\sum$上的正规式**，它表示$L(\epsilon)=\\{ \epsilon \\}$和$\varnothing$
2. 若$a$是$\sum$上的字符，**则$a$是正规式**，表示$L(a)=\\{a\\}$
3. 若正规式$r$和$s$分别表示$L(r)$和$L(s)$:
    - $r \| s$是正规式，表示集合$L(r)\cup L(s)$
    - $rs$ 是正规式，表示集合$L(r)L(s)$
    - $r^* $ 是正规式，表示集合 $(L(r))* $
    - $r$是正规式，表示集合仍是$L(r)$

##### 运算

- 运算符的优先级与结合性
    1. 三种运算均具有左结合性质
    2. 优先级从高到低排列顺序为：**闭包运算、连接运算、或运算**
- 正规式的等价：若正规式$P$和$Q$表示了同一个正规集，则称P和Q是等价的，记为$P=Q$
- 正规式等价的判定（证明）
    - 根据定义
    - 利用代数性质
        1. $ r|s = s|r $
        2. $r|(s|t) = (r|s)|t$
        3. $r(s|t) = rs|rt$
        4. $(s|t)r = sr|tr $
        5. $(rs)t = r(st)$
        6. $εr = rε = r$
        7. $r^* = (r+|ε) $
        8. $r^{\*\*} = r^* $

#### 记号的说明

例如：

```
relation = < | <= | <> | > | >= | =

id = (a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z
       |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z)
     (a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z
     |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z
     |0|1|2|3|4|5|6|7|8|9)*

num = (0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*
      (ε|.(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*)
      (ε|E(+|-|ε)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*)
```

- 简化正规式描述
    - 正闭包：$r^+ = rr^* = r^* r，r^* = r^+|ε$
    - 可缺省：$r?=r|ε$
    - 字符组：如$[abc]$，它等价于：$a|b|c$
    - 非字符组：$[^r]$
- 引入辅助定义
```
char              = [a-zA-Z]
digit             = [0-9]
digits            = digit+
optional_fraction = ( . digits )?
optional_exponent = ( E (+|-)? digits )?

id  = char ( char|digit )*
num = digits optional_fraction optional_exponent
```

### 记号的识别-有限自动机

#### 不确定的有限自动机（Nondeterministic Finite Automaton，NFA）

**定义**：$M=(S, \sum, move, s_0, F) $
- $S$是有限个状态(state)的集合
- $\sum$是有限个输入字符 包括 $ε$ 的集合
- $move(s_i, ch)=s_j$
- $s_0$是唯一的初态
- $F$是终态集

##### 直观的表示方式
1. 状态转换图
2. 状态转换矩阵
{{<image src="https://files.catbox.moe/7xnams.png" position="center" style="zoom: 60% ;">}}
{{<image src="https://files.catbox.moe/xlnj3y.png" position="center" style="zoom: 80% ;">}}

##### NFA存在的问题

1. 只有尝试了全部可能的路径，才能确定一个输入序列不被接受，而这些路径的条数随着路径长度的增长成指数增长
2. 识别过程中需要大量的回溯，时间复杂度升高且算法趋于复杂

#### 确定的有限自动机（Deterministic Finite Automaton，DFA）

**定义**：DFA是NFA的一个特例，其中
1. 没有状态具有$\epsilon$状态转移$(\epsilon -transition)$，即状态图中没有标记$\epsilon$的边
2. 对每个状态$s$和每个字符$a$，最多有一个下一状态

##### 模拟DFA算法

```pascal
s := s0; ch := nextchar;    -- 初值
while ch != eof             -- 循环
loop s := move(s, ch);
     ch := nextchar;
end loop;
if s in F
then return "yes"; else return "no";
end if;
```

### 从正规式到词法分析器

#### 构造词法分析器的方法和步骤

1. 用正规式描述模式
2. 构造NFA
3. 确定化（转换成等价的DFA）
4. 最小化（优化DFA）
5. 从优化后的DFA构造词法分析器

#### 从正规式到NFA

**Thompson算法**

1. 对$\epsilon$，$N(\epsilon)$：
{{<image src="https://files.catbox.moe/qv83fk.png" position="center" style="zoom: 30% ;">}}
2. 对于$\sum$上的每个字符$a$，$N(a)$：
{{<image src="https://files.catbox.moe/uie9rx.png" position="center" style="zoom: 30% ;">}}
3. 若$N(p)$和$N(q)$是正规式$p$和$q$的NFA
    1. 对于$p|q$，构造$N(p|q)$：{{<image src="https://files.catbox.moe/cn7ny1.png" position="center" style="zoom: 30% ;">}}
    2. 对于正规式$pq$，构造NFA $N(pq)$：{{<image src="https://files.catbox.moe/zexlif.png" position="center" style="zoom: 30% ;">}}
    3. 对于正规式$p^* $，构造NFA $N(p^{*})$：{{<image src="https://files.catbox.moe/hn9frb.png" position="center" style="zoom: 30% ;">}}

#### 从NFA到DFA

##### 并行方法

- $smove(S, a)$：从状态集$S$中的每个状态出发，经过标记为$a$的边直接到达的下一状态全体
- $\epsilon$-闭包：从状态T出发，经过若干次$\epsilon$转移到达的状态全体

**$\epsilon$-闭包 的定义**
1. T中的所有状态属于$\epsilon$-闭包
2. 如果$t$属于$\epsilon$-闭包(T)且$move(t, \epsilon)=u$，则$u$属于$\epsilon$-闭包(T)
3. 再无其它状态属于$\epsilon$-闭包(T)

**求$\epsilon$-闭包 的算法**

```pascal
function ε-闭包(T) is
begin
    for T中的每个状态t
    loop 加入t到U; push(t);
    end loop;
    while 栈不空
    loop pop(t);
        for 每个u=move(t, ε)
        loop if u不在U中 then 加入u到U中; push(u); endif;
        end loop;
    end loop;
    return U;
end ε-闭包;
```

**模拟NFA**

```pascal
S := ε-闭包({s0});              -- 所有可能初态的集合
a := nextchar;
while a != eof
loop
    S := ε-闭包(smove(S, a));   -- 所有下一状态的集合
    a := nextchar;
end loop;
if S and F != nil then return "yes"; else return "no";
end if;
```

##### 子集法构造DFA

```pascal
Dstates = {ε-闭包({s0})};       // Dstates中仅有一个状态且未标记
while Dstates有尚未标记的状态T
loop 标记T;
    for 每一个输入字符a
    loop U := ε-闭包(smove(T, a))
        if U 非空
        then Dtran[T, a] := U;
            if U 不在Dstates中
            then U作为尚未标记的状态加入Dstates;
            end if;
        end if;
    end loop;
end loop;
```

例如用上述算法构造(a|b)*abb的DFA：

{{<image src="https://files.catbox.moe/52hvlz.png" position="center" style="zoom: 40% ;">}}

```bash
ε-闭包({0}) = {0, 1, 2, 4, 7}*                  A
ε-闭包(smove(A, a)) = {3, 8, 6, 7, 1, 2, 4}*    B
ε-闭包(smove(A, b)) = {5, 6, 7, 1, 2, 4}*       C
ε-闭包(smove(B, a)) = {3, 8, 6, 7, 1, 2, 4}     B
ε-闭包(smove(B, b)) = {9, 5, 6, 7, 1, 2, 4}*    D
ε-闭包(smove(C, a)) = {3, 8, 6, 7, 1, 2, 4}     B
ε-闭包(smove(C, b)) = {5, 6, 7, 1, 2, 4}        C
ε-闭包(smove(D, a)) = {3, 8, 6, 7, 1, 2, 4}     B
ε-闭包(smove(D, b)) = {5, 10, 6, 7, 1, 2, 4}    E
ε-闭包(smove(E, a)) = {3, 8, 6, 7, 1, 2, 4}     B
ε-闭包(smove(E, b)) = {5, 6, 7, 1, 2, 4}        C
```
{{<image src="https://files.catbox.moe/act9lb.png" position="center" style="zoom: 40% ;">}}

#### 最小化DFA

**可区分**:对于DFA中的任何两个状态$t$和$s$，若从一状态出发接受输入字符串$\omega$，而从另一状态出发不接受$\omega$，则称 **$\omega$区分状态$t$和$s$**。如果存在某个能够区分状态$s$和状态$t$的串，那么它们是**可区分的**。

**最小化DFA算法**
1. 初始划分$\Pi=\\{S-F, F\\}, \Pi_{new} = \Pi$。$F$是终态集，$S-F$是非终态集
2. 应用下述过程构造新的划分$\Pi_{new}$:
    1. for $\Pi$的每一个组$G$
    2. loop 划分$G$, $G$的两个状态$s$和$t$在同一组中的充要条件是：
    $$\forall a \in \Sigma \forall G_i \in \Pi (move(s, a) \in G_i \leftrightarrow move(t, a) \in G_i)$$用新的划分组替代$G$, 形成新的划分$\Pi_{new}$;  
    end loop
3. 若$\Pi_{new}=\Pi$，令$\Pi_{final} = \Pi$，转4，否则令$\Pi = \Pi_{new}$并重复步骤2
4. 选代表并修改状态转移
5. 删除死状态，即不是终态且对所有输入字符均转向自身，或从初态不可到达的状态

#### 由DFA构造词法分析器

- 表驱动的词法分析器(自动生成)
- 直接编码的词法分析器

|   | 表驱动 | 直接编码 |
| -- | -- | -- |
| 分析器的速度  | 慢 | 快|
| 程序与模式的关系 | 无关| 有关 |
| 分析器的规模 | 较大 | 较小 |
| 适合编写的方法 | 工具生成| 手工编写 |


## 第三章 语法分析

### 基本术语

#### 语法分析器的作用

1. 根据词法分析器提供的记号流，为语法正确的输入**构造语法树**。
2. 检查输入中的语法（可能还包含词法错误），并调用出错处理器进行适当处理。

#### 语法错误的处理原则

##### 基本恢复策略

1. 紧急方式恢复：使用同步记号
2. 短语级恢复：采用串替换的方式
3. 出错产生式：捕获错误
4. 全局纠正

例：

```pascal
x := a + b
y := c + d;
```
- 紧急方式——丢弃b后若干记号，知道遇见+`x := a + b + d;`
- 短语级恢复——加入分号，使之成为一个赋值句`y := c + d;`

### 上下文无关法（Context Free Grammer，CFG）

#### CFG定义及表示

四元组$G=(N, T, P, S)$，其中
1. $N$——**非终结符**（Nonterminals）有限集合
2. $T$——**终结符**（Terminals）有限集合，$N \cup T = \emptyset $
3. $P$——**产生式**（Productions）有限集合，$A\rightarrow a$，其中$A \in N$(左部)，$a \in (N\cup T)^*$ (右部)，若$a = \epsilon$，则称$A \rightarrow \epsilon$为空产生式
4. $S$——$S$是非终结符，称为**开始符号**

##### 由产生式集表示CFG

- $E \rightarrow E + E$
- $E \rightarrow E * E$
- $E \rightarrow (E)$
- $E \rightarrow -E$
- $E \rightarrow id$

##### 终结符与非终结符书写上的约定

- 大写字母$A、B、C$表示非终结符
- 小写字母$a、b、c$表示终结符
- 小写希腊字母$\alpha、\beta、\delta $表示任意文法符号序列

#### CFG产生语言的基本方法——推导

- **直接推导**：$\alpha A \beta => \alpha \gamma \beta $
- **零布或多步推导**
- **至少一步推导**

##### 由CFG所产生的语言L(G)

$$L(G) = \\{ \omega | S \overset{+}{\Rightarrow} and \ \omega \in T^* \\} $$
$L(G)$称为**上下文无关语言**（Context Free Language, CFL）$\omega$成为句子，若$S \overset{*}{\Rightarrow} \alpha, \alpha \in (N \cup T)^{*} $，则称$\alpha$为$G$的一个**句型**。

##### 最左推导和最右推导（规范推导）

最左推导产生的句型称为**左句型**

### 推导与语法树

#### 语法树和抽象语法树

{{<image src="https://files.catbox.moe/fskbip.png" position="center" style="zoom: 80% ;">}}

#### 二义性与二义性的消除

- **二义性**：一个句子可能对应多棵语法树
    - 文法二义性：若文法$G$对同一句子产生不止一棵语法树，则称语法树$G$是二义的。或者说，若文法$G$对同一个句子存在两个不同的最左（最右）推导，则称文法$G$是二义的。
    - **语言的二义性**：如果产生上下文无关语言的每一个文法都是二义的，则此语言是二义的

- **二义性的消除**
    - 改写二义文法为非二义性文法
        1. 引入一个新的非终结符，增加一个子结构并提高一级优先级
        2. 递归非终结符在终结符左边，运算具有左结合性，否则具有右结合性
        {{<image src="https://files.catbox.moe/o3b2cj.png" position="center" style="zoom: 70% ;">}}
        消除“悬空else”问题  
        {{<image src="https://files.catbox.moe/9tosqb.png" position="center" style="zoom: 60% ;">}}
    - 为文法符号规定优先级和结合性
    - 修改语言的语法`end if`

### 语言与文法简介

#### 正规式与上下文无关法

##### 正规式到CFG的转换

- 若$0$为初态，则$A_0$为开始符号
- 对于$move(i,a)=j$，引入产生式$A_i→aA_j$
- 对于$move(i,ε)=j$，引入产生式$A_i→A_j$
- 若$i$是终态，则引入产生式$A_i →ε$。

{{<image src="https://files.catbox.moe/a0ttvr.png" position="center" style="zoom: 30% ;">}}

#### 上下文有关语言

- 不能用CFG描述的语言
    - $L1=\\{ \omega c \omega | \omega \in (a | b)^* \\}$标识符声明与引用一致性的抽象
    - $L2=\\{a^nb^mc^nd^m|n \ge 1\ and\ m \ge 1\\}$ 形参与实参一致性的抽象
    - $L3=\\{ a^nb^nc^n|n \ge 1\\}$ 计数问题的抽象
- 相近的CFL
    - $L1^{'}=\\{ \omega c \omega^r | \omega \in (a | b)^* \\} (S\rightarrow aSa\ |\ bSb\ |c)$
    - $L2^{'}=\\{ a^nb^mc^md^n|n\ge 1, m \ge 1\\} (S \rightarrow aSd\ | aAd\ A \rightarrow bAc\ |\ bc)$
    - $L2^{''}=\\{ a^nb^nc^md^m | n \ge 1, m \ge 1\\} (S \rightarrow AB\ A\rightarrow aAb\ |\ ab \ B\rightarrow cBd\ | cd) $
    - $ L3^{'}=\\{ a^mb^mc^m | m, n \ge 1\\}\ (S \rightarrow aAb | ab\  C\rightarrow cC|c)$

#### 形式语言与自动机简介

- 0型文法：若文法 $G=(N, T, P, S)$ 的每个产生式 $α→β$ 中 均有 $α∈(N∪T)^* $ 且至少含有一个非终结符 $β∈(N∪T)^*$则称 G 为 0 型文法 。
- 限制
    - $G $的任何产生式 $α→β$ ($S→ε$ 除外) 满足$ |α|≤|\beta |$
    - $G$ 的任何产生式形如 $A→β$ 其中 $A∈N\ β∈(N∪T)^*$
    - $G$ 的任何产生式形如 $A→a$ 或者 $A→aB$( 或者 $A→Ba$) 其中 $A$
和 $B$$∈N$ $a∈T$

| 文法 | 语言 | 自动机 |
| -- | -- | -- |
| 短语文法（0型） | 短语结构语言| 图灵机 |
| CSG（1型）| CSL | 线性界限自动机 |
| CFG（2型）| CFL | 下推自动机 |
| 正规文法 （3型）| 正规集 | 有限自动机 |

### 自上而下语法分析

#### 一般方法（试探＋回溯，边推导边匹配）

{{<image src="https://files.catbox.moe/imsqsp.png" position="center" style="zoom: 30% ;">}}

#### 消除左递归

- 消除直接左递归:
    $A\rightarrow Aα|β$替换为$A \rightarrow \beta A^{'}\ \ A^{'} \rightarrow \alpha A^{'} | \epsilon$
- 消除文法的左递归（直接/间接左递归）：
    合理排序非终结符：$A_1,A_2,…,A_n$(排序方法不唯一)
	用$A_j→δ_1|δ_2|...|δ_k$右部替换$A_i→A_jγ$中的$A_j$，得到$A_i→δ_1 γ|δ_2 γ|...|δ_k γ$；
	(如果有)消除$A_i$产生式中的直接左递归；
    {{<image src="https://files.catbox.moe/1bguuh.png" position="center" style="zoom: 30% ;">}}

#### 提取公因子

将$A \rightarrow \alpha {\beta}_1 | \alpha {\beta}_2$替换为$ A \rightarrow \alpha A^{'} \ A^{'} \rightarrow {\beta}_1|{\beta}_2$

#### 递归下降分析

...

#### 预测分析器

1. 非递归（表驱动）预测分析器的工作模式

    {{<image src="https://files.catbox.moe/b5qjym.png" position="center" style="zoom: 80% ;">}}
    - 工作方式
        - 格局：三元组(栈内容^top，剩余输入^ip，改变格局的动作)
        - 改变格局的动作
            1. 匹配终结符：若^top = ^ip(但≠‘#’)，则pop且next(ip)；
            2. 展开非终结符：若^top = X且^ip=a且M[X, a] = α(X→α)，则pop且push(α)（α逆序入栈）;
            3. 报告分析成功：若^top = ^ip = #，则分析成功并结束;
            4. 报告出错：其它情况，调用错误恢复例程。
    - 预测分析表
        {{<image src="https://files.catbox.moe/d8ffpi.png" position="center" style="zoom: 70% ;">}}
2. FIRST集合和FOLLOW集合
    - FIRST集合：$FIRST(\alpha) = \\{ a | \alpha \overset{*}{=>} a..., a \in T \\} $ $\alpha$的FIRST集合就是由**从$\alpha$开始可导出的文法符号序列的开头终结符**构成的集合。
        - 求解
            - 直接收取：对形如$U \rightarrow a...$ 的产生式（其中$a$是终结符），把$a$收入到$FIRST(U)$中
            - 反复传送：对形如$U \rightarrow P...$ 的产生式（其中$P$是非终结符，把$FIRST(P)$的内容传送到$FIRST(U)$中
    - FOLLOW集合：$FOLLOW(A)=\\{ a | S \overset{*}{=>} Aa \\}$ $A$的$FOLLOW$集合，就是由**从开始符号可导出的含A的文法符号序列中紧邻A之后的终结符**构成的集合。
        - 求解
            - 加入$ \\# $到$FOLLOW(S)$
            - 若有产生式$A \rightarrow \alpha B \beta $，则除$\epsilon$ 外，$FIRST(\beta)$的全体加入到$FOLLOW(B)$
            - 若有产生式$A \rightarrow \alpha B$或$A \rightarrow \alpha B \beta 且 \epsilon \in FIRST(\beta)$，则$FOLLOW(A)$的全体加入$FOLLOW(B)$
    - 例题
        
        {{<image src="https://files.catbox.moe/wou88k.png" position="center" style="zoom: 60% ;">}}
3. 构造预测分析表
    1. 对文法的每个产生式$A \rightarrow \alpha$，执行2和3；
    2. 对$FIRST(\alpha)$的每个终结符$a$，将$A \rightarrow \alpha$加入到$M[A, a]$中；
    3. 对$\epsilon \in FIRST(\alpha )$，则对$FOLLOW(A)$中的每个终结符$b$（包括$\\#$)，将$A \rightarrow a$加入到$M[A, b]$中。

4. LL(1)文法
    - 判断LL(1)文法的方法
        - 构造分析表
        - 推论判断：$G$是$LL(1)$的，当且仅当$G$的任何两个产生式$A \rightarrow \alpha | \beta$条件
            1. $FIRST(\alpha) \cap FIRST(\beta) = \emptyset$
            2. 若$\beta \overset{*}{=>} \epsilon$，则$FIRST(\alpha) \cap FOLLOW(A)=\emptyset$
    - 弱点
        - 难写、难懂
        - 应用范围有限，往往写不出来某些语言的$LL(1)$文法
        - 实际编译器中使用更多的是一类$LL(1)$文法的真超集，即$LR(1)$文法。

### 自下而上语法分析

#### 短语

设$\alpha \beta \delta$是文法$G$的一个句型，若存在$S \overset{*}{=>} \alpha \beta \delta$，$A \overset{+}{=>}\beta$，则称$\beta$是句型$\alpha \beta \delta$(相对于$A$)的短语。

- 直接短语：$A \rightarrow \beta$
- 句柄：一个句型地最左直接短语被称为句柄

#### 最左规约——”剪句柄“过程

{{<image src="https://i.loli.net/2021/05/19/N9jQmX3LCA4HMDR.png" position="center" style="zoom: 60% ;">}}

#### LR(k)文法

$L$表示从左到右扫描输入序列，$R$表示逆序的最右推导，$k$表示为确定下一动作向前看的终结符个数

#### LR分析法

- ACTION[s, a]：栈顶状态为s面临a时采取什么动作(shift or reduce)
- GOTO[s, X]：规约后对应的状态

{{<image src="https://i.loli.net/2021/05/20/LPUcian3HS54b7y.png" position="center" style="zoom: 60% ;">}}

#### LR(0)分析表的构造

##### 活前缀：为了描述LR分析中栈内的符号的特点

如果在符号序列$\alpha$的右边增添零个或多个终结符之后，能够形成一个右句型并且$\alpha$不含该句型句柄之后的任何符号，则称$\alpha$为文法$G$的活前缀。

对于规范句型$\alpha \beta \delta$，$\beta$为句柄，如果$\alpha \beta = u_1 u_2 ... u_r$，则符号串$u_1 u_2 ...u_i(1 \le i \le r)$时$\alpha \beta \delta$的**活前缀**


- 举例说明以下文法的活前缀
    $G: S \rightarrow aABe | aAbBec \ A \rightarrow b | bA \ B \rightarrow d $
- 活前缀：$a, aA, aAB, aABe, aAb, aAbBec, aAbd, aAd, ab, abb, abbb, ab+$

##### LR(0)项目

一个$LR(0)$项目(简称项目)是这样一个产生式，在它右部的某个位置有一个点$“.”$。**对于$A \rightarrow \epsilon$，它仅有一个项目$A \rightarrow .$**

- 意义
    - $A \rightarrow . XYZ$，说明希望从后面输入串中看到可以从$XYZ$推出的符号串，需要移进；
    - $A \rightarrow X . YZ$，说明已经从输入串中看到可以从$X$推出的符号串，希望进一步看到可以从$YZ$推出的符号串，需要继续移进。
    - $A→ XYZ . $，说明当前栈顶已经形成句柄，可以归约。

##### 识别文法G的活前缀的NFA

- 若状态$i$为$X \rightarrow X_1 ... X_{i-1} . X_i ... X_n$，状态$j$为$X \rightarrow X_1 ... X_{i-1} X_i . X_{i+1} ... X_n$，则从状态$i$连一条$X_i$有向边到状态$j$
- 若状态$i$为$X \rightarrow \alpha .A \beta$，A为非终结符，则从$i$连一条$\epsilon$到所有状态$A \rightarrow . \gamma$

{{<image src="https://i.loli.net/2021/05/20/JbYMeXTKA6CfzNj.png" position="center" style="zoom: 70% ;">}}

##### 确定化后的DFA

{{<image src="https://i.loli.net/2021/05/20/KWaSjp2GqLsbkZe.png" position="center" style="zoom: 60% ;">}}

##### LR(0)项目集规范族的构造

- 拓广文法$G^{'}= G \cup \\{ S^{'} \rightarrow S\\}$：**为了使得最终构造的DFA状态集中具有唯一的接收状态**
- NFA（项目）-> DFA（项目集）
    - $CLOSURE(I)$：从项目集$I$不经过任何文法符号到达的项目全体
    - $GO(I, X)$：所有从$I$经文法符号$X$能到达的项目全体（**与$somve$不同，$GO$含有闭包计算**）
- $CLOSURE(I)$计算方法：
    - $I$的任何项目属于$CLOSURE(I)$
    - 若$A \rightarrow \alpha . B \beta$属于$CLOSURE(I)$，项目$B \rightarrow .\gamma$也属于$CLOSURE(I)$
    - 重复以上步骤直到$CLOSURE(I)$不再增大
- $GO(I, X)=CLOSURE(J)$

##### 有效项目

若存在最右推导$S^{'} \overset{*}{=>}\alpha A \omega  => \alpha \beta_1 \beta_2 \omega $，则称项目$A \rightarrow \beta_1 . \beta_2$对活前缀$\alpha \beta_1$有效

- 意义
    - 到目前为止语法分析是正确的
    - 指导下一步的分析
        - $A \rightarrow \alpha a. \beta$（可移进项）
        - $B \rightarrow \beta.$（可规约项）

##### LR(0)分析表的构造

- 圆点后是终结符，需要填ACTION移进
- 圆点后是非终结符，需要填GOTO表
- 圆点后为空，需要填ACTION规约
