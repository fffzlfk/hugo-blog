---
title: "编译原理"
date: 2021-03-11T10:51:32+08:00
toc: true
draft: false
summary: "Compiler Principles" 
tags:
    - 编译原理
    - Academic
---

## 第一章 引言

### 语言之间的翻译

{{<image src="https://files.catbox.moe/wi466j.png" position="center" style="zoom: 30% ;">}}

### 编译器与解释器

#### 语言翻译两种基本形态

- 先翻译后执行
- 边翻译边执行

### 编译器的工作原理和基本组成

#### 通用程序设计语言的主要成分

**声明+定义**

#### 以阶段划分编译器

{{<image src="https://files.catbox.moe/javh21.png" position="center" style="zoom: 70% ;">}}

#### 编译器的分析/综合模式

{{<image src="https://files.catbox.moe/phca02.png" position="center" style="zoom: 80% ;">}}

## 第二章 词法分析

### 词法分析中的若干问题

#### 记号、模式与单词

| 单词的基本分类 | |
| -- | -- |
| 关键字（保留字） | key(key word, or reversed word) |
| 标识符 | id(identifier) |
| 字面量 | literal |
| 特殊符号 | ks(key symbol, or special symbol)|

**记号=记号的类别+记号的属性**

### 模式的形式化描述

#### 字符串与语言

- 定义2.1：语言$L$是**有限**字母表$\sum$上**有限**长度**字符串**的集合。

- 字符串：由字母表中的符号组成的任意有穷序列。
- 字符串的长度：字符串中的符号个数。

##### 字符串基本概念

| 表示、术语 | 举例 |
| -- | -- |
| $\|S\|$ | $\|abc\|= 3$ |
| $\varepsilon$ | $\| \varepsilon\| = 0$ |
| $S1S2$ | $"abc""def"="abcdef"$ |
| $S^n$（幂）| $"abc"^3 ="abcabcabc"$ |
| $S$的前缀 | $"abc"$的前缀可以是：$ε，a，ab, abc$ |
| $S$的后缀 | $"abc"$的后缀可以是：$ε，c，bc, abc$ |
| $S$的子串 | $"abc"$的子串可以是$ε，a，b, c, …$|
| $S$的真前缀 | $"abc"$的真前缀：$a, ab$ |
| $S$的真后缀 | $"abc"$的真后缀：$c, bc$ |
| $S$的真子串 | $"abc"$的真子串：$a, b, c, ab, bc $ |
| $S$的子序列 | $"abdf"$是$"abcdef"$的一个子序列（$S$中去掉$0$或若干个不一定连续的字符后形成的字符串）|
| $S$的逆转$S^R$ | $S=abc,S^R=cba$ |

##### 字符串集合的运算

| 表示、术语 | 意义 |
| -- | -- |
| $\varnothing$ | 空集合 |
| $\{\epsilon\}$ | 空串作为唯一元素的集合 |
| $X = L \cup M$ | 集合的并：$ X = \\{ s \| \in L\ or\ s \in M \\} $|
| $X = L \cap M$ | 集合的交：$ X = \\{ s \| \in L\ and\ s \in M \\} $|
| $X = L \cap M$ | 集合的连接：$ X = \\{ st \| \in L\ and\ s \in M\\} $|
| $X = L^0$ | 集合的连接：$ L^0 = \\{ \epsilon \\} $|
| $X = L^*$ | 集合的Kleene闭包：$X=L^0 \cup L^1 \cup L^2 \cup ... $ |
| $X = L^+$ | 集合的正闭包：$X=L^1 \cup L^2 \cup L^3 \cup ... $ |


#### 正规式与正规集

##### 正规式的递归定义

1. **$\epsilon$和$\varnothing$都是$\sum$上的正规式**，它表示$L(\epsilon)=\\{ \epsilon \\}$和$\varnothing$
2. 若$a$是$\sum$上的字符，**则$a$是正规式**，表示$L(a)=\\{a\\}$
3. 若正规式$r$和$s$分别表示$L(r)$和$L(s)$:
    - $r \| s$是正规式，表示集合$L(r)\cup L(s)$
    - $rs$ 是正规式，表示集合$L(r)L(s)$
    - $r^* $ 是正规式，表示集合 $(L(r))* $
    - $r$是正规式，表示集合仍是$L(r)$

##### 运算

- 运算符的优先级与结合性
    1. 三种运算均具有左结合性质
    2. 优先级从高到低排列顺序为：**闭包运算、连接运算、或运算**
- 正规式的等价：若正规式$P$和$Q$表示了同一个正规集，则称P和Q是等价的，记为$P=Q$
- 正规式等价的判定（证明）
    - 根据定义
    - 利用代数性质
        1. $ r|s = s|r $
        2. $r|(s|t) = (r|s)|t$
        3. $r(s|t) = rs|rt$
        4. $(s|t)r = sr|tr $
        5. $(rs)t = r(st)$
        6. $εr = rε = r$
        7. $r^* = (r+|ε) $
        8. $r^{\*\*} = r^* $

#### 记号的说明

例如：

```
relation = < | <= | <> | > | >= | =

id = (a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z
       |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z)
     (a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z
     |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z
     |0|1|2|3|4|5|6|7|8|9)*

num = (0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*
      (ε|.(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*)
      (ε|E(+|-|ε)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*)
```

- 简化正规式描述
    - 正闭包：$r^+ = rr^* = r^* r，r^* = r^+|ε$
    - 可缺省：$r?=r|ε$
    - 字符组：如$[abc]$，它等价于：$a|b|c$
    - 非字符组：$[^r]$
- 引入辅助定义
```
char              = [a-zA-Z]
digit             = [0-9]
digits            = digit+
optional_fraction = ( . digits )?
optional_exponent = ( E (+|-)? digits )?

id  = char ( char|digit )*
num = digits optional_fraction optional_exponent
```

### 记号的识别-有限自动机

#### 不确定的有限自动机（Nondeterministic Finite Automaton，NFA）

**定义**：$M=(S, \sum, move, s_0, F) $
- $S$是有限个状态(state)的集合
- $\sum$是有限个输入字符 包括 $ε$ 的集合
- $move(s_i, ch)=s_j$
- $s_0$是唯一的初态
- $F$是终态集

##### 直观的表示方式
1. 状态转换图
2. 状态转换矩阵
{{<image src="https://files.catbox.moe/7xnams.png" position="center" style="zoom: 60% ;">}}
{{<image src="https://files.catbox.moe/xlnj3y.png" position="center" style="zoom: 80% ;">}}

##### NFA存在的问题

1. 只有尝试了全部可能的路径，才能确定一个输入序列不被接受，而这些路径的条数随着路径长度的增长成指数增长
2. 识别过程中需要大量的回溯，时间复杂度升高且算法趋于复杂

#### 确定的有限自动机（Deterministic Finite Automaton，DFA）

**定义**：DFA是NFA的一个特例，其中
1. 没有状态具有$\epsilon$状态转移$(\epsilon -transition)$，即状态图中没有标记$\epsilon$的边
2. 对每个状态$s$和每个字符$a$，最多有一个下一状态

##### 模拟DFA算法

```pascal
s := s0; ch := nextchar;    -- 初值
while ch != eof             -- 循环
loop s := move(s, ch);
     ch := nextchar;
end loop;
if s in F
then return "yes"; else return "no";
end if;
```

### 从正规式到词法分析器

#### 构造词法分析器的方法和步骤

1. 用正规式描述模式
2. 构造NFA
3. 确定化（转换成等价的DFA）
4. 最小化（优化DFA）
5. 从优化后的DFA构造词法分析器

#### 从正规式到NFA

**Thompson算法**

1. 对$\epsilon$，$N(\epsilon)$：
{{<image src="https://files.catbox.moe/qv83fk.png" position="center" style="zoom: 30% ;">}}
2. 对于$\sum$上的每个字符$a$，$N(a)$：
{{<image src="https://files.catbox.moe/uie9rx.png" position="center" style="zoom: 30% ;">}}
3. 若$N(p)$和$N(q)$是正规式$p$和$q$的NFA
    1. 对于$p|q$，构造$N(p|q)$：{{<image src="https://files.catbox.moe/cn7ny1.png" position="center" style="zoom: 30% ;">}}
    2. 对于正规式$pq$，构造NFA $N(pq)$：{{<image src="https://files.catbox.moe/zexlif.png" position="center" style="zoom: 30% ;">}}
    3. 对于正规式$p^* $，构造NFA $N(p^{*})$：{{<image src="https://files.catbox.moe/hn9frb.png" position="center" style="zoom: 30% ;">}}

#### 从NFA到DFA

##### 并行方法

- $smove(S, a)$：从状态集$S$中的每个状态出发，经过标记为$a$的边直接到达的下一状态全体
- $\epsilon$-闭包：从状态T出发，经过若干次$\epsilon$转移到达的状态全体

**$\epsilon$-闭包 的定义**
1. T中的所有状态属于$\epsilon$-闭包
2. 如果$t$属于$\epsilon$-闭包(T)且$move(t, \epsilon)=u$，则$u$属于$\epsilon$-闭包(T)
3. 再无其它状态属于$\epsilon$-闭包(T)

**求$\epsilon$-闭包 的算法**

```pascal
function ε-闭包(T) is
begin
    for T中的每个状态t
    loop 加入t到U; push(t);
    end loop;
    while 栈不空
    loop pop(t);
        for 每个u=move(t, ε)
        loop if u不在U中 then 加入u到U中; push(u); endif;
        end loop;
    end loop;
    return U;
end ε-闭包;
```

**模拟NFA**

```pascal
S := ε-闭包({s0});              -- 所有可能初态的集合
a := nextchar;
while a != eof
loop
    S := ε-闭包(smove(S, a));   -- 所有下一状态的集合
    a := nextchar;
end loop;
if S and F != nil then return "yes"; else return "no";
end if;
```