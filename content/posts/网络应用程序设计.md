---
title: "网络应用程序设计"
date: 2021-04-07T20:48:12+08:00
toc: true
draft: false
summary: Network Program Design for Application
tags:
    - Academic
---

## 基本socket函数

### 创建网络端点

- 创建socket描述符
```c
int socket (int family, int type, int protocol)
```

### Socket地址

#### TCP/IP协议的socket地址

```c
struct sockaddr_in {
        short 		    sin_family;    /*AF_INET*/
        u_short 		sin_port;      /*端口号，网络字节顺序*/
        struct n_addr 	sin_addr;      /*IP地址，网络字节顺序*/
        char    		sin_zero[8];   /*填充字节，必须为全零*/
};

struct in_addr {
  	union {
          		struct { u_char s_b1,s_b2,s_b3,s_b4; }   S_un_b;
          		struct { u_short s_w1,s_w2; }   S_un_w;
         		 u_long   S_addr;
 	 } S_un;
};
```

#### 地址转换函数

- 字符串形式地址转换为网络地址形式`inet_aton(const char *cp,struct in_addr *inp);`
- 网络地址转换为字符串地址形式`char* inet_ntoa(struct in_addr in);`

### 字节顺序

#### 主机字节顺序

- `little-endian`低字节在前
- `big-endian`高字节在前

#### 网络字节顺序

采用`big-endian`顺序

#### 主机字节顺序和网络字节顺序的转换

```c
unsigned short int htons(unsigned short int hostshort)
unsigned long int htonl(unsigned long int hotlong)
unsigned short int ntohs(unsigned short int netshort)
unsigned long int ntohl(unsigned long int netlong)
```

### 连接服务器

```c
int connect(int sockfd,struct sockaddr *servaddr,int addrlen)
```

### 绑定服务器地址和端口

```c
int bind(int sockfd,struct sockaddr *myaddr,int addrlen); 
```

### 监听端口

```c
int listen(int sockfd,int backlog)
```
- sockfd－已绑定的socket描述符
- backlog－以完成连接，等待接受的队列长度

### 接收客户端连接

```c
int accept(int sockfd,struct sockaddr *clientaddr,int addrlen);
```

### 代码示例

#### server

```c
#include <arpa/inet.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

#define MAXDATASIZE 128
#define PORT 3000
#define BACKLOG 5

int main(int argc, char **argv) {
    int sockfd, new_fd, nbytes, sin_size;
    char buf[MAXDATASIZE];
    struct sockaddr_in srvaddr, clientaddr;

    // 1.创建网络端点
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        printf("can;t create socket\n");
        exit(1);
    }

    if (argc == 2) {
        int on = 1;
        setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
        printf("reuse addr\n");
    }
    //填充地址
    bzero(&srvaddr, sizeof(srvaddr));
    srvaddr.sin_family = AF_INET;
    srvaddr.sin_port = htons(PORT);
    srvaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    /*
    if(inet_aton(argv[1],&srvaddr.sin_addr)==-1){
            printf("addr convert error\n");
            exit(1);
    }
    */
    // 2.绑定服务器地址和端口
    if (bind(sockfd, (struct sockaddr *)&srvaddr, sizeof(struct sockaddr)) ==
        -1) {
        printf("bind error\n");
        exit(1);
    }
    // 3. 监听端口
    if (listen(sockfd, BACKLOG) == -1) {
        printf("listen error\n");
        exit(1);
    }
    for (;;) {
        // 4.接受客户端连接
        sin_size = sizeof(struct sockaddr_in);
        if ((new_fd = accept(sockfd, (struct sockaddr *)&clientaddr,
                             &sin_size)) == -1) {
            printf("accept error\n");
            continue;
        }
        printf("client addr:%s %d\n", inet_ntoa(clientaddr.sin_addr),
               ntohs(clientaddr.sin_port));
        // 5.接收请求
        getchar();
        nbytes = read(new_fd, buf, MAXDATASIZE);
        buf[nbytes] = '\0';
        printf("client:%s\n", buf);

        // 6.回送响应
        sprintf(buf, "wellcome!");
        write(new_fd, buf, strlen(buf));
        //关闭socket
        close(new_fd);
    }
    close(sockfd);

    return 0;
}
```

#### client

```c
#include <arpa/inet.h>
#include <errno.h>
#include <netdb.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

#define MAXDATASIZE 128
#define PORT 3000

int addr_conv(char *address, struct in_addr *inaddr);

int main(int argc, char **argv) {
    int sockfd, nbytes;
    int port = PORT;
    char buf[MAXDATASIZE];
    struct sockaddr_in srvaddr;
    if (argc != 2 && argc != 3) {
        printf(
            "usage:./client hostname|ip. Or usage:./client hostname|ip port\n");
        exit(0);
    }

    if (argc == 3) port = atoi(argv[2]);
    // 1.创建网络端点
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        printf("can;t create socket\n");
        exit(1);
    }
    //指定服务器地址（本地socket地址采用默认值）
    bzero(&srvaddr, sizeof(srvaddr));
    srvaddr.sin_family = AF_INET;
    srvaddr.sin_port = htons(port);
    /*
    if(inet_aton("127.0.0.1",&srvaddr.sin_addr)==-1){
            printf("addr convert error\n");
            exit(1);
    }
    */
    if (addr_conv(argv[1], &srvaddr.sin_addr) == -1) {
        perror(strerror(errno));
    }
    // 2.连接服务器
    if (connect(sockfd, (struct sockaddr *)&srvaddr, sizeof(struct sockaddr)) ==
        -1) {
        printf("connect error\n");
        exit(1);
    }
    // 3.发送请求
    sprintf(buf, "hello");
    write(sockfd, buf, strlen(buf));
    sprintf(buf, "hello2");
    write(sockfd, buf, strlen(buf));
    sprintf(buf, "hello3");
    write(sockfd, buf, strlen(buf));
    // 4.接收响应
    if ((nbytes = read(sockfd, buf, MAXDATASIZE)) == -1) {
        printf("read error\n");
        exit(1);
    }
    buf[nbytes] = '\0';
    printf("srv respons:%s\n", buf);
    //关闭socket
    close(sockfd);
    return 0;
}

int addr_conv(char *address, struct in_addr *inaddr) {
    struct hostent *he;
    if (inet_aton(address, inaddr) == 1) {
        printf("call inet_aton sucess.\n");
        return 0;
    }
    printf("call inet_aton fail.\n");
    he = gethostbyname(address);
    if (he != NULL) {
        printf("call gethostbyname sucess.\n");
        *inaddr = *((struct in_addr *)(he->h_addr_list[0]));
        return 0;
    }
    return -1;
}
```

## 高级socket函数

### DHCP

**动态主机配置协议**（Dynamic Host Configuration Protocol）

#### 分配方式

- 自动分配
- 动态分配
- 人工分配

#### DHCP过程

{{<image src="https://files.catbox.moe/exth7w.png" position="center" style="zoom: 80% ;">}}

### 域名访问

#### 域名系统——DNS

- 域名查找过程

{{<image src="https://files.catbox.moe/9rdt4n.png" position="center" style="zoom: 60% ;">}}

#### 域名到IP的转换函数

```c
struct hostent* gethostbyname(const char *name)

struct hostent{
	char	h_name;	        /*主机正式名称*/
	char	**h_aliases;	/*别名列表，以NULL结束*/
	int 	h_addrtype;	    /*主机地址类型：AF_INET*/
	int 	h_length;	    /*主机地址长度：4字节32位*/
	char 	**h_addr_list;	/*主机网络地址列表，以NULL结束*/
}
#define 	h_addr 	h_addr_list[0]; //主机的第一个网络地址
```
示例代码

```c
#include <arpa/inet.h>
#include <fcntl.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

int main(int argc, char **argv) {
    if (argc != 2) {
        printf("invalid args\n");
    }
    struct hostent *he;
    he = gethostbyname(argv[1]);

    if (he != NULL) {
        printf("h_name:%s\n", he->h_name);
        printf("h_length:%d\n", he->h_length);
        printf("h_addrtype:%d\n", he->h_addrtype);
        int i;
        for (i = 0; he->h_aliases[i] != NULL; i++)
            printf("h_aliases[%d]:%s\n", i + 1, he->h_aliases[i]);
        printf("first ip:%s\r\n", inet_ntoa(*((struct in_addr *)he->h_addr)));

        for (i = 0; he->h_addr_list[i] != NULL; i++)
            printf("ip%d:%s\n", i + 1,
                   inet_ntoa(*(struct in_addr *)he->h_addr_list[i]));

    } else {
        printf("gethostbyname error: %s\n", hstrerror(h_errno));
    }
    return 0;
}
```

#### IP到域名的转换函数

- 查询IP对应的域名

```c
struct hostent *gethostbyaddr(const char *addr, size_t len, in family);
```
- 示例代码

```c
#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>

int main(int argc, char *argv[]) {
    struct in_addr addr;

    inet_aton(argv[1], &addr);

    struct hostent *he;
    he = gethostbyaddr((char *)&addr, 4, AF_INET);

    if (he != NULL) {
        printf("h_name: %s\n", he->h_name);
    } else {
        printf("gethostbyaddr error: %s", hstrerror(h_errno));
    }
    return 0;
}
```

### 高级Socket函数

#### recv和send

```c
int recv(int sockfd,void* buf,int len, int flags);
int send(int sockfd,void* buf,int len,int flags);
```

#### shutdown关闭连接

```c
int shutdown(int sockfd,int howto); 
```
- `howto = 0`对后来接收到的数据返回确认后丢弃
- `howto = 1`继续发送发送缓冲区未发送完的数据，然后发送FIN字段关闭写通道
- `howto = 2`关闭读写通道，任何进程不能再操作这个socket
    - 与`close`的区别
        - shutdown操作连接通道，其他进程不能再使用已被关闭的通道；close操作描述符，其他进程仍然可以使用该socket描述符
        - close关闭应用程序与socket的接口，调用close之后进程不能再读写这个socket；shutdown可以只关闭一个通道，另一个通道仍然可以操作



## UDP与原始Socket编程

### UDP Socket编程

{{<image src="https://files.catbox.moe/k0q0ar.png" position="center" style="zoom: 60% ;">}}

#### `recvfrom`：接受UDP数据包

```c
int recvfrom(int sockfd, void *buf, int len, unsigned char flags,
             struct socketaddr *from, socklen_t *addrlen);
```
#### `sendto`：发送UDP数据包

```c
int sendto(int sockfd,const void *buf,int len,unsigned char flags,
           struct socketaddr *to,int  tolen); 
```

#### UDP服务器

- 服务器不接受客户端连接，只需监听端口
- 循环服务器，可以交替处理各个客户端数据包

```cpp
#include <arpa/inet.h>
#include <errno.h>
#include <netdb.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <unistd.h>

#include <iostream>

using namespace std;

int main(int argc, char **argv) {
    if (argc != 2) {
        cout << "argument invalid" << endl;
        return 1;
    }
    short port = atoi(argv[1]);

    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd == -1) {
        cout << "create socket error" << endl;
        return 1;
    }
    sockaddr_in addr;
    bzero(&addr, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = htonl(INADDR_ANY);
    //绑定服务器地址
    if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
        cout << "bind error" << endl;
        return 1;
    }
    for (;;) {
        char buf[32];
        sockaddr_in client_addr;
        socklen_t addr_len;
        //接收客户端数据包
        int n = recvfrom(sockfd, buf, 16, 0, (struct sockaddr *)&client_addr,
                         &addr_len);
        if (n >= 0) {
            buf[n] = 0;
            cout << "recv:" << buf << endl;
            struct timeval tv;
            gettimeofday(&tv, NULL);
            sprintf(buf, "%d %d", (int)tv.tv_sec, (int)tv.tv_usec);
            //利用recvfron中得到的地址回送数据包
            sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)&client_addr,
                   sizeof(client_addr));
        }
    }
    close(sockfd);
    return 0;
}
```

#### UDP客户端

- 客户端不用建立连接，第一次调用sendto函数时，**UDP协议为这个UDP socket选择一个端口号，以后的发送和接受操作均使用这个端口号**。
- 客户端可以接收来自任何主机的数据报 
- 客户端可能永远阻塞（服务器主机崩溃） 

```cpp
#include <arpa/inet.h>
#include <errno.h>
#include <netdb.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

#include <iostream>

using namespace std;

int main(int argc, char **argv) {
    if (argc < 2) {
        cout << "argument invalid" << endl;
        return 1;
    }
    short port = atoi(argv[1]);

    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd == -1) {
        cout << "create socket error" << endl;
        return 1;
    }

    sockaddr_in addr;
    bzero(&addr, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = htonl(INADDR_ANY);
    if (argc == 3 && strcmp(argv[2], "-c") == 0) {
        //记录服务器地址
        connect(sockfd, (struct sockaddr *)&addr, sizeof(addr));
    }
    for (int i = 0; i < 10; i++) {
        char buf[16];
        sprintf(buf, "%d hello", getpid());
        cout << "send:" << buf << endl;
        int n;
        if (argc == 3 && strcmp(argv[2], "-c") == 0) {
            //发送时不需要服务器地址
            n = sendto(sockfd, buf, strlen(buf), 0, NULL, 0);
        } else {
            //发送时需要服务器地址
            n = sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)&addr,
                       sizeof(addr));
        }
        n = recvfrom(sockfd, buf, 16, 0, NULL, NULL);
        if (n >= 0) {
            buf[n] = 0;
            cout << "recv:" << buf << endl;
        }
        sleep(1);
    }
    close(sockfd);
    return 0;
}
```

#### 有连接的UDP Socket

- 在UDP Socket上调用connect函数，但不会产生3次握手过程，只记录连接另一方的IP和端口，connect函数马上返回

#### 使用UDP Socket的说明

- UDP协议不保证数据包可靠到达（**超时和重发机制**）
- UDP协议不保证数据报顺序到达（**数据报序列号**区分）
- UDP协议没有流控

### 原始Socket编程

#### 概述

- TCP、UDP Socket对TCP协议和UDP协议做了封装来简化编程接口，但失去了对IP数据包操作的灵活性
- 原始Socket直接针对IP数据包编程，具有更强的灵活性
- 可以编写基于IP协议的高层协议

#### 发送数据包

- 没有调用`connect`函数绑定对方地址时必须用`sendto`或`sendmsg`发送数据包；调用`connect`绑定对方IP地址后，可以使用`write`和`send`发送数据包

#### 接收数据包

- UDP包和TCP包
- 大多数ICMP包的拷贝将传递给原始socket
- 其他类型的数据包的拷贝传递给匹配的socket
- 内核不能识别的IP数据包将传送给匹配的原始socket

## Linux进程与信号机制

### 概述

- linux进程是系统进行资源分配和调度的基本单位。
- 进程的状态：
    1. 新建
    2. 运行
    3. 阻塞
    4. 就绪
    5. 完成
- 按继承关系分类
    1. 父、子、孙进程
    2. 兄弟进程
    3. 孤儿进程

### 创建进程

- `pid_t fork(void);`
    - 功能：创建新的进程，调用者成为父进程，产生的新进程成为子进程
    - 返回值：
        - `> 0`, 子进程的id，只在父进程中返回
        - `-1`, 调用失败
        - `=0`, 只在子进程中返回
    - 头文件：`#include <sys/types.h>` `#include <unistd.h>`
- fork的原理
    - 两次返回
        - 调用fork的进程（父进程）返回正整数（子进程ID）
        - 在新创建的进程（子进程）中返回0，表示是子进程
    - 在调用fork时发生了什么
        - 系统创建新进程，并为该进程准备数据段、堆栈段和代码段
        - 代码段使用和父进程相同的代码段
        - 父进程的数据段和堆栈段被复制（[copy on write, 写入时复制](https://zh.wikipedia.org/wiki/%E5%AF%AB%E5%85%A5%E6%99%82%E8%A4%87%E8%A3%BD)）给子进程
    {{<image src="https://files.catbox.moe/6yhyeq.png" position="center" style="zoom: 60% ;">}}
    - 子进程和父进程共享的内容
        - **代码段**
        - 用户标识符
        - 环境变量
        - **打开的文件描述符(Socket描述符)**
        - 根目录
        - 当前工作目录
        - 创建文件的模式
        - :warning: 数据段和堆栈段通过复制方式共享，因此子进程或父进程修改了变量值后不会影响另一个进程，即使是全局变量。
    - 父子进程执行顺序随机
- 执行另一个程序
    - `int execve(const char *path,char * const argv[],char *envp);`只有execve是真正的系统调用
    - `int execl(const char *path, const char * argv,…);`
- 注意：
    1. `fork()`和`exec()`这两个函数，前者用于并行执行，父、子进程执行相同正文中的不同部分；后者用于调用其他进程，进程执行新的正文。
    2. `fork()`以后，父、子进程共享代码段，并只重新创建数据有改变的页（段页式管理）
    3. `exec()`以后，建立新的代码段，用被调用程序的内容填充。
    4. 前者的子进程执行后续的公共代码，后者的子进程不执行后续的公共代码

```cpp
#include <iostream>
#include <unistd.h>
using namespace std;

int main() {
    pid_t pid;

    if ((pid = fork()) == 0) {
        // 子进程
        cout << "Son Process" << endl;
        exit(0);
    } else if (pid > 0) {
        // 父进程
        cout << "Father Process" << endl;
        exit(0);
    } else {
        cout << "Error" << endl;
        exit(1);
    }
    return 0;
}
```


### 信号机制

- 发送信号
    - `int kill(pid_t pid, int sig)`
    - `int raise(int sig)`向进程自身发送信号
    - `unsigned int alarm(unsigned int seconds)`
    - `void abort()`
    - `int sigqueue(pid_t pid, int sig, const union sigval val)`

### 进程终止

`exit()`

### 处理子进程死亡

- 僵尸进程（zombie）
    - 子进程终止时如果父进程存在且未处理SIGCHLD信号则子进程变为僵尸进程
    - 僵尸进程占据系统进程表项
    - 对比孤儿进程
        - 子进程终止，父进程并没有调用 wait/waitpid 获取子进程的终止状态，且父进程还没有结束（子进程没有被 init 收养），那么当子进程结束后，它的进程描述符仍然保存在系统中，这就成了僵尸进程。
        - 子进程还没有结束，但是父进程结束了，这个时候子进程失去其唯一的父进程，成为了孤儿进程。
- **清理僵尸进程的方法1**
    - 忽略SIGCHLD信号（使用信号处理函数（SIG_IGN)
    - 忽略SIGCHLD信号时，系统将清除子进程的进程表项，这种方法依赖于Linux版本的实现
- 终端操作
    - `top`，查看动态进程状态
    - `ps -A -ostat, ppid, pid, cmd | grep -e '^[Zz]'，查看僵尸进程
    - `kill -HUP xxxx`, 清除僵尸
- **清除僵尸进程的方法2**
    - 调用`wait`或`waitpid`等待子进程
        - `pid_t wait(int *status);`等待任意子进程终止，没有子进程终止时阻塞，如果没有子进程返回`-1`
        - `pid_t waitpid(int pid, int *status, int option)`
        - 此方法没有兼容性问题
- **清除僵尸进程的方法3**
    - 捕获SIGCHLD信号
- **清除僵尸进程的方法4**
    - 调用`fork()`两次，使得子进程成为孤儿进程，由init管理
        - 这种方法第一次调用fork产生的子进程可能成为僵尸进程
        - 这种方法第二次调用fork产生的子进程由init处理子进程退出，不会成为僵尸进程
        >通俗点讲，就是爷爷第一次 fork 生一个老爸，老爸出生后立刻 fork 生下儿子，这个时候老爸的任务就结束了，可以死掉了 (exit)，这个时候儿子被强大的 init 收养，爷爷爱干啥干啥，从而儿子永远不会成为僵尸进程。
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid;

    if ((pid = fork()) == 0) {
        pid = fork();
        if (pid > 0) {
            // 父亲生下儿子直接退出，儿子会被收养
            exit(0);
        }

        sleep(0.5);
        printf("I'm son after second fork.\n");
        printf("my parent's pid: %d\n", getppid());

        exit(0);
    }

    // 爷爷生下父亲后直接等待为其收尸
    waitpid(pid, NULL, 0);

    // 爷爷尽情快活

    return 0;
}
```

### 进程同步

当fork调用成功后，父子进程各做各的事情，但当父进程的工作告一段落，需要用到子进程的结果时，它就停下来调用wait，一直等到子进程运行结束，然后利用子进程的结果继续执行。

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

int main() {
    pid_t pc, pr;
    int status;

    pc = fork();
    if (pc < 0)
        printf("Error occured on forking.\n");
    else if (pc == 0) {
        /* 子进程的工作 */
        printf("son\n");
        exit(0);
    } else {
        /* 父进程的工作 */
        printf("father\n");
        pr = wait(&status);
        /* 利用子进程的结果 */
    }
    return 0;
}
```