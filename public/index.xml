<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fffzlfk&#39;s Blog</title>
    <link>https://fffzlfk.gitlab.io/</link>
    <description>Recent content on fffzlfk&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Tue, 02 Feb 2021 14:23:44 +0800</lastBuildDate><atom:link href="https://fffzlfk.gitlab.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python装饰器</title>
      <link>https://fffzlfk.gitlab.io/posts/python%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
      <pubDate>Tue, 02 Feb 2021 14:23:44 +0800</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/posts/python%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
      <description>引入 当我们想在一个函数执行前后干点什么事情的时候，可以这么写：
def foo(): print(&amp;#39;foo()!!!&amp;#39;) def bar(): print(&amp;#39;Before&amp;#39;) foo() print(&amp;#39;After&amp;#39;) bar() 装饰器实现 但这样看着总是很别扭，我们可以写成这样：
def foo(): print(&amp;#39;foo()!!!&amp;#39;) def bar(func): def inner(): print(f&amp;#39;Before {func.__name__}&amp;#39;) func() print(f&amp;#39;After {func.__name__}&amp;#39;) return inner bar(foo)() .notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative}Note
在Python中function是第一公民，所以可以它作为参数
这样我们就实现了一个简单的装饰器，我们可以发现这样在调用的时候比较麻烦，Python还提供了这样了一个语法糖：
def bar(func): def inner(): print(f&amp;#39;In Bar Before {func.__name__}&amp;#39;) func() print(f&amp;#39;In Bar After {func.__name__}&amp;#39;) return inner @bar def foo(): print(&amp;#39;foo()!!!&amp;#39;) foo() 除此之外，Python装饰器可以有多个，相当与一层层的包裹：
def bar(func): def inner(): print(f&amp;#39;In Bar Before {func.</description>
    </item>
    
    <item>
      <title>AcWing寒假每日一题</title>
      <link>https://fffzlfk.gitlab.io/posts/acwing%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</link>
      <pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/posts/acwing%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</guid>
      <description>Week 1 货仓选址 题目链接
思路 绝对值不等式：$|a_1 - x| + |a_2 - x| + |a_3 - x| + &amp;hellip; + |a_n - x| \ge |a_n-a_1| + |a_{n-1}-a_{2}|+&amp;hellip; $ 结论：当n为奇数，x应在中位数；当n为偶数时，x应在中间两个数之间。
代码 #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std; const int N = 100005; int a[N]; int n; int main() { cin &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; n; i++) cin &amp;gt;&amp;gt; a[i]; sort(a, a + n); int ans = 0; for (int i = 0; i &amp;lt; n; i++) ans += abs(a[i]-a[n/2]); cout &amp;lt;&amp;lt; ans; return 0; } 数字三角形-DP 题目链接</description>
    </item>
    
    <item>
      <title>SQL</title>
      <link>https://fffzlfk.gitlab.io/posts/sql/</link>
      <pubDate>Sat, 24 Oct 2020 20:22:42 +0800</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/posts/sql/</guid>
      <description>SQL概述 SQL的特点  综合统一：集DQ、DDL、DML、DCL于一体 高度非过程化：不用考虑如何实现，只需提出“做什么”，不关心“怎么做” 面向集合的操作方式：查询、插入、删除、更新操作对象及结果都是集合 以同一种语法结构提供两种使用方法：可交互式和嵌入式使用 以简捷的自然语言实现对数据库的定义、操作和控制功能：定义了少量的关键字实现对数据库的定义、操纵和控制功能  SQL所使用的动词（核心功能）    SQL功能 动词     数据查询 SELECT   数据定义 CREATE, DROP, ALTER   数据操作 INSERT, UPDATE, DELETE   数据控制 GRANT, REVOKE    数据定义 SQL的数据定义语句 SQL中的数据类型 基本表的定义 创建基本表 CREATE TABLE &amp;lt;表名&amp;gt; ( &amp;lt;列名&amp;gt; &amp;lt;数据类型&amp;gt;[&amp;lt;列级完整性约束条件&amp;gt;] [, &amp;lt;列名&amp;gt; &amp;lt;数据类型&amp;gt;[&amp;lt;列级完整性约束条件&amp;gt;] ] … [, &amp;lt;表级完整性约束条件&amp;gt; ] ) ;  常用的完整性约束  主码约束：PRIMARY KEY (&amp;lt;列名1&amp;gt;, &amp;lt;列名2&amp;gt;,…) 非空值约束：NOT NULL 唯一性约束：UNIQUE 参照完整性约束：FOREIGN KEY (&amp;lt;列名&amp;gt;) REFERENCES &amp;lt;表名&amp;gt;(&amp;lt;列名&amp;gt;) 一般性约束：CHECK(&amp;lt;谓词&amp;gt;)    删除基本表 DROP TABLE &amp;lt;表名&amp;gt; [RESTRICT|CASCADE];   RESTRICT：删除表是有限制的：</description>
    </item>
    
    <item>
      <title>微机原理</title>
      <link>https://fffzlfk.gitlab.io/posts/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sat, 17 Oct 2020 21:07:26 +0800</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/posts/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/</guid>
      <description>单核处理器8086/8088 寄存器结构 通用寄存器    Reg 特殊用途     AX,AL I/O 指令的数据寄存器；乘法指令存放被乘数或积(隐含)，除法指令存放被除数或商(隐含)   AH LAHF指令的目标寄存器(隐含)   AL 数制转换或十进制运算指令和XLAT指令的累加器(隐含)   BX 间接寻址的基址寄存器 XLAT指令的基址寄存器(隐含)   CX 串操作和LOOP指令的计数器(隐含)   DX 字乘法/除法指令存放乘积高16位或被除数高位或余数(隐含) 间接寻址的 I/O 端口地址   SI 串操作的源变址寄存器(隐含)、间接寻址的变址寄存器   DI 串操作的目标变址寄存器(隐含)、间接寻址的变址寄存器   BP 对堆栈区间接寻址的基址指针   SP 堆栈操作的堆栈顶部指针    标志寄存器   6个状态标志位
  CF，进位标志。本次运算最高位有进位或借位发生，则CF=1。STC（CLC）指令使CF=1（=0），CMC指令使之取反。（用于无符号数）
  PF，奇偶校验标志：低 8 位有偶数个 1 则 PF = 1</description>
    </item>
    
    <item>
      <title>C&#43;&#43;(临时对象的分析)</title>
      <link>https://fffzlfk.gitlab.io/posts/c&#43;&#43;%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/posts/c&#43;&#43;%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E6%9E%90/</guid>
      <description>关闭编译器优化</description>
    </item>
    
    <item>
      <title>算法（第四版）</title>
      <link>https://fffzlfk.gitlab.io/posts/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%BD%9C%E4%B8%9A%E9%A2%98/</link>
      <pubDate>Fri, 09 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/posts/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%BD%9C%E4%B8%9A%E9%A2%98/</guid>
      <description>The solution of algs4&amp;rsquo;s exercise</description>
    </item>
    
    <item>
      <title>OOP(C&#43;&#43;)</title>
      <link>https://fffzlfk.gitlab.io/posts/oopc&#43;&#43;/</link>
      <pubDate>Tue, 06 Oct 2020 12:25:11 +0800</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/posts/oopc&#43;&#43;/</guid>
      <description>Object-Oriented Programming</description>
    </item>
    
    <item>
      <title>LeetCode杂题2</title>
      <link>https://fffzlfk.gitlab.io/posts/leetcode%E6%9D%82%E9%A2%982/</link>
      <pubDate>Sun, 04 Oct 2020 12:25:11 +0800</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/posts/leetcode%E6%9D%82%E9%A2%982/</guid>
      <description>杂题记录2</description>
    </item>
    
    <item>
      <title>字典树（trie tree）</title>
      <link>https://fffzlfk.gitlab.io/posts/%E5%AD%97%E5%85%B8%E6%A0%91trie-tree/</link>
      <pubDate>Sat, 03 Oct 2020 12:45:22 +0800</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/posts/%E5%AD%97%E5%85%B8%E6%A0%91trie-tree/</guid>
      <description>hihoCoder#1014</description>
    </item>
    
    <item>
      <title>算法进阶指南打卡</title>
      <link>https://fffzlfk.gitlab.io/posts/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%E6%89%93%E5%8D%A1/</link>
      <pubDate>Tue, 22 Sep 2020 12:45:22 +0800</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/posts/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%E6%89%93%E5%8D%A1/</guid>
      <description>蓝书</description>
    </item>
    
    <item>
      <title>CF#653(div3)</title>
      <link>https://fffzlfk.gitlab.io/2020/08/03/cf#653div3/</link>
      <pubDate>Mon, 03 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2020/08/03/cf#653div3/</guid>
      <description>AC代码 AC代码 AC代码 AC代码 AC代码 </description>
    </item>
    
    <item>
      <title>LeetCode杂题</title>
      <link>https://fffzlfk.gitlab.io/2020/07/27/leetcode/</link>
      <pubDate>Mon, 27 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2020/07/27/leetcode/</guid>
      <description>AC代码 &amp;lt;span class=&amp;quot;hljs-function&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;bool&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;hljs-title&amp;quot;&amp;gt;isPathCrossing&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;hljs-params&amp;quot;&amp;gt;(&amp;lt;span class=&amp;quot;hljs-built_in&amp;quot;&amp;gt;string&amp;lt;/span&amp;gt; path)&amp;lt;/span&amp;gt; &amp;lt;/span&amp;gt;{M[make_pair(&amp;lt;span class=&amp;quot;hljs-number&amp;quot;&amp;gt;0&amp;lt;/span&amp;gt;, &amp;lt;span class=&amp;quot;hljs-number&amp;quot;&amp;gt;0&amp;lt;/span&amp;gt;)] = &amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;true&amp;lt;/span&amp;gt;;&amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;int&amp;lt;/span&amp;gt; x = &amp;lt;span class=&amp;quot;hljs-number&amp;quot;&amp;gt;0&amp;lt;/span&amp;gt;, y = &amp;lt;span class=&amp;quot;hljs-number&amp;quot;&amp;gt;0&amp;lt;/span&amp;gt;;&amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;for&amp;lt;/span&amp;gt; (&amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;auto&amp;lt;/span&amp;gt; i : path) {&amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;if&amp;lt;/span&amp;gt; (i == &amp;lt;span class=&amp;quot;hljs-string&amp;quot;&amp;gt;&#39;N&#39;&amp;lt;/span&amp;gt;) {x--;} &amp;lt;span class=&amp;quot;hljs-function&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;else&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;hljs-title&amp;quot;&amp;gt;if&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;hljs-params&amp;quot;&amp;gt;(i == &#39;S&#39;)&amp;lt;/span&amp;gt; &amp;lt;/span&amp;gt;{x++;} &amp;lt;span class=&amp;quot;hljs-function&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;else&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;hljs-title&amp;quot;&amp;gt;if&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;hljs-params&amp;quot;&amp;gt;(i == &#39;W&#39;)&amp;lt;/span&amp;gt; &amp;lt;/span&amp;gt;{y--;} &amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;else&amp;lt;/span&amp;gt; y++;&amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;if&amp;lt;/span&amp;gt; (M[make_pair(x, y)]) &amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;true&amp;lt;/span&amp;gt;;M[make_pair(x, y)] = &amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;true&amp;lt;/span&amp;gt;;}&amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;false&amp;lt;/span&amp;gt;;} };AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 面试题-二分 求波动数组[1, 3, 5, 7, 9, 11, 13, 8, 1]中的最大值。</description>
    </item>
    
    <item>
      <title>不修改数组找出重复的数字</title>
      <link>https://fffzlfk.gitlab.io/2020/07/13/%D2%B3%D8%B8/</link>
      <pubDate>Mon, 13 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2020/07/13/%D2%B3%D8%B8/</guid>
      <description>问题描述 给定一个长度为$$ n+1 $$的数组nums，数组中所有的数均在$$ 1∼n $$的范围内，其中$$ n≥1 $$。
请找出数组中任意一个重复的数，但不能修改输入的数组。
样例 给定$ nums = [2, 3, 5, 4, 3, 2, 6, 7]$。
返回 2 或 3。 思考题：如果只能使用 $ O(1) $ 的额外空间，该怎么做呢？
分治，抽屉原理解法-$ O(nlogn) $  抽屉原理：n+1 个苹果放在 n 个抽屉里，那么至少有一个抽屉中会放两个苹果。
 用在这个题目中就是，一共有$ n+1 $个数，每个数的取值范围是1到n，所以至少会有一个数出现两次。
然后我们采用分治的思想，将每个数的取值的区间 $ [1, n] $划分成$ [1, n/2] $和$ [n/2+1, n] $两个子区间，然后分别统计两个区间中数的个数。 注意这里的区间是指 数的取值范围，而不是 数组下标。
划分之后，左右两个区间里一定至少存在一个区间，区间中数的个数大于区间长度。 这个可以用反证法来说明：如果两个区间中数的个数都小于等于区间长度，那么整个区间中数的个数就小于等于n，和有n+1个数矛盾。
因此我们可以把问题划归到左右两个子区间中的一个，而且由于区间中数的个数大于区间长度，根据抽屉原理，在这个子区间中一定存在某个数出现了两次。
依次类推，每次我们可以把区间长度缩小一半，直到区间长度为1时，我们就找到了答案。
复杂度分析 时间复杂度：每次会将区间长度缩小一半，一共会缩小 $ O(logn) $次。每次统计两个子区间中的数时需要遍历整个数组，时间复杂度是$ O(n) $。所以总时间复杂度是$ O(nlogn) $。 空间复杂度：代码中没有用到额外的数组，所以额外的空间复杂度是 $ O(1) $。</description>
    </item>
    
    <item>
      <title>单调队列</title>
      <link>https://fffzlfk.gitlab.io/2020/07/03//</link>
      <pubDate>Fri, 03 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2020/07/03//</guid>
      <description>&amp;lt;script&amp;gt;hljs.initHighlightingOnLoad();&amp;lt;/script&amp;gt; 题目描述 有一个长为$ n $的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。
例如：
The array is $[1,3,-1,-3,5,3,6,7]$, and $k = 3$。 输入格式 输入一共有两行，第一行有两个正整数 $n, k$。 第二行 $n $个整数，表示序列 $a$
输出格式 输出共两行，第一行为每次窗口滑动的最小值 第二行为每次窗口滑动的最大值
输入输出样例 输入8 31 3 -1 -3 5 3 6 7输出-1 -3 -3 -3 3 33 3 5 5 6 7说明/提示 【数据范围】 对于 $50% $的数据，$1 \le n \le 10^5$； 对于 $100%$的数据，$1\le k \le n \le 10^6 ，a_i \in [-2^{31},2^{31})$。</description>
    </item>
    
    <item>
      <title>LeetCode第29场双周赛</title>
      <link>https://fffzlfk.gitlab.io/2020/06/28/leetcode29/</link>
      <pubDate>Sun, 28 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2020/06/28/leetcode29/</guid>
      <description>题目描述 给你一个整数数组 salary ，数组里每个数都是 唯一 的，其中 salary[i] 是第 i 个员工的工资。 请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。
AC代码 class Solution { public: double average(vector&amp;lt;int&amp;gt;&amp;amp; salary) { int Max = *max_element(salary.begin(), salary.end()); int Min = *min_element(salary.begin(), salary.end()); int s = 0, cnt = 0; for (auto i : salary) if (i != Max &amp;amp;&amp;amp; i != Min) s += i, cnt++; return (double)s/(cnt); } }; 题目描述 给你两个正整数 n 和 k 。
如果正整数 i 满足 n % i == 0 ，那么我们就说正整数 i 是整数 n 的因子。</description>
    </item>
    
    <item>
      <title>背包九讲</title>
      <link>https://fffzlfk.gitlab.io/2020/06/25/%C5%BE/</link>
      <pubDate>Thu, 25 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2020/06/25/%C5%BE/</guid>
      <description>#01 01背包问题 AC代码 AC代码 #02 完全背包问题 AC代码 AC代码 #03 多重背包问题 AC代码 AC代码 AC代码 #04 混合背包问题 AC代码 AC代码 AC代码 #06 分组背包问题 AC代码 #07 有依赖的背包问题 AC代码 AC代码 #08 背包问题求方案数 AC代码 #09 背包问题求具体方案 AC代码   </description>
    </item>
    
    <item>
      <title>KMP &amp; Manacher</title>
      <link>https://fffzlfk.gitlab.io/2020/06/24/kmpandmanacher/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2020/06/24/kmpandmanacher/</guid>
      <description>P3375 【模板】KMP字符串匹配 AC代码 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; const int maxn = 1e6 + 5; char s1[maxn]; char s2[maxn]; int _next[maxn]; void get_next(int len) { int j = 0; for (int i = 2; i &amp;lt;= len; i++) { while (j &amp;amp;&amp;amp; s2[j + 1] != s2[i]) j = _next[j]; if (s2[j + 1] == s2[i]) j++; _next[i] = j; } } void find(int len1, int len2) { int j = 0; for (int i = 1; i &amp;lt;= len1; i++) { while (j &amp;amp;&amp;amp; s2[j + 1] !</description>
    </item>
    
    <item>
      <title>二分</title>
      <link>https://fffzlfk.gitlab.io/2020/06/23//</link>
      <pubDate>Tue, 23 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2020/06/23//</guid>
      <description>P1024 一元三次方程求解【浮点数二分模版】 AC代码 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; double A, B, C, D; double check(double x) { return A * pow(x, 3) + B * pow(x, 2) + C * x + D; } void bs() { double l, r, mid; int cnt = 0; for (double i = -100.0; i &amp;lt;= 100.0; i++) { l = i, r = i + 1; double chl = check(l); double chr = check(r); if (chl == 0) { printf(&amp;#34;%.</description>
    </item>
    
    <item>
      <title>归并排序、树状数组、线段树、RMQ、LRU(倍增)</title>
      <link>https://fffzlfk.gitlab.io/2020/06/22/%E9%B2%A2/</link>
      <pubDate>Mon, 22 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2020/06/22/%E9%B2%A2/</guid>
      <description>P1908 逆序对 AC代码(归并排序) AC代码(树状数组) P3374 【模板】树状数组 1 AC代码 P3368 【模板】树状数组 2 AC代码 P3372 【模板】线段树 1 AC代码 P3865 【模板】ST表 AC代码 POJ3264 Balanced Lineup【RMQ模板】 AC代码 P1816 忠诚【RMQ】 AC代码 P3379 【模板】最近公共祖先（LCA） AC代码   </description>
    </item>
    
    <item>
      <title>图论练习</title>
      <link>https://fffzlfk.gitlab.io/2020/06/21/%CD%BC%CF%B0/</link>
      <pubDate>Sun, 21 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2020/06/21/%CD%BC%CF%B0/</guid>
      <description>UVA10129 单词 Play on Words（欧拉路径） AC代码 P3367 【模板】并查集 AC代码 P1551 亲戚-【模板】并查集 AC代码 P1111 修复公路 AC代码 P1195 口袋的天空 AC代码 P1196 [NOI2002]银河英雄传说-【模板】带权并查集 AC代码 P1536 村村通 AC代码 P3916 图的遍历 AC代码 P4779 【模板】单源最短路径（标准版） AC代码 POJ2186 Popular Cows AC代码 P3366 【模板】最小生成树 AC代码 POJ2421 Constructing Roads AC代码   </description>
    </item>
    
    <item>
      <title>搜索练习</title>
      <link>https://fffzlfk.gitlab.io/2020/06/17/%CF%B0/</link>
      <pubDate>Wed, 17 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2020/06/17/%CF%B0/</guid>
      <description>以下题目来自洛谷 P1379 八数码难题 AC代码 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; const int maxn = 4e5; typedef int state[9]; state st[maxn], goal; int dist[maxn]; const int dx[] = {0, 0, -1, 1}; const int dy[] = {-1, 1, 0, 0}; set&amp;amp;lt;int&amp;amp;gt; vis; bool try_insert(int s) { int res = 0; for (int i = 0; i &amp;lt; 9; i++) res = res * 10 + st[s][i]; if (vis.count(res)) return false; vis.insert(res); return true; } int bfs() { vis.</description>
    </item>
    
    <item>
      <title>数论练习</title>
      <link>https://fffzlfk.gitlab.io/2020/06/17/%CF%B0/</link>
      <pubDate>Wed, 17 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2020/06/17/%CF%B0/</guid>
      <description>以下题目来自洛谷 P3390 【模板】矩阵快速幂 AC代码 P3383 【模板】线性筛素数    10 100 1000 10000 100000 1000000 10000000 100000000     4 29 197 1426 11018 89516 754095 6515550    AC代码 CF822A I&amp;rsquo;m bored with life AC代码 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; // using ll = long long; // 不打表也能过 int get_mul[] = {1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600}; int main() { int a, b; scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;a, &amp;amp;b); printf(&amp;#34;%d\n&amp;#34;, get_mul[min(a, b) - 1]); // for (int i = 1; i &amp;lt; 13; i++) printf(&amp;#34;%d, &amp;#34;, get(i));  // system(&amp;#34;pause&amp;#34;);  return 0; } 素数个数（线性筛模版） AC代码 #include &amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>CF#640(div4)</title>
      <link>https://fffzlfk.gitlab.io/2020/06/15/cf#640div4/</link>
      <pubDate>Mon, 15 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2020/06/15/cf#640div4/</guid>
      <description>Problem A For example, the following numbers are round: $$ 4000, 1, 9, 800, 90. $$ The following numbers are not round: $$ 110, 707, 222, 1001. $$
You are given a positive integer n ($$1≤n≤10^4$$). Represent the number n as a sum of round numbers using the minimum number of summands (addends). In other words, you need to represent the given number n as a sum of the least number of terms, each of which is a round number.</description>
    </item>
    
    <item>
      <title>一个Vue实现的简易计算器</title>
      <link>https://fffzlfk.gitlab.io/2020/06/11/%D2%BBvue%CA%B5%D6%B5%C4%BC/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2020/06/11/%D2%BBvue%CA%B5%D6%B5%C4%BC/</guid>
      <description>点击此链接体验此计算器HTML部分 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;calculator&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;result&amp;#34; style=&amp;#34;grid-area: result&amp;#34;&amp;gt; {{ equation }} &amp;lt;/div&amp;gt; &amp;lt;button style=&amp;#34;grid-area: ac&amp;#34; @click=&amp;#34;clear&amp;#34;&amp;gt;AC&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: plus-minus&amp;#34; @click=&amp;#34;calculateToggle&amp;#34;&amp;gt;±&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: percent&amp;#34; @click=&amp;#34;calculatePercentage&amp;#34;&amp;gt;%&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: add&amp;#34; @click=&amp;#34;append(&amp;#39;+&amp;#39;)&amp;#34;&amp;gt;+&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: subtract&amp;#34; @click=&amp;#34;append(&amp;#39;-&amp;#39;)&amp;#34;&amp;gt; - &amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: multiply&amp;#34; @click=&amp;#34;append(&amp;#39;×&amp;#39;)&amp;#34;&amp;gt;×&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: divide&amp;#34; @click=&amp;#34;append(&amp;#39;÷&amp;#39;)&amp;#34;&amp;gt;÷&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: equal&amp;#34; @click=&amp;#34;calculate&amp;#34;&amp;gt;=&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: number-1&amp;#34; @click=&amp;#34;append(&amp;#39;1&amp;#39;)&amp;#34;&amp;gt;1&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: number-2&amp;#34; @click=&amp;#34;append(&amp;#39;2&amp;#39;)&amp;#34;&amp;gt;2&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: number-3&amp;#34; @click=&amp;#34;append(&amp;#39;3&amp;#39;)&amp;#34;&amp;gt;3&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: number-4&amp;#34; @click=&amp;#34;append(&amp;#39;4&amp;#39;)&amp;#34;&amp;gt;4&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: number-5&amp;#34; @click=&amp;#34;append(&amp;#39;5&amp;#39;)&amp;#34;&amp;gt;5&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: number-6&amp;#34; @click=&amp;#34;append(&amp;#39;6&amp;#39;)&amp;#34;&amp;gt;6&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: number-7&amp;#34; @click=&amp;#34;append(&amp;#39;7&amp;#39;)&amp;#34;&amp;gt;7&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: number-8&amp;#34; @click=&amp;#34;append(&amp;#39;8&amp;#39;)&amp;#34;&amp;gt;8&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: number-9&amp;#34; @click=&amp;#34;append(&amp;#39;9&amp;#39;)&amp;#34;&amp;gt;9&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: number-0&amp;#34; @click=&amp;#34;append(&amp;#39;0&amp;#39;)&amp;#34;&amp;gt;0&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: dot&amp;#34; @click=&amp;#34;append(&amp;#39;.</description>
    </item>
    
    <item>
      <title>Windows消息队列</title>
      <link>https://fffzlfk.gitlab.io/2020/05/31/windows%CF%A3/</link>
      <pubDate>Sun, 31 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2020/05/31/windows%CF%A3/</guid>
      <description>问题描述 消息队列是Windows系统的基础。对于每个进程，系统维护一个消息队列。如果在进程中有特定事件发生，如点击鼠标、文字改变等，系统将把这个消息加到队列当中。同时，如果队列不是空的，这一进程循环地从队列中按照优先级获取消息。请注意优先级值低意味着优先级高。请编辑程序模拟消息队列，将消息加到队列中以及从队列中获取消息。
题目链接
解决思路 此次可以使用优先队列来解，priority_queue是一种先入优先级高者出的队列。
输入格式: 输入首先给出正整数N（≤10^5​​），随后N行，每行给出一个指令——GET或PUT，分别表示从队列中取出消息或将消息添加到队列中。如果指令是PUT，后面就有一个消息名称、以及一个正整数表示消息的优先级，此数越小表示优先级越高。消息名称是长度不超过10个字符且不含空格的字符串；题目保证队列中消息的优先级无重复，且输入至少有一个GET。
输出格式: 对于每个GET指令，在一行中输出消息队列中优先级最高的消息的名称和参数。如果消息队列中没有消息，输出EMPTY QUEUE!。对于PUT指令则没有输出。
输入样例: 9PUT msg1 5PUT msg2 4GETPUT msg3 2PUT msg4 4GETGETGETGET输出样例: msg2msg3msg4msg1EMPTY QUEUE!AC代码 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; struct node { char s[12]; int p; friend bool operator&amp;lt;(const node &amp;amp;a, const node &amp;amp;b) { return a.p &amp;gt; b.p; } node(char *a, int b) { strcpy(s, a); p = b; } }; priority_queue&amp;lt;node&amp;gt; Q; int main() { int T; scanf(&amp;#34;%d&amp;#34;, &amp;amp;T); char tmp[4], t[12]; int p; while (T--) { scanf(&amp;#34;%s&amp;#34;, tmp); if (tmp[0] == &amp;#39;P&amp;#39;) { scanf(&amp;#34;%s %d&amp;#34;, t, &amp;amp;p); Q.</description>
    </item>
    
    <item>
      <title>机器学习02-决策树</title>
      <link>https://fffzlfk.gitlab.io/2020/03/30/%D1%A7%CF%B002-/</link>
      <pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2020/03/30/%D1%A7%CF%B002-/</guid>
      <description>一个简单的例子 from sklearn import tree features = [[140, 1], [130, 1], [150, 0], [170, 0]] labels = [0, 0, 1, 1] clf = tree.DecisionTreeClassifier() clf = clf.fit(features, labels) print(clf.predict([[150, 1]])) 经典例子iris 代码 import numpy as np from sklearn.datasets import load_iris from sklearn import tree iris = load_iris() # print(iris.feature_names) # print(iris.target_names) # print(iris.data[0]) # print(iris.target[0]) test_idx = [0, 50, 100] train_target = np.delete(iris.target, test_idx) train_data = np.delete(iris.data, test_idx, axis=0) test_target = iris.</description>
    </item>
    
    <item>
      <title>机器学习03-KNN</title>
      <link>https://fffzlfk.gitlab.io/2020/04/01/%D1%A7%CF%B003-knn/</link>
      <pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2020/04/01/%D1%A7%CF%B003-knn/</guid>
      <description>from scipy.spatial import distance def euc(a, b): return distance.euclidean(a, b) class ScrappyKNN(): def fit(self, X_train, y_train): self.X_train = X_train self.y_train = y_train def predict(self, X_test): predictions = [] for row in X_test: label = self.closest(row) predictions.append(label) return predictions def closest(self, row): best_dist = euc(row, self.X_train[0]) best_index = 0 for i in range(1, len(self.X_train)): dist = euc(row, self.X_train[i]) if dist &amp;lt; best_dist: best_dist = dist best_index = i return self.y_train[best_index] from sklearn import datasets iris = datasets.</description>
    </item>
    
    <item>
      <title>机器学习01</title>
      <link>https://fffzlfk.gitlab.io/2020/03/21/%D1%A7%CF%B001/</link>
      <pubDate>Sat, 21 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2020/03/21/%D1%A7%CF%B001/</guid>
      <description>卷积神经网络入门 import tensorflow as tf import numpy as np from tensorflow import keras # 创建一层的神经网络 model = tf.keras.Sequential([keras.layers.Dense(units=1, input_shape=[1])]) # 指定loss和optimizer函数 &amp;#39;sgd&amp;#39;(梯度随机下降) (均方误差) model.compile(optimizer=&amp;#39;sgd&amp;#39;, loss=&amp;#39;mean_squared_error&amp;#39;) # 生成测试数据 X = [] for i in range(-1, 5): X.append(i * 1.0) Y = [3 * i + 1 for i in X] xs = np.array(X, dtype=float) ys = np.array(Y, dtype=float) model.fit(xs, ys, epochs=2500) # 使用模型 print(model.predict([0.0])) 手写数字识别代码 from tensorflow.examples.tutorials.mnist import input_data minist = input_data.</description>
    </item>
    
    <item>
      <title>两个有序序列的中位数</title>
      <link>https://fffzlfk.gitlab.io/2019/12/31/%D0%B5%CE%BB/</link>
      <pubDate>Tue, 31 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/12/31/%D0%B5%CE%BB/</guid>
      <description>问题描述 已知有两个等长的非降序序列S1, S2, 设计函数求S1与S2并集的中位数。有序序列A ​0 ​​ ,A ​1 ​​ ,⋯,A ​N−1 ​​ 的中位数指A ​(N−1)/2 ​​ 的值,即第⌊(N+1)/2⌋个数（A ​0 ​​ 为第1个数）。
输入格式: 输入分三行。第一行给出序列的公共长度N（0&amp;lt;N≤100000），随后每行输入一个序列的信息，即N个非降序排列的整数。数字用空格间隔。
输出格式: 在一行中输出两个输入序列的并集序列的中位数。
输入样例1: 51 3 5 7 92 3 4 5 6输出样例1: 4输入样例2: 6-100 -10 1 1 1 1-50 0 2 3 4 5输出样例2: 1代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; q; int main() { int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); int t; for (int i = 1; i &amp;lt;= 2 * n; i++) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); q.</description>
    </item>
    
    <item>
      <title>汉诺塔问题</title>
      <link>https://fffzlfk.gitlab.io/2019/12/20/%C5%B5/</link>
      <pubDate>Fri, 20 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/12/20/%C5%B5/</guid>
      <description>问题描述 借助堆栈以非递归（循环）方式求解汉诺塔的问题（n, a, b, c），即将N个盘子从起始柱（标记为“a”）通过借助柱（标记为“b”）移动到目标柱（标记为“c”），并保证每个移动符合汉诺塔问题的要求。
输入格式: 输入为一个正整数N，即起始柱上的盘数。
输出格式: 每个操作（移动）占一行，按柱1 -&amp;gt; 柱2的格式输出。
输入样例: 3输出样例: a -&amp;gt; ca -&amp;gt; bc -&amp;gt; ba -&amp;gt; cb -&amp;gt; ab -&amp;gt; ca -&amp;gt; c代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; void move(char a, char b) { printf(&amp;#34;%c -&amp;gt; %c\n&amp;#34;, a, b); } void hanoi(int n, char a, char b, char c) { if (n == 1) move(a, c); else { hanoi(n - 1, a, c, b); move(a, c); hanoi(n - 1, b, a, c); } } int main() { int n; cin &amp;gt;&amp;gt; n; hanoi(n, &amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;); return 0; } </description>
    </item>
    
    <item>
      <title>关键活动</title>
      <link>https://fffzlfk.gitlab.io/2019/12/19/%D8%BC/</link>
      <pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/12/19/%D8%BC/</guid>
      <description>问题描述 假定一个工程项目由一组子任务构成，子任务之间有的可以并行执行，有的必须在完成了其它一些子任务后才能执行。“任务调度”包括一组子任务、以及每个子任务可以执行所依赖的子任务集。
比如完成一个专业的所有课程学习和毕业设计可以看成一个本科生要完成的一项工程，各门课程可以看成是子任务。有些课程可以同时开设，比如英语和C程序设计，它们没有必须先修哪门的约束；有些课程则不可以同时开设，因为它们有先后的依赖关系，比如C程序设计和数据结构两门课，必须先学习前者。
但是需要注意的是，对一组子任务，并不是任意的任务调度都是一个可行的方案。比如方案中存在“子任务A依赖于子任务B，子任务B依赖于子任务C，子任务C又依赖于子任务A”，那么这三个任务哪个都不能先执行，这就是一个不可行的方案。
任务调度问题中，如果还给出了完成每个子任务需要的时间，则我们可以算出完成整个工程需要的最短时间。在这些子任务中，有些任务即使推迟几天完成，也不会影响全局的工期；但是有些任务必须准时完成，否则整个项目的工期就要因此延误，这种任务就叫“关键活动”。
请编写程序判定一个给定的工程项目的任务调度是否可行；如果该调度方案可行，则计算完成整个工程项目需要的最短时间，并输出所有的关键活动。
输入格式: 输入第1行给出两个正整数N(≤100)和M，其中N是任务交接点（即衔接相互依赖的两个子任务的节点，例如：若任务2要在任务1完成后才开始，则两任务之间必有一个交接点）的数量。交接点按1~N编号，M是子任务的数量，依次编号为1~M。随后M行，每行给出了3个正整数，分别是该任务开始和完成涉及的交接点编号以及该任务所需的时间，整数间用空格分隔。
输出格式: 如果任务调度不可行，则输出0；否则第1行输出完成整个工程项目需要的时间，第2行开始输出所有关键活动，每个关键活动占一行，按格式“V-&amp;gt;W”输出，其中V和W为该任务开始和完成涉及的交接点编号。关键活动输出的顺序规则是：任务开始的交接点编号小者优先，起点编号相同时，与输入时任务的顺序相反。
输入样例: 7 81 2 41 3 32 4 53 4 34 5 14 6 65 7 56 7 2输出样例: 171-&amp;gt;22-&amp;gt;44-&amp;gt;66-&amp;gt;7代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int n, m; struct Node { int id; int len; }; vector&amp;lt;Node&amp;gt; G[105]; int ve[105]; int vl[105]; int in[105]; stack&amp;lt;int&amp;gt; S; void read() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); int a, b, c; while (m--) { scanf(&amp;#34;%d%d%d&amp;#34;, &amp;amp;a, &amp;amp;b, &amp;amp;c); Node t; t.</description>
    </item>
    
    <item>
      <title>求前缀表达式的值</title>
      <link>https://fffzlfk.gitlab.io/2019/12/19/%C7%B0%CA%BD%D6%B5/</link>
      <pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/12/19/%C7%B0%CA%BD%D6%B5/</guid>
      <description>问题描述 算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。前缀表达式指二元运算符位于两个运算数之前，例如2+3*(7-4)+8/4的前缀表达式是：+ + 2 * 3 - 7 4 / 8 4。请设计程序计算前缀表达式的结果值。
输入格式: 输入在一行内给出不超过30个字符的前缀表达式，只包含+、-、*、/以及运算数，不同对象（运算数、运算符号）之间以空格分隔。
输出格式: 输出前缀表达式的运算结果，保留小数点后1位，或错误信息ERROR。
输入样例: + + 2 * 3 - 7 4 / 8 4输出样例: 13.0代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; float calculate(float x, float y, char t) { switch (t) { case &amp;#39;+&amp;#39;: return x + y; break; case &amp;#39;-&amp;#39;: return x - y; break; case &amp;#39;*&amp;#39;: return x * y; break; case &amp;#39;/&amp;#39;: if (y == 0.</description>
    </item>
    
    <item>
      <title>部分置信区间总结</title>
      <link>https://fffzlfk.gitlab.io/2019/12/09//</link>
      <pubDate>Mon, 09 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/12/09//</guid>
      <description>单正态分布均值μ
  σ2已知 $$ (\bar X-\frac{\sigma}{\sqrt{n}}z_{\frac \alpha 2},\bar X+\frac{\sigma}{\sqrt{n}}z_{\frac \alpha 2}) $$
  σ2未知，样本方差S2$$ (\bar X-\frac{S}{\sqrt n}t_\frac \alpha 2 (n-1),\bar X+\frac{S}{\sqrt n}t_\frac \alpha 2 (n-1)) $$
    单正态分布方差σ2  μ已知 $$ (\frac{\sum_{i=1}^n(X_i-\mu)^2}{\chi_{\frac \alpha 2}^2(n)},\frac{\sum_{i=1}^n(X_i-\mu)^2}{\chi_{1-\frac \alpha 2}^2(n)}) $$
  μ未知，样本方差S2已知 $$ (\frac {(n-1)S^2}{\chi _{\frac \alpha 2}^2(n-1)},\frac {(n-1)S^2}{\chi _{1-\frac \alpha 2}^2(n-1)}) $$
    双正态分布μ1-μ2  σ12, σ22已知 $$ (\bar X-\bar Y\pm\sqrt{\frac {\sigma_1^2} {n_1} +\frac {\sigma_2^2} {n_2} }z_{\frac \alpha 2}) $$</description>
    </item>
    
    <item>
      <title>哥尼斯堡七桥问题</title>
      <link>https://fffzlfk.gitlab.io/2019/12/08/%C4%A1/</link>
      <pubDate>Sun, 08 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/12/08/%C4%A1/</guid>
      <description>问题描述 哥尼斯堡是位于普累格河上的一座城市，它包含两个岛屿及连接它们的七座桥，如下图所示。
可否走过这样的七座桥，而且每桥只走过一次？瑞士数学家欧拉(Leonhard Euler，1707—1783)最终解决了这个问题，并由此创立了拓扑学。
这个问题如今可以描述为判断欧拉回路是否存在的问题。欧拉回路是指不令笔离开纸面，可画过图中每条边仅一次，且可以回到起点的一条回路。现给定一个无向图，问是否存在欧拉回路？
输入格式: 输入第一行给出两个正整数，分别是节点数N (1≤N≤1000)和边数M；随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个节点的编号（节点从1到N编号）。
输出格式: 若欧拉回路存在则输出1，否则输出0。
样例 输入样例1: 6 101 22 33 14 55 66 41 41 63 43 6输出样例1: 1输入样例2: 5 81 21 32 32 42 55 35 43 4输出样例2: 0代码实现 使用并查集判断连通性 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int n, m; struct { int pre; int dgr = 0; } Node[1005]; int find(int i) { return Node[i].</description>
    </item>
    
    <item>
      <title>堆中的路径</title>
      <link>https://fffzlfk.gitlab.io/2019/12/05/%D0%B5/</link>
      <pubDate>Thu, 05 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/12/05/%D0%B5/</guid>
      <description>问题描述 将一系列给定数字插入一个初始为空的小顶堆H[]。随后对任意给定的下标i，打印从H[i]到根结点的路径。
输入格式: 每组测试第1行包含2个正整数N和M(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的N个要被插入一个初始为空的小顶堆的整数。最后一行给出M个下标。
输出格式: 对输入中给出的每个下标i，在一行中输出从H[i]到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。
输入样例: 5 346 23 26 24 105 4 3输出样例: 24 23 1046 23 1026 10代码实现 #include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std; int n; int m; int h[1005]; int s = 0; void add(int k) { s++; int i; for (i = s; h[i / 2] &amp;gt; k; i /= 2) h[i] = h[i / 2]; h[i] = k; } int main() { cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; int t; int N = n; h[0] = -10001; //注意h[0]要很小，否则会进入死循环  while (N--) { cin &amp;gt;&amp;gt; t; add(t); } while (m--) { cin &amp;gt;&amp;gt; t; while (t !</description>
    </item>
    
    <item>
      <title>希尔排序&amp;快排&amp;堆排序</title>
      <link>https://fffzlfk.gitlab.io/2019/12/04//</link>
      <pubDate>Wed, 04 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/12/04//</guid>
      <description>希尔排序 算法描述 代码实现 #include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std; void ShellInsert(vector&amp;lt;int&amp;gt; &amp;amp;L, int dk) { for (int i = dk; i &amp;lt; L.size(); i++) { int j; int tmp; if (L[i] &amp;lt; L[i - dk]) { tmp = L[i]; // 暂存  for (j = i - dk; j &amp;gt; 0 &amp;amp;&amp;amp; L[j] &amp;gt; tmp; j -= dk) L[j + dk] = L[j]; //向后移动到插入位置  L[j + dk] = tmp; //插入  } } } void ShellSort(vector&amp;lt;int&amp;gt; &amp;amp;L, int dlta[], int t) { for (int k = 0; k &amp;lt; t; k++) ShellInsert(L, dlta[k]); } int main(int argc, char const *argv[]) { vector&amp;lt;int&amp;gt; L = {0, 3, 1, 4, 7, 4, 2, 9}; int dlta[] = {3, 2, 1}; ShellSort(L, dlta, 3); vector&amp;lt;int&amp;gt;::iterator it = L.</description>
    </item>
    
    <item>
      <title>让课代表收作业变得更简单</title>
      <link>https://fffzlfk.gitlab.io/2019/12/02/%CA%BC/</link>
      <pubDate>Mon, 02 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/12/02/%CA%BC/</guid>
      <description>前期准备  一个邮箱地址和密码 Python3环境  教程  在邮箱设置里开启pop 安装xlwt和xlrd  pip3 install xlwt pip3 install xlrd 将下面代码中的邮件地址, 口令和POP3服务器地址改为你所对应的；并指定att_file(存储路径)。  #!/usr/bin/env python3 # -*- coding: utf-8 -*- import poplib import email import datetime import time import os import xlrd import xlwt from email.parser import Parser from email.header import decode_header from email.utils import parseaddr # 输入邮件地址, 口令和POP3服务器地址: email = &amp;#39;***@163.com&amp;#39; password = &amp;#39;********&amp;#39; pop3_server = &amp;#39;pop.163.com&amp;#39; def decode_str(s): #字符编码转换 value, charset = decode_header(s)[0] if charset: value = value.</description>
    </item>
    
    <item>
      <title>二叉排序树的合并</title>
      <link>https://fffzlfk.gitlab.io/2019/12/01/%CF%B2/</link>
      <pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/12/01/%CF%B2/</guid>
      <description>问题描述 试编写程序，将两棵二叉排序树合并为一棵二叉排序树。
输入格式 按照先序序列，分两行输入两棵二叉排序树各结点（结点值大于0），其中-1表示取消建立子树结点。
输出格式 按照中序序列输出合并后的二叉排序树。
输入样例 12 8 4 -1 -1 10 -1 -1 16 13 -1 -1 18 -1 -117 6 2 -1 -1 9 -1 -1 24 19 -1 -1 26 -1 -1输出样例 2 4 6 8 9 10 12 13 16 17 18 19 24 26代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; struct TreeNode { int data; TreeNode *left; TreeNode *right; TreeNode(int n) : data(n) {} }; void createBTree(TreeNode *&amp;amp;root) { int t; scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); if (t !</description>
    </item>
    
    <item>
      <title>哈希表设计</title>
      <link>https://fffzlfk.gitlab.io/2019/12/01/%CF%A3/</link>
      <pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/12/01/%CF%A3/</guid>
      <description>问题描述 针对某个集体（比如你所在的班级）中的“人名”设计一个哈希表，使得平均查找长度不超过R，完成相应的建表和查表程序。
基本要求 假设人名为中国人姓名的汉语拼音形式。待填入哈希表的人名共有30个，取平均查找长度的上限为2。哈希函数用除留余数法构造，用伪随机探测再散列发处理冲突。
代码实现 #include &amp;lt;iostream&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;using namespace std; #define M 50 struct name { char str[20]; int value; } Name[30]; struct hash { char name[20]; int key; int sum; int flag; } HashList[M]; void init() { FILE *fp; fp = fopen(&amp;#34;text.txt&amp;#34;, &amp;#34;r&amp;#34;); for (int i = 0; i &amp;lt; 30; i++) { fgets(Name[i].str, 20, fp); int j = 0; for (; Name[i].str[j] != &amp;#39;\n&amp;#39;; j++) ; Name[i].</description>
    </item>
    
    <item>
      <title>六度空间</title>
      <link>https://fffzlfk.gitlab.io/2019/11/29/%C8%BF%D5%BC/</link>
      <pubDate>Fri, 29 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/29/%C8%BF%D5%BC/</guid>
      <description>问题描述 “六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。
“六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。
假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。
输入格式: 输入第1行给出两个正整数，分别表示社交网络图的结点数N（1&amp;lt;N≤1000​ ，表示人数）、边数M≤33×N，表示社交关系数）。随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到N编号）。
输出格式: 对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。
输入样例: 10 91 22 33 44 55 66 77 88 99 10输出样例: 1: 70.00%2: 80.00%3: 90.00%4: 100.00%5: 100.00%6: 100.00%7: 100.00%8: 90.00%9: 80.00%10: 70.00%代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int n, m; int arcs[1005][1005]; int d[1005][1005]; void read() { cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; int a, b; for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= n; j++) arcs[i][j] = 2005; } while (m--) { cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; arcs[a][b] = 1; arcs[b][a] = 1; } } void solve() { for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= n; j++) { d[i][j] = arcs[i][j]; } } for (int i = 1; i &amp;lt;= n; i++) d[i][i] = 0; for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= n; j++) { for (int k = 1; k &amp;lt;= n; k++) { d[j][k] = min(d[j][i] + d[i][k], d[j][k]); } } } } void print() { for (int i = 1; i &amp;lt;= n; i++) { double count = 0; for (int j = 1; j &amp;lt;= n; j++) { if (d[i][j] &amp;lt;= 6) count++; } printf(&amp;#34;%d: %.</description>
    </item>
    
    <item>
      <title>一元多项式的乘法和加法运算</title>
      <link>https://fffzlfk.gitlab.io/2019/11/28/%D2%BB%D4%AB%CA%BD%C4%B3%CD%BC%D3%B7/</link>
      <pubDate>Thu, 28 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/28/%D2%BB%D4%AB%CA%BD%C4%B3%CD%BC%D3%B7/</guid>
      <description>问题描述 设计函数分别求两个一元多项式的乘积与和。
输入格式: 输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。
输出格式: 输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出0 0。
输入样例: 4 3 4 -5 2 6 1 -2 03 5 20 -7 4 3 1输出样例: 15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 15 20 -4 4 -5 2 9 1 -2 0代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int m, n; int A[1005]; int B[1005]; int C[2005]; void read() { int t1, t2; cin &amp;gt;&amp;gt; m; while (m--) { cin &amp;gt;&amp;gt; t1 &amp;gt;&amp;gt; t2; A[t2] += t1; } cin &amp;gt;&amp;gt; n; while (n--) { cin &amp;gt;&amp;gt; t1 &amp;gt;&amp;gt; t2; B[t2] += t1; } } void mul() { bool zero = 1; int flag = 1; for (int i = 1004; i &amp;gt;= 0; i--) { for (int j = 1004; j &amp;gt;= 0; j--) { C[i + j] += A[i] * B[j]; } } for (int i = 2004; i &amp;gt;= 0; i--) { if (C[i]) { zero = 0; printf(flag ?</description>
    </item>
    
    <item>
      <title>列出可连通集</title>
      <link>https://fffzlfk.gitlab.io/2019/11/28/%D0%B3%CD%A8/</link>
      <pubDate>Thu, 28 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/28/%D0%B3%CD%A8/</guid>
      <description>问题描述 给定一个有N个顶点和E条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到N−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。
输入格式: 输入第1行给出2个整数N(0&amp;lt;N≤10)和E，分别是图的顶点数和边数。随后E行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。
输出格式: 按照如下的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。
输入样例: 8 60 70 12 04 12 43 5输出样例: { 0 1 4 2 7 }{ 3 5 }{ 6 }代码实现 DFS #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int N, E; bool visit[11]; bool arcs[11][11]; void read() { cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; E; int a, b; while (E--) { cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; arcs[a][b] = 1; arcs[b][a] = 1; } } void dfs(int v) { printf(&amp;#34; %d&amp;#34;, v); visit[v] = 1; for (int i = 0; i &amp;lt; N; i++) { if (!</description>
    </item>
    
    <item>
      <title>最大子列和问题</title>
      <link>https://fffzlfk.gitlab.io/2019/11/28/%D0%BA/</link>
      <pubDate>Thu, 28 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/28/%D0%BA/</guid>
      <description>问题描述 给定K个整数组成的序列,其中“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。
本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：
数据1：与样例等价，测试基本正确性；数据2：102个随机整数；数据3：103个随机整数；数据4：104个随机整数；数据5：105个随机整数；输入格式: 输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。
输出格式: 在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。
输入样例: 6-2 11 -4 13 -5 -2输出样例: 20解决思路 最大连续子列只可能是以0～n-1位置结尾，若前面位置的最大连续子列和max(i-1) &amp;gt; 0, 则以i位置结尾的最大连续子列和max(i)为max(i-1) + nums[i], 否则为nums[i]。
代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int n; int a[100005]; long long getMax() { long long max = a[0]; long long cur = a[0]; for (int i = 1; i &amp;lt; n; i++) { cur = (cur &amp;gt; 0 ?</description>
    </item>
    
    <item>
      <title>二叉树的遍历</title>
      <link>https://fffzlfk.gitlab.io/2019/11/26/%C4%B1/</link>
      <pubDate>Tue, 26 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/26/%C4%B1/</guid>
      <description>问题描述 二叉树的遍历 本题要求给定二叉树的4种遍历。
函数接口定义：
void InorderTraversal( BinTree BT ); void PreorderTraversal( BinTree BT ); void PostorderTraversal( BinTree BT ); void LevelorderTraversal( BinTree BT ); 其中BinTree结构定义如下：
typedef struct TNode *Position; typedef Position BinTree; struct TNode{ ElementType Data; BinTree Left; BinTree Right; }; 要求4个函数分别按照访问顺序打印出结点的内容，格式为一个空格跟着一个字符。
输出样例 （对于图中给出的树）：
Inorder: D B E F A G H C IPreorder: A B D F E C G H IPostorder: D E F B H G I C ALevelorder: A B C D F G I E H代码实现 void InorderTraversal(BinTree BT) { if (BT) { InorderTraversal(BT-&amp;gt;Left); printf(&amp;#34; %c&amp;#34;, BT-&amp;gt;Data); InorderTraversal(BT-&amp;gt;Right); } else { return; } } void PreorderTraversal(BinTree BT) { if (BT) { printf(&amp;#34; %c&amp;#34;, BT-&amp;gt;Data); PreorderTraversal(BT-&amp;gt;Left); PreorderTraversal(BT-&amp;gt;Right); } else { return; } } void PostorderTraversal(BinTree BT) { if (BT) { PostorderTraversal(BT-&amp;gt;Left); PostorderTraversal(BT-&amp;gt;Right); printf(&amp;#34; %c&amp;#34;, BT-&amp;gt;Data); } else { return; } } void LevelorderTraversal(BinTree BT) { BinTree Q[100]; int front = 0; int rear = 0; if (BT) { Q[++rear] = BT; } while (front !</description>
    </item>
    
    <item>
      <title>二叉树前序、中序、后序遍历的相互求法</title>
      <link>https://fffzlfk.gitlab.io/2019/11/24/%D7%AA/</link>
      <pubDate>Sun, 24 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/24/%D7%AA/</guid>
      <description>一、已知前序、中序、求后序遍历 例如：
前序遍历: GDAFEMHZ中序遍历: ADEFGHMZ  根据前序遍历的特点，我们知道根结点为G
  观察中序遍历ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树，G右侧的HMZ必然是root的右子树。
  观察左子树ADEF，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为D。
  同样的道理，root的右子树节点HMZ中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。
  观察发现，上面的过程是递归的。先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。该步递归的过程可以简洁表达如下：
 确定根,确定左子树，确定右子树。 在左子树中递归。 在右子树中递归。 打印当前根。    核心代码
buildTreebyPre(preorder + 1, inorder, root_idx, root-&amp;gt;left); buildTreebyPre(preorder + 1 + root_idx, inorder + root_idx + 1, length - (root_idx + 1), root-&amp;gt;right); 二、已知中序、后序遍历、求前序遍历 依然是上面的题，这次我们只给出中序和后序遍历：
中序遍历: ADEFGHMZ后序遍历: AEFDHZMG  根据后序遍历的特点，我们知道后序遍历最后一个结点即为根结点，即根结点为G。
  观察中序遍历ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树，G右侧的HMZ必然是root的右子树。
  观察左子树ADEF，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为D。
  同样的道理，root的右子树节点HMZ中的根节点也可以通过前序遍历求得。在前后序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。</description>
    </item>
    
    <item>
      <title>LeetCode-50 &amp; LeetCode-34</title>
      <link>https://fffzlfk.gitlab.io/2019/11/23/leetcode-50/</link>
      <pubDate>Sat, 23 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/23/leetcode-50/</guid>
      <description>LeetCode-50-Pow(x, n) 问题描述 实现 pow(x, n) ，即计算 x 的 n 次幂函数。
 示例 1:  输入: 2.00000, 10输出: 1024.00000 示例 2:  输入: 2.10000, 3输出: 9.26100 示例 3:  输入: 2.00000, -2输出: 0.25000 解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 &amp;lt; x &amp;lt; 100.0, n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。  代码实现 class Solution { public: double quickPow(double x, long long n) { if (n == 0) return 1.</description>
    </item>
    
    <item>
      <title>POJ-2387-Til_the_Cows_Come_Home</title>
      <link>https://fffzlfk.gitlab.io/2019/11/22/poj2387/</link>
      <pubDate>Fri, 22 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/22/poj2387/</guid>
      <description>问题描述 贝西（Bessie）在野外，想回到谷仓以尽可能多地睡觉，直到农夫约翰（John Farmer）叫醒她早上进行挤奶。贝西需要美睡，所以她想尽快回来。
农夫约翰的田地里有N（2 &amp;lt;= N &amp;lt;= 1000）个地标，唯一编号为1..N。地标1是谷仓；Bessie整日站立的苹果树丛是地标N。奶牛使用地标之间长度各异的T（1 &amp;lt;= T &amp;lt;= 2000）双向奶牛场在田间旅行。贝西对自己的导航能力不抱有信心，因此，从开始到结束，她始终保持在步道上。
给定地标之间的路径，确定Bessie返回谷仓必须行走的最小距离。可以保证存在这样的路经。
大意 题目会给你n个点，m条边，然后给你每条边又哪两个点相连，并且其中的路程是多少。我们需要找到最短路径的总路程。
样例输入 5 51 2 202 3 303 4 204 5 201 5 100样例输出 90代码实现 #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std; #define Max 0xfffffff #define N 1005 int arcs[N][N]; int visit[N]; int f[N]; int n, t; void shortestPath() { int i, j, k, min; memset(visit, 0, sizeof(visit)); for (i = 1; i &amp;lt;= n; i++) f[i] = arcs[1][i]; f[1] = 0; for (i = 1; i &amp;lt; n; i++) { min = Max; for (j = 1; j &amp;lt;= n; j++) { if (!</description>
    </item>
    
    <item>
      <title>二分查找及二叉排序树</title>
      <link>https://fffzlfk.gitlab.io/2019/11/22/%D6%B2%D2%BD%D2%B7/</link>
      <pubDate>Fri, 22 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/22/%D6%B2%D2%BD%D2%B7/</guid>
      <description>问题描述  顺序表的二分查找（折半查找),同时实现寻找左边界和右边界的算法 二叉排序树的查找、删除以及添加结点  代码实现 二分查找 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int search_bi(vector&amp;lt;int&amp;gt; nums, int target) { int low = 0; int high = nums.size() - 1; int mid; while (low &amp;lt;= high) { mid = (low + high) / 2; if (nums[mid] == target) return mid; else if (nums[mid] &amp;lt; target) { low = mid + 1; } else { high = mid - 1; } } return -1; } int search_left(vector&amp;lt;int&amp;gt; nums, int target) { // 寻找左边界  if (!</description>
    </item>
    
    <item>
      <title>最小生成树的求法</title>
      <link>https://fffzlfk.gitlab.io/2019/11/21/%D1%81/</link>
      <pubDate>Thu, 21 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/21/%D1%81/</guid>
      <description>问题描述 请对下图的无向带权图 (1)写出它的邻接矩阵，并按普里姆算法求其最小生成树； (2)写出它的邻接表，并按克鲁斯卡尔算法求其最小生成树。 问题解决 邻接矩阵 0 4 3 - - - - -4 0 5 5 9 - - -3 5 0 5 - - - 5- 5 5 0 7 6 5 4- 9 - 7 0 3 - -- - - 6 3 0 2 -- - - 5 - 2 0 6- - 5 4 - - 6 0#include &amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>105.从前序与中序遍历序列构造二叉树</title>
      <link>https://fffzlfk.gitlab.io/2019/11/17/leetcode-105-%C7%B0%D0%B9/</link>
      <pubDate>Sun, 17 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/17/leetcode-105-%C7%B0%D0%B9/</guid>
      <description>问题描述 题目链接
根据一棵树的前序遍历与中序遍历构造二叉树。
  注意: 你可以假设树中没有重复的元素。
  例如，给出
  前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树：
 3/ \9 20/ \15 7代码实现 class Solution { public: vector&amp;lt;int&amp;gt; pre_order; vector&amp;lt;int&amp;gt; in_order; map&amp;lt;int,int&amp;gt; m; int pre_idx = 0; TreeNode* help(int inleft, int inright) { if (inleft == inright) return NULL; int root_val = pre_order[pre_idx]; TreeNode *root = new TreeNode(root_val); int index = m[root_val]; pre_idx++; root-&amp;gt;left = help(inleft, index); root-&amp;gt;right = help(index + 1, inright); return root; } TreeNode* buildTree(vector&amp;lt;int&amp;gt;&amp;amp; preorder, vector&amp;lt;int&amp;gt;&amp;amp; inorder) { pre_order = preorder; in_order = inorder; for (int i = 0; i &amp;lt; (int)inorder.</description>
    </item>
    
    <item>
      <title>98.验证二叉搜索树</title>
      <link>https://fffzlfk.gitlab.io/2019/11/17/leetcode-98-%D6%A4/</link>
      <pubDate>Sun, 17 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/17/leetcode-98-%D6%A4/</guid>
      <description>问题描述 给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。
示例 示例 1:  输入:   2/ \1 3 输出: true  示例 2:  输入:   5/ \1 4/ \3 6 输出: false  解释: 输入为: [5,1,4,null,null,3,6]。  根节点的值为 5 ，但是其右子节点值为 4 。
代码实现 bool helper(struct TreeNode *root, int lower, int upper) { if (!root) return true; // printf(&amp;#34;current low:%d\ncurrent up:%d\n&amp;#34;, lower, upper); 	if (lower !</description>
    </item>
    
    <item>
      <title>无向图的遍历</title>
      <link>https://fffzlfk.gitlab.io/2019/11/15/%CD%BC%C4%B1/</link>
      <pubDate>Fri, 15 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/15/%CD%BC%C4%B1/</guid>
      <description>问题描述  分别使用邻接表和邻接矩阵存储无向图图，并设计深度优先搜索遍历算法和广度优先搜索遍历算法。 用1,2,3，&amp;hellip;，表示结点 并分别求出深度优先生成树和广度优先生成树的边集。  代码实现 邻接表 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define MAX_VERTEX_NUM 31 typedef int InfoType; typedef int VertexType; bool visited[MAX_VERTEX_NUM]; bool dfs_arc[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; bool bfs_arc[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; typedef struct ArcNode { int adjvex; ArcNode *nextarc; InfoType *info; } ArcNode; typedef struct VNode { VertexType data; ArcNode *firstarc; } VNode, AdjList[MAX_VERTEX_NUM]; typedef struct { AdjList vertices; int vexnum, arcnum; int kind; } ALGraph; //创建无向图 void Create(ALGraph &amp;amp;G) { puts(&amp;#34;输入节点数和边数&amp;#34;); scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;G.vexnum, &amp;amp;G.arcnum); for (int i = 1; i &amp;lt;= G.</description>
    </item>
    
    <item>
      <title>求元素子树深度</title>
      <link>https://fffzlfk.gitlab.io/2019/11/13/%D4%AB/</link>
      <pubDate>Wed, 13 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/13/%D4%AB/</guid>
      <description>问题描述 请设计递归算法求以元素为x根节点的子树深度
代码实现 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define OK 1 #define ERROR 0 typedef char ElemType; typedef int Status; typedef struct Node { ElemType data; Node *left; Node *right; } * BTree; Status createBTree(BTree &amp;amp;T) { ElemType c; scanf(&amp;#34;%c&amp;#34;, &amp;amp;c); getchar(); if (c == &amp;#39; &amp;#39;) T = NULL; else { if (!(T = (Node*)malloc(sizeof(Node)))) return ERROR; T-&amp;gt;data = c; printf(&amp;#34;请输入%c的左孩子\n&amp;#34;, c); createBTree(T-&amp;gt;left); printf(&amp;#34;请输入%c的右孩子\n&amp;#34;, c); createBTree(T-&amp;gt;right); } } int getDepth(BTree T) { if (T == NULL) return 0; else { return getDepth(T-&amp;gt;left) &amp;gt; getDepth(T-&amp;gt;right) ?</description>
    </item>
    
    <item>
      <title>哈夫曼编码及译码器</title>
      <link>https://fffzlfk.gitlab.io/2019/11/10/%EB%BC%B0/</link>
      <pubDate>Sun, 10 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/10/%EB%BC%B0/</guid>
      <description>问题描述 利用哈夫曼编码进行通信可以大大提高信道利用率,缩短信息传输时间,降低传输成本。但是,这要求在发送端通过一个编码系统对待传数据预先码,在接收端将传来的数据进行译码(复原)。对于双工信道(即可以双向传输信息的信道),每端需要一个完编/译码系统。试为这样的信息收发站写一个哈夫曼码的编/译码系统。
基本要求 一个完整的系统应具有以下功能:
 I :初始化(Initialization)。从终端读人字符集大小n,以及n个字符和n个权值,建立哈夫曼树,并将它存于文件 hfmTree 中。 E :编码(Encoding)。利用以建好的哈夫曼树(如不在内存,则从文件 hfmTree 中读人),对文件 ToBeTran 中的正文进行编码,然后将结果存人文件 CodeFile 中。 D :译 码(Decoding)。利用已建好的哈夫曼树将文件 CodeFile 中的代码进行译码,结果存人文件 TextFile 中。 P :印代码文件(Print)。将文件 CodeFile 以紧凑格式显示在终端上,每行50个代码。同时将此字符形式的编码文件写人文件 CodePrin。 T :打印哈夫曼树(Tree printing)。将已在内存中的哈夫曼树以直观的方式(树或凹人表形式)显示在终端上,同时将此字符形式的哈夫曼树写人文件 TreePrint 中。  代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;#define INT_MAX 2147483647 #define OK 1 #define ERROR 0 typedef char ElemType; typedef int Status; typedef struct { char c; int weight; int parent; int left; int right; char *code; } HNode; HNode *T; int n; Status select(HNode *T, int pos, int *s1, int *s2) { int m1, m2; m1 = m2 = INT_MAX; for (int j = 1; j &amp;lt;= pos; j++) { if (T[j].</description>
    </item>
    
    <item>
      <title>哈夫曼树和哈夫曼编码</title>
      <link>https://fffzlfk.gitlab.io/2019/11/07//</link>
      <pubDate>Thu, 07 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/07//</guid>
      <description>概念解释 Huffman树是一种特殊结构的二叉树，由Huffman树设计的二进制前缀编码，也称为Huffman编码在通信领域有着广泛的应用。
  路径长度 路径长度指的是路径上分支的数目，在上图中，路径长度为2。
  节点的权 节点的权指的是为树中的每一个节点赋予的一个非负的值，如上图中每一个节点中的值。
  节点的带权路径长度 节点的带权路径长度指的是从根节点到该节点之间的路径长度与该节点权的乘积：如对于1节点的带权路径长度为：2。
  树的带权路径长度 树的带权路径长度指的是所有叶子节点的带权路径长度之和。
   有了如上的概念，对于Huffman树，其定义为： 给定nn权值作为nn个叶子节点，构造一棵二叉树，若这棵二叉树的带权路径长度达到最小，则称这样的二叉树为最优二叉树，也称为Huffman树。
 解决方法 重复以下的步骤：
 按照权值对每一个节点排序：D-F-T-E-R-A 选择权值最小的两个节点，此处为D和F生成新的节点，节点的权重这两个节点的权重之和，为2 直到只剩最后的根节点  代码实现 readfile #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; const int MAXSIZE = 1000; int read_file(FILE *fn, map&amp;lt;char, int&amp;gt; &amp;amp;word) { if (fn == NULL) return -1; char line[MAXSIZE]; while (fgets(line, 1024, fn)) { fprintf(stderr, &amp;#34;%s\n&amp;#34;, line); char *p = line; while (*p !</description>
    </item>
    
    <item>
      <title>约瑟夫环问题</title>
      <link>https://fffzlfk.gitlab.io/2019/11/06/%D5%AC%C9%AA/</link>
      <pubDate>Wed, 06 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/06/%D5%AC%C9%AA/</guid>
      <description>问题描述 编号为1, 2, 3,&amp;hellip;,n的n个人围成一圈，每个人持有一个密码（正整数），从初始m为上限从1开始报数，报到m为止，报m的出列，将他的密码作为下一个m值，如此下去，求出出列顺序。
解决思路 很容易想到用循环链表来解决该问题
测试样例 样例输入 7 203 1 7 2 4 8 4样例输出 6147235代码实现 Clang #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; typedef struct Node { int data; int id; Node *next; } * LinkList; void Create(LinkList &amp;amp;L, int n) { L = (Node*)malloc(sizeof(Node)); Node *node, *end; end = L; for (int i = 0; i &amp;lt; n; i++) { node = (Node*)malloc(sizeof(Node)); scanf(&amp;#34;%d&amp;#34;, &amp;amp;node-&amp;gt;data); node-&amp;gt;id = i + 1; end-&amp;gt;next = node; end = node; } end-&amp;gt;next = L-&amp;gt;next; } int solve(LinkList &amp;amp;L, int m) { if (m &amp;lt; 1) return -1; int t = m; Node *last = L-&amp;gt;next; Node *cur = L-&amp;gt;next; while (cur-&amp;gt;next !</description>
    </item>
    
    <item>
      <title>魔王语言解释</title>
      <link>https://fffzlfk.gitlab.io/2019/11/06/%C4%A7%D5%AD/</link>
      <pubDate>Wed, 06 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/06/%C4%A7%D5%AD/</guid>
      <description>问题描述 有一个魔王总是使用自己的一种非常精练而抽象的语言讲话，没人能听的懂。但他的语言是可以逐步解释成人能懂得语言的，因为他的语言是由以下两种形式的规则由人的语言逐 步抽象上去的：
 （1）α-&amp;gt;β1β2&amp;hellip;βn （2）(θδ1δ2&amp;hellip;δn)-&amp;gt;θδnθδn-1&amp;hellip;θδ1θ   在这两种形式中，从左到右均表示解释；从右到左表示抽象。试写一个魔王解释系统，把他的话解释成人能听懂得话。
 基本要求 用下述两条具体规则和上述规则实现。设大写字母表示魔王语言的词汇；小写字母表示人的语言词汇；希腊字母（a,b1,s,y1等）表示可以用大写或小写字母代换的变量。魔王语言可含人的词汇。
 (1) B-&amp;gt;tAdA (2) A-&amp;gt;sae  测试数据 B（ehnxgz）B 解释成tsaedsaeezegexeneietsaedsae 若将小写字母与汉字建立下表所示的对应关系，则魔王说的话是“天上一个鹅地上一个鹅鹅追鹅赶鹅下鹅蛋鹅恨鹅天上一个鹅地上一个鹅。” t d s a e z g x n i
天 地 上 一个 鹅 追 赶 下 蛋 恨
代码实现 C++ #include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;using namespace std; void solve(char c, stack&amp;lt;char&amp;gt; &amp;amp;S, string &amp;amp;str) { if (c &amp;gt;= &amp;#39;a&amp;#39; &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;z&amp;#39;) { printf(&amp;#34;%c&amp;#34;, c); str += c; } else if (c == &amp;#39;A&amp;#39;) { printf(&amp;#34;sae&amp;#34;); str += &amp;#34;sae&amp;#34;; } else if (c == &amp;#39;B&amp;#39;) { printf(&amp;#34;tsaedsae&amp;#34;); str += &amp;#34;tsaedsae&amp;#34;; } else if (c == &amp;#39;(&amp;#39;) { stack&amp;lt;char&amp;gt; SS; S.</description>
    </item>
    
    <item>
      <title>二叉树的创建和遍历</title>
      <link>https://fffzlfk.gitlab.io/2019/10/30/%C4%B5%CD%B1/</link>
      <pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/10/30/%C4%B5%CD%B1/</guid>
      <description>问题描述 用C语言实现二叉树的表示及非递归中序遍历算法（没啥说的直接上代码）
代码实现 #include &amp;lt;iostream&amp;gt;#include &amp;lt;stack&amp;gt; #define MAXSIZE 1000 #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2  typedef int Status; typedef char ElemType; using namespace std; typedef struct BiTNode { ElemType data; struct BiTNode *lchild, *rchild; } BiTNode, * BiTree; Status CreateBiTree(BiTree &amp;amp;T) { ElemType ch; scanf(&amp;#34;%c&amp;#34;, &amp;amp;ch); getchar(); if (ch == &amp;#39; &amp;#39;) T = NULL; else { if (!</description>
    </item>
    
    <item>
      <title>链栈</title>
      <link>https://fffzlfk.gitlab.io/2019/10/23/%D5%BB%CA%B5/</link>
      <pubDate>Wed, 23 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/10/23/%D5%BB%CA%B5/</guid>
      <description>简介 链栈一般用一个头指针结构top来表示，它指向栈顶元素，对于链表来说，top结构相当于它的头指针head。
代码实现 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; struct Node { int data; Node *next; }; typedef struct { Node *top; int count; } * Stack; void InitStack(Stack &amp;amp;s) { s-&amp;gt;top = (Node*)malloc(sizeof(Node)); if (!s-&amp;gt;top) { puts(&amp;#34;ERROR&amp;#34;); return; } s-&amp;gt;top = NULL; s-&amp;gt;count = 0; } void Push(Stack &amp;amp;s, int e) { Node *node = (Node*)malloc(sizeof(Node)); node-&amp;gt;data = e; node-&amp;gt;next = s-&amp;gt;top; s-&amp;gt;top = node; s-&amp;gt;count++; } int Pop(Stack &amp;amp;s) { if (s-&amp;gt;count == 0) { puts(&amp;#34;Empty&amp;#34;); exit(0); } Node *t = s-&amp;gt;top; s-&amp;gt;top = s-&amp;gt;top-&amp;gt;next; int e = t-&amp;gt;data; free(t); s-&amp;gt;count--; return e; } void ClearStack(Stack &amp;amp;s) { if (s-&amp;gt;count == 0) return; Node *p, *q; p = s-&amp;gt;top; while (p) { q = p; p = p-&amp;gt;next; free(q); } s-&amp;gt;count = 0; } int main(int argc, char const *argv[]) { Stack s; InitStack(s); for (int i = 0; i &amp;lt; 10; i++) Push(s, i); // ClearStack(s); 	printf(&amp;#34;%d\n&amp;#34;, Pop(s)); Push(s, 100); for (int i = 0; i &amp;lt; 11; i++) { printf(&amp;#34;%d\n&amp;#34;, Pop(s)); } return 0; } </description>
    </item>
    
    <item>
      <title>删除子串</title>
      <link>https://fffzlfk.gitlab.io/2019/10/21/%C9%BE%D3%B5/</link>
      <pubDate>Mon, 21 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/10/21/%C9%BE%D3%B5/</guid>
      <description>问题描述 删除s中所有与t相同的子串
 如 s = &amp;ldquo;abcdabcdabcd&amp;rdquo;, t = &amp;ldquo;cd&amp;rdquo;, 则操作后s = &amp;ldquo;ababab&amp;rdquo;
 代码实现 #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std; int* GetNext(string p) { int pLen = p.length(); int *next = new int[pLen]; next[0] = -1; int j = 0; int k = -1; while (j &amp;lt; pLen - 1) { if (k == -1 || p[j] == p[k]) { j++; k++; next[j] = k; } else { j = next[j]; } } return next; } void solve(string &amp;amp;s, string p) { int* next =GetNext(p); int sLen = s.</description>
    </item>
    
    <item>
      <title>求最长重复子串及其位置</title>
      <link>https://fffzlfk.gitlab.io/2019/10/19/%D8%B8%D3%B5%CE%BB/</link>
      <pubDate>Sat, 19 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/10/19/%D8%B8%D3%B5%CE%BB/</guid>
      <description>问题描述 给出一个线性排列的串s，求出s中出现的第一个最长重复子串及其位置；并分析时间复杂度。
 例如 s = &amp;ldquo;abcdbcd&amp;rdquo;，它的第一个出现的最长重复子串及其位置分别为：&amp;ldquo;bcd，1&amp;rdquo;。
 代码实现 #include &amp;lt;iostream&amp;gt;using namespace std; int* GetNext(string p) { int pLen = p.length(); int* next = new int[pLen]; next[0] = -1; int j = 0; int k = -1; while (j &amp;lt; pLen - 1) { if (k == -1 || p[k] == p[j]) { k++; j++; if (p[k] != p[j]) { next[j] = k; } else { next[j] = next[k]; } } else { k = next[k]; } } return next; } int KmpSearch(string s, string p) { int *next = GetNext(p); int sLen = s.</description>
    </item>
    
    <item>
      <title>KMP算法</title>
      <link>https://fffzlfk.gitlab.io/2019/10/13/kmp%E3%B7%A8/</link>
      <pubDate>Sun, 13 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/10/13/kmp%E3%B7%A8/</guid>
      <description>KMP算法描述  算法流程   设文本串匹配到i，模式串匹配到j
  若j == -1或者匹配成功(s[i] == p[j])，则i++，j++； 若j != -1且匹配不成功，则j = next[j]（相当于模式串p相对于文本串s向右移动(j - next[j])位）。  得到next数组   next数组表示当前字符之前的字符串中，有多大长度的相同前缀后缀
 对于P的前j+1个序列字符：
 若p[k] == p[j]，则next[j + 1 ] = next [j] + 1 = k + 1； 若p[k ] ≠ p[j]，如果此时p[ next[k] ] == p[j ]，则next[ j + 1 ] = next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。  代码实现 C语言 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt; #define MAXN 100  int* GetNext(char* p) { int pLen = strlen(p); int j = 0; int k = -1; int* next = new int[strlen(p)]; next[0] = -1; while (j &amp;lt; pLen - 1) { if (k == -1 || p[j] == p[k]) { j++; k++; if (p[j] !</description>
    </item>
    
    <item>
      <title>循环队列</title>
      <link>https://fffzlfk.gitlab.io/2019/10/10/%D1%AD/</link>
      <pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/10/10/%D1%AD/</guid>
      <description>问题描述 如果希望循环队列的每一个元素都能用到，需设置一个标志域tag，用tag的0或1来区分是否满队列。试写出这种结构的算法，并从时间和空间分析这两种这两种方法的适用范围。
带标志域（tag）的算法实现 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2  typedef int Status; typedef int ElemType; #define MAXSIZE 100 typedef struct { ElemType *base; int front; int rear; int tag; } SqQueue; Status InitQueue(SqQueue &amp;amp;Q) { Q.base = (ElemType*) malloc(MAXSIZE * sizeof(ElemType)); if (!Q.base) exit(OVERFLOW); Q.front = Q.rear = 0; Q.tag = 0; return OK; } int QueueLength(SqQueue Q) { return (Q.</description>
    </item>
    
    <item>
      <title>括号匹配</title>
      <link>https://fffzlfk.gitlab.io/2019/10/09/%C6%A5/</link>
      <pubDate>Wed, 09 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/10/09/%C6%A5/</guid>
      <description>问题描述 假设一个算术表达式中可以包含三种括号：圆括号&#39;(&amp;lsquo;和&amp;rsquo;)&#39;、方括号&#39;[&amp;lsquo;和 &amp;lsquo;]&amp;lsquo;以及花括号&amp;rsquo;{&amp;lsquo;和&amp;rsquo;}&#39;。编写判别所给表达式中所含括号是否正确。
解决方法 可用“期待匹配消解”的思想来设计算法，对表达式中每一个左括号都期待一个相应的右括号与之匹配，且自左至右按表达式中出现的先后论，越迟的左括号期待匹配的渴望程度越高。
代码实现 #include &amp;lt;iostream&amp;gt;#include &amp;lt;stack&amp;gt; using namespace std; bool is_march(string str) { stack&amp;lt;char&amp;gt; s; for (int i = 0; i &amp;lt; (int)str.length(); i++) { switch (str[i]) { case &amp;#39;(&amp;#39;: case &amp;#39;[&amp;#39;: case &amp;#39;{&amp;#39;: s.push(str[i]); break; case &amp;#39;)&amp;#39;: if (s.empty() || s.top() != &amp;#39;(&amp;#39;) return false; else s.pop(); break; case &amp;#39;]&amp;#39;: if (s.empty() || s.top() != &amp;#39;[&amp;#39;) return false; else s.pop(); break; case &amp;#39;}&amp;#39;: if (s.empty() || s.</description>
    </item>
    
    <item>
      <title>表达式求值</title>
      <link>https://fffzlfk.gitlab.io/2019/09/29/%CA%BD%D6%B5/</link>
      <pubDate>Sun, 29 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/09/29/%CA%BD%D6%B5/</guid>
      <description>问题描述 表达式求值是一个基本问题，是栈的一个应用。如计算： 输入&#39;#&amp;lsquo;代表结束。
算法基本思想 使用两个工作栈，一个存运算符(optr)，另一个存操作数或运算结果(opnd)。
 首先将&amp;rsquo;#&amp;lsquo;push到optr； 依次读入每个字符，若是操作数则进opnd（注意多位数情况），若为运算符则于比较optr栈顶运算符比较优先级完成相应操作。  代码实现 #include &amp;lt;iostream&amp;gt;#include &amp;lt;stack&amp;gt; using namespace std; int prec(char a, char b) { if (a == &amp;#39;+&amp;#39; || a == &amp;#39;-&amp;#39;) { if (b == &amp;#39;+&amp;#39; || b == &amp;#39;-&amp;#39; || b == &amp;#39;)&amp;#39; || b == &amp;#39;#&amp;#39;) return 1; else return -1; } else if (a == &amp;#39;*&amp;#39; || a == &amp;#39;/&amp;#39;) { if (b == &amp;#39;(&amp;#39;) return -1; else return 1; } else if (a == &amp;#39;(&amp;#39; || a == &amp;#39;#&amp;#39;) { if (a == &amp;#39;(&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;)&amp;#39;) return 0; else if (a == &amp;#39;(&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;#&amp;#39;) return -2; else if (a == &amp;#39;#&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;)&amp;#39;) return -2; else if (a == &amp;#39;#&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;#&amp;#39;) return 0; else return -1; } else if (a == &amp;#39;)&amp;#39;) { if (b == &amp;#39;(&amp;#39;) return -2; else return 1; } return -2; } int Operate(int a, int b, char c) { if (c == &amp;#39;+&amp;#39;) return a + b; else if (c == &amp;#39;-&amp;#39;) return a - b; else if (c == &amp;#39;*&amp;#39;) return a * b; else if (c == &amp;#39;/&amp;#39;) return a / b; else exit(0); } int EvaluateExpression(string s) { stack&amp;lt;char&amp;gt; optr; stack&amp;lt;int&amp;gt; opnd; optr.</description>
    </item>
    
    <item>
      <title>数据结构课后作业</title>
      <link>https://fffzlfk.gitlab.io/2019/09/28/chp1%CE%BA%D2%B5/</link>
      <pubDate>Sat, 28 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/09/28/chp1%CE%BA%D2%B5/</guid>
      <description>请参考《数据结构题集（C语言版）》严慧敏版
 2.11 typedef int Status; typedef int ElemType; typedef struct { ElemType *elem; int length; int listsize; } SqList; Status InitList_Sq(SqList &amp;amp;L) { //构造一个空线性表 	L.elem = (ElemType*)malloc(LIST_INIT_SIZE * sizeof(ElemType)); if (!L.elem) exit(OVERFLOW); L.length = 0; L.listsize = LIST_INIT_SIZE; return OK; } Status ListInsert_Sq(SqList &amp;amp;L, int i, ElemType e) { //在顺序线性表L中的第i个位置之前插入新的元素e 	if (i &amp;lt; 1 || i &amp;gt; L.length + 1) return ERROR; if (L.length &amp;gt; L.listsize) { ElemType *newbase = (ElemType*) realloc(L.</description>
    </item>
    
    <item>
      <title>用C语言实现静态链表</title>
      <link>https://fffzlfk.gitlab.io/2019/09/20/c%CA%B5%CC%AC/</link>
      <pubDate>Fri, 20 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/09/20/c%CA%B5%CC%AC/</guid>
      <description>静态链表 用数组替代指针，数组中的每一项有两个域：data &amp;amp; cur；data用来存放数据，而cur则为游标，相当于链表中的next。 代码实现 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define MAXSIZE 1000 #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2  typedef int Status; typedef int ElemType; typedef struct { ElemType data; int cur; } Component, StaticLinkList[MAXSIZE]; /*将下标为k的空闲结点回收到备用链表*/ void Free_SSL(StaticLinkList space, int k) { space[k].cur = space[0].cur; space[0].cur = k; } int ListLength(StaticLinkList L) { int j = 0; int i = L[MAXSIZE-1].</description>
    </item>
    
    <item>
      <title>简单双向循环链表的表示和实现(C语言)</title>
      <link>https://fffzlfk.gitlab.io/2019/09/15/%D1%AD%C4%B1%CA%BE%CA%B5c/</link>
      <pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/09/15/%D1%AD%C4%B1%CA%BE%CA%B5c/</guid>
      <description>双向循环链表 双向链表的每一个节点有两个指针，一个是next（下一个），一个是prep（上一个），其他和单向类似；至于循环双向链表，它的结构为： 代码实现 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2  #define LIST_INIT_SIZE 100 #define LISTINCREMENT 10  typedef int Status; typedef int ElemType; typedef struct Node { ElemType value; Node* prep; Node* next; } DbLink; DbLink* CreateDbLink(int n) { DbLink *head, *node, *end; head = (DbLink*)malloc(sizeof(DbLink)); if (!head) exit(OVERFLOW); end = head; for (int i = 0; i &amp;lt; n; i++) { node = (DbLink*)malloc(sizeof(DbLink)); if (!</description>
    </item>
    
    <item>
      <title>归并两个非递减排列的线性表(C语言)</title>
      <link>https://fffzlfk.gitlab.io/2019/09/12/%E9%B2%A2%C7%B5%DD%BC%D0%B5%D5%A1c/</link>
      <pubDate>Thu, 12 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/09/12/%E9%B2%A2%C7%B5%DD%BC%D0%B5%D5%A1c/</guid>
      <description>问题 已知线性表La, Lb按非递减有序排列，现需要将La, Lb归并为一个新的非递减有序排列线性表Lc。例如
 La = (3, 5, 8, 11) Lb = (2, 6, 8, 20) 则Lc = (2, 3, 5, 6, 8, 8,11, 20)
 方法 设两个指针pa, pb分别指向La，Lb的首元素，当前应插入Lc的元素为复杂度 显然该算法为线性复杂度，即O(n)；原因是La, Lb为非递减有序排列，故lb中的每个元素不必遍历la中每个元素；而且Lc插入操作实则是通过复制完成的。
代码实现 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2  #define LIST_INIT_SIZE 100 #define LISTINCREMENT 10  typedef int Status; typedef int ElemType; typedef struct { ElemType *elem; int length; int listsize; } SqList; Status InitList_Sq(SqList &amp;amp;L) { //构造一个空线性表 	L.</description>
    </item>
    
    <item>
      <title>求两个简单链表的并集</title>
      <link>https://fffzlfk.gitlab.io/2019/09/07/%C4%BE/</link>
      <pubDate>Sat, 07 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/09/07/%C4%BE/</guid>
      <description>问题： 给出两个单向链表，求出它们的并集 例如：
 a = [1, 2, 3], b = [2, 3, 4]; 实现InterSect(a, b), 使得a = [1, 2, 3, 4]
 代码实现 #include &amp;lt;stdio.h&amp;gt; typedef struct node { int value; node *next; } LinkList; LinkList* InitList(int n) { LinkList *head, *node, *end; head = new LinkList; end = head; while (n--) { node = new LinkList; scanf(&amp;#34;%d&amp;#34;, &amp;amp;node-&amp;gt;value); end-&amp;gt;next = node; end = node; } end-&amp;gt;next = NULL; return head; } void ShowList(LinkList *h) { while (h-&amp;gt;next !</description>
    </item>
    
    <item>
      <title>线性表的顺序表示和实现(C语言)</title>
      <link>https://fffzlfk.gitlab.io/2019/09/08/%D5%A1%CA%BE%CA%B5c/</link>
      <pubDate>Sat, 07 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/09/08/%D5%A1%CA%BE%CA%B5c/</guid>
      <description>线性表的顺序表示:  线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素。 数据元素的存储位置之间满足如下关系:  一般来说:   #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2
#define LIST_INIT_SIZE 100 #define LISTINCREMENT 10
typedef int Status; typedef int ElemType; typedef struct { ElemType *elem; int length; int listsize; } SqList;
Status InitList_Sq(SqList &amp;amp;L) { //构造一个空线性表 L.elem = (ElemType*)malloc(LIST_INIT_SIZE * sizeof(ElemType)); if (!L.elem) exit(OVERFLOW); L.length = 0; L.listsize = LIST_INIT_SIZE; return OK; }</description>
    </item>
    
    <item>
      <title>一个用C实现的简单的单向链表</title>
      <link>https://fffzlfk.gitlab.io/2019/09/03/%D2%BBc%CA%B5%D6%B5%C4%BC%C4%B5-2019/</link>
      <pubDate>Wed, 04 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/09/03/%D2%BBc%CA%B5%D6%B5%C4%BC%C4%B5-2019/</guid>
      <description>typedef struct value { int v; struct value *next; } LinkList;
LinkList *create(int n) { LinkList *head, node, end; head = (LinkList)malloc(sizeof(LinkList)); end = head; for (int i = 0; i &amp;lt; n; i++) { node = (LinkList)malloc(sizeof(LinkList)); scanf(&amp;quot;%d&amp;quot;, &amp;amp;node-&amp;gt;v); end-&amp;gt;next = node; end = node; } end-&amp;gt;next = NULL; return head; }
void change(LinkList *list, int n) { LinkList *t = list; int i = 0; while(i &amp;lt; n &amp;amp;&amp;amp; t !</description>
    </item>
    
    <item>
      <title>一个简单的位运算及其复杂度分析(Sample)</title>
      <link>https://fffzlfk.gitlab.io/2019/09/03/%D2%BB%CE%BB%E3%BC%B0%E4%B8%B4%D3%B7%C8%B7sample-2019/</link>
      <pubDate>Tue, 03 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/09/03/%D2%BB%CE%BB%E3%BC%B0%E4%B8%B4%D3%B7%C8%B7sample-2019/</guid>
      <description>代码实现： #include &amp;lt;iostream&amp;gt; using namespace std; int countOnes(unsigned int n) { int ones = 0; while(n) { ones += n &amp;amp; 1; n &amp;gt;&amp;gt;= 1; } return ones; } int main() { int n; while (cin &amp;gt;&amp;gt; n) cout &amp;lt;&amp;lt; countOnes(n) &amp;lt;&amp;lt; endl; return 0; } 时间复杂度： 总的循环次数为n展开为二进制后的位数，即无论是该循环体之前、之内还是之后,均只涉及常数次(逻辑判断、位与运算、加法、右移 等)基本操作。因此,countOnes()算法的执行时间主要由循环的次数决定,亦即:  由大O记号定义,在用函数log r n界定渐进复杂度时,常底数r的具体取值无所谓，故通常不予专门标出而笼统地记作logn，比如,尽管此处底数为常数2,却可直接记作O(logn)。此类算法称作具有“对数时间复杂度”(logarithmic-time algorithm)。</description>
    </item>
    
    <item>
      <title>求k阶斐波那契第m项的值</title>
      <link>https://fffzlfk.gitlab.io/2019/09/03/k%EC%B3%B2m%D6%B5-2019/</link>
      <pubDate>Tue, 03 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/09/03/k%EC%B3%B2m%D6%B5-2019/</guid>
      <description>代码实现 #include &amp;lt;stdio.h&amp;gt;const int MAXN = 10000; long long fib(int k, int m) { long long a[MAXN]; for (int i = 0; i &amp;lt; k - 1; i++) { a[i] = 0; } a[k - 1] = 1; for (int i = k; i &amp;lt;= m; i++) { long long s = 0; for (int j = i - 1; j &amp;gt; i - 1 - k; j--) { s += a[j]; } a[i] = s; } return a[m]; } int main() { int k, m; while (scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;k, &amp;amp;m) == 2) { printf(&amp;#34;%lld\n&amp;#34;, fib(k, m)); } return 0; } 注释 该题目出现在数据结构（C语言版）题集中的1.</description>
    </item>
    
    <item>
      <title>打印沙漏 &amp; 个位数统计</title>
      <link>https://fffzlfk.gitlab.io/2019/03/23/%D3%A1%C9%B3/</link>
      <pubDate>Sat, 23 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/03/23/%D3%A1%C9%B3/</guid>
      <description>打印沙漏  本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印  *****************  所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。
  给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。
  输入格式: 输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。
输出格式: 首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。
输入样例: 19 *输出样例: *****************2代码 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int main() { int m; char c; scanf(&amp;#34;%d %c&amp;#34;, &amp;amp;m, &amp;amp;c); int n = sqrt((m + 1) / 2.0) - 1; int surp = m - 2 * (n + 1) * (n + 1) + 1; for (int i = n; i &amp;gt;= 0; i--) { for (int j = 0; j &amp;lt; n - i; j++) putchar(&amp;#39; &amp;#39;); for (int j = 0; j &amp;lt; 2 * i + 1; j++) putchar(c); puts(&amp;#34;&amp;#34;); } for (int i = 1; i &amp;lt;= n; i++) { for (int j = 0; j &amp;lt; n - i; j++) putchar(&amp;#39; &amp;#39;); for (int j = 0; j &amp;lt; 2 * i + 1; j++) putchar(c); puts(&amp;#34;&amp;#34;); } printf(&amp;#34;%d&amp;#34;, surp); return 0; } 个位数统计 题目描述 给定一个 k 位整数，请编写程序统计每种不同的个位数字出现的次数。例如：给定 N=100311，则有 2 个 0，3 个 1，和 1 个 3。</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://fffzlfk.gitlab.io/about/</link>
      <pubDate>Wed, 03 Oct 2018 20:35:24 +0800</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/about/</guid>
      <description>About Me</description>
    </item>
    
  </channel>
</rss>
