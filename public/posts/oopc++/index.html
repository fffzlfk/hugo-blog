<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="Object-Oriented Programming" />
<meta name="keywords" content=", C&#43;&#43;" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="#252627" />
<link rel="canonical" href="https://fffzlfk.gitlab.io/posts/oopc&#43;&#43;/" /> 
<title>
     OOP(C&#43;&#43;) :: fffzlfk&#39;s Blog  — Thinking will not overcome fear but action will. 
</title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css" rel="stylesheet" type="text/css">  
<link rel="stylesheet" href="/main.0b44ca839b5cf0ae1c9a176353cd724cec3113bb1cfc03e2d9bbec8c21d31f40.css"> 


    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#252627">
    <link rel="shortcut icon" href="/favicon.ico">
    <meta name="msapplication-TileColor" content="#252627">
    <meta name="theme-color" content="#252627">

 <meta itemprop="name" content="OOP(C&#43;&#43;)">
<meta itemprop="description" content="Object-Oriented Programming">
<meta itemprop="datePublished" content="2020-10-06T12:25:11+08:00" />
<meta itemprop="dateModified" content="2020-10-06T12:25:11+08:00" />
<meta itemprop="wordCount" content="3719">
<meta itemprop="image" content="https://fffzlfk.gitlab.io"/>



<meta itemprop="keywords" content="C&#43;&#43;," />
 <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://fffzlfk.gitlab.io"/>

<meta name="twitter:title" content="OOP(C&#43;&#43;)"/>
<meta name="twitter:description" content="Object-Oriented Programming"/>
  <meta property="og:title" content="OOP(C&#43;&#43;)" />
<meta property="og:description" content="Object-Oriented Programming" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://fffzlfk.gitlab.io/posts/oopc&#43;&#43;/" />
<meta property="og:image" content="https://fffzlfk.gitlab.io"/>
<meta property="article:published_time" content="2020-10-06T12:25:11+08:00" />
<meta property="article:modified_time" content="2020-10-06T12:25:11+08:00" /><meta property="og:site_name" content="fffzlfk&#39;s Blog" />
   
<meta property="article:published_time" content="2020-10-06 12:25:11 &#43;0800 CST" /> 






<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} });
</script>

<body class="line-numbers" ></body>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-0BH7B3RWSF"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }
    gtag('js', new Date());

    gtag('config', 'G-0BH7B3RWSF');
</script>
    </head>

    <body class="">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ cd fffzlfk/home/</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://fffzlfk.gitlab.io/about">About</a></li><li><a href="https://fffzlfk.gitlab.io/posts">Blog</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        18 minutes

        
      </p>
    </div>

    <article>
      <h1 class="post-title">
        <a href="https://fffzlfk.gitlab.io/posts/oopc&#43;&#43;/">OOP(C++)</a>
      </h1>
        <hr />
        <aside id="toc">
          <div class="toc-title">Table of Contents</div>
          <nav id="TableOfContents">
  <ul>
    <li><a href="#c基础">C++基础</a>
      <ul>
        <li><a href="#c对c的扩充">C++对C的扩充</a></li>
        <li><a href="#第一次上级题目">第一次上级题目</a></li>
      </ul>
    </li>
    <li><a href="#类和对象">类和对象</a>
      <ul>
        <li><a href="#复制构造函数调用时机">复制构造函数调用时机</a></li>
        <li><a href="#指向非静态成员函数的指针">指向非静态成员函数的指针</a></li>
        <li><a href="#指向静态成员函数的指针">指向静态成员函数的指针</a></li>
        <li><a href="#对象引用的作用">对象引用的作用</a></li>
        <li><a href="#关于数据成员初始化">关于数据成员初始化</a></li>
        <li><a href="#常对象">常对象</a></li>
        <li><a href="#对象数组">对象数组</a></li>
        <li><a href="#类模板">类模板</a></li>
        <li><a href="#第二次上机题目">第二次上机题目</a></li>
      </ul>
    </li>
    <li><a href="#运算符重载">运算符重载</a>
      <ul>
        <li><a href="#不能重载的运算符">不能重载的运算符</a></li>
        <li><a href="#重载为类的成员函数">重载为类的成员函数</a></li>
        <li><a href="#友元函数">友元函数</a></li>
        <li><a href="#重载为类的友元函数">重载为类的友元函数</a></li>
        <li><a href="#重载输入输出运算符">重载输入输出运算符</a></li>
        <li><a href="#函数对象">函数对象</a></li>
        <li><a href="#类型转换运算符重载">类型转换运算符重载</a></li>
        <li><a href="#示例代码">示例代码</a></li>
      </ul>
    </li>
    <li><a href="#继承与派生">继承与派生</a>
      <ul>
        <li><a href="#派生类定义">派生类定义</a></li>
        <li><a href="#派生类的构造函数和析构函数">派生类的构造函数和析构函数</a></li>
        <li><a href="#多继承与虚基类">多继承与虚基类</a></li>
        <li><a href="#多继承引起的二义性问题">多继承引起的二义性问题</a></li>
        <li><a href="#虚基类">虚基类</a></li>
      </ul>
    </li>
    <li><a href="#多态性与虚函数">多态性与虚函数</a>
      <ul>
        <li><a href="#类型兼容规则">类型兼容规则</a></li>
        <li><a href="#多态polymorphism">多态（Polymorphism）</a></li>
        <li><a href="#第三次上机题目">第三次上机题目</a></li>
      </ul>
    </li>
    <li><a href="#输入输出流">输入输出流</a>
      <ul>
        <li><a href="#流">流</a></li>
        <li><a href="#io流类库的层次结构">I/O流类库的层次结构</a></li>
        <li><a href="#io流类库的头文件">I/O流类库的头文件</a></li>
        <li><a href="#输入输出的格式控制">输入输出的格式控制</a></li>
      </ul>
    </li>
    <li><a href="#大作业">大作业</a></li>
  </ul>
</nav>
        </aside>
        <hr />

      

      <div class="post-content">
        <h2 id="c基础">C++基础</h2>
<h3 id="c对c的扩充">C++对C的扩充</h3>
<h4 id="名字空间">名字空间</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">namespace</span> ns1{
    <span style="color:#66d9ef">int</span> inflag;
}
<span style="color:#66d9ef">namespace</span> ns2{
    <span style="color:#66d9ef">int</span> inflag;
}

ns1<span style="color:#f92672">::</span>inflag<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;
ns2<span style="color:#f92672">::</span>inflag<span style="color:#f92672">=-</span><span style="color:#ae81ff">3</span>;
<span style="color:#75715e">// using ns1::inflag; inflag=2;
</span><span style="color:#75715e">// ns2::inflag=-3;
</span></code></pre></div><h4 id="用const定义常量">用const定义常量</h4>
<ul>
<li>用const定义标识符常量时，<strong>一定要对其初始化</strong>，这是唯一方法。</li>
</ul>
<h4 id="引用">引用</h4>
<ul>
<li>
<p>对变量起另外一个名字，这个名字称为该变量的引用。</p>
</li>
<li>
<p>其中原变量名必须是一个已定义过的变量。</p>
</li>
<li>
<p>引用并没有重新在内存中开辟存储单元，只是引用原变量的单元。</p>
</li>
<li>
<p>对引用的初始化，可以用一个变量名，也可以用另一个引用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span>   a<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>;
<span style="color:#66d9ef">int</span>  <span style="color:#f92672">&amp;</span>b<span style="color:#f92672">=</span>a;
<span style="color:#66d9ef">int</span>  <span style="color:#f92672">&amp;</span>c<span style="color:#f92672">=</span>b;
</code></pre></div></li>
<li>
<p>引用同变量一样有地址，可以对其地址进行操作，即将其地址赋给一指针。</p>
</li>
<li>
<p>对const常量的引用使用如下方式：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">  <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>ri <span style="color:#f92672">=</span> i;
  <span style="color:#75715e">// ri = 10;  错误
</span><span style="color:#75715e"></span>  i <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;    <span style="color:#75715e">//正确
</span><span style="color:#75715e"></span>  cout <span style="color:#f92672">&lt;&lt;</span> ri;
</code></pre></div></li>
<li>
<p>以下的声明是非法的</p>
<ul>
<li>企图建立void类型的引用 void &amp;a</li>
<li>企图建立引用的数组 int &amp;a[6]</li>
<li>企图建立指向引用的指针 int &amp;*p</li>
</ul>
</li>
<li>
<p>指针和引用的区别：</p>
<ul>
<li>指针是通过地址<strong>间接</strong>访问某个变量，而引用是通过别名<strong>直接</strong>访问某个变量。</li>
<li>引用必须初始化，而<strong>一旦初始化后不再作为其他变量的别名</strong>。指针若不进行初始化，编译器不会报错。</li>
</ul>
</li>
</ul>
<h4 id="引用与函数">引用与函数</h4>
<ul>
<li>函数的返回值为引用类型

    <img src="https://i.postimg.cc/P5PdH4VS/1.jpg"  class="center"  style="zoom: 45% ;"  />

</li>
</ul>
<h4 id="内联函数">内联函数</h4>
<ul>
<li>调用内联函数时，编译器首先检查调用是否正确（类型安全检查或者自动进行类型转换）。如果正确，则<strong>将内联函数的代码直接替换函数调用，并用实参换型参</strong>，于是省去了函数调用的开销。因此，内联机制增加了空间开销而节约了时间开销。</li>
</ul>
<h3 id="第一次上级题目">第一次上级题目</h3>
<ol>
<li>求2个或3个正整数中的最大数，用带有默认参数的函数实现。</li>
<li>输入三个整数，将它们按由小到大的顺序输出，要求使用变量的引用。</li>
<li>编写一个程序，用同一个函数名对几个数据进行从小到大排序，数据类型可以是整型、浮点型。用重载函数实现。</li>
<li>对第3题改用函数模板实现，并与第3题程序进行对比分析。</li>
<li>设计一个日期Date类，它能实现年月日的输入和输出，要求分别将成员函数定义在类体内和类体外。</li>
<li>声明一个Circle类，有数据成员Radius（半径）、成员函数GetArea（）计算圆的面积，构造一个Circle的对象进行测试。</li>
<li>编写一个基于对象的程序，求出3个长方柱的体积。数据成员包括length(长)、width(宽)、height(高)。要求用成员函数实现以下功能：<br>
(1) 由键盘分别输入3个长方柱的长、宽、高；<br>
(2) 计算长方柱的体积；<br>
(3) 输出3个长方柱的体积。</li>
</ol>
<h4 id="源码下载">源码下载</h4>
<p><a href="/0x01/test1.cpp">1</a><br>
<a href="/0x01/test2.cpp">2</a><br>
<a href="/0x01/test3.cpp">3</a><br>
<a href="/0x01/test4.cpp">4</a><br>
<a href="/0x01/test5.cpp">5</a><br>
<a href="/0x01/test6.cpp">6</a><br>
<a href="/0x01/test7.cpp">7</a></p>
<h2 id="类和对象">类和对象</h2>
<h3 id="复制构造函数调用时机">复制构造函数调用时机</h3>
<ol>
<li>程序中需要新建立一个对象，并用另一个同类的对象对它初始化</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Box <span style="color:#a6e22e">box1</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>);
Box box2 <span style="color:#f92672">=</span> box1; <span style="color:#75715e">// Box box2(box1);
</span></code></pre></div><ol start="2">
<li>当函数的参数为类对象时，在调用函数时需要将实参对象完整的传递给形参</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>(Box b) {
  <span style="color:#75715e">// do something...
</span><span style="color:#75715e"></span>}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  Box box1(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>);
  fun(box1);
}
</code></pre></div><ol start="3">
<li>当函数的返回值是类的对象，在函数调用完毕将返回值带回函数调用处时</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Box <span style="color:#a6e22e">f1</span>() {
  Box box1(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>);
  <span style="color:#66d9ef">return</span> box1;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  Box box2;
  box2 <span style="color:#f92672">=</span> f();
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="指向非静态成员函数的指针">指向非静态成员函数的指针</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/* Author: fffzlfk */</span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Node(<span style="color:#66d9ef">int</span> xx, <span style="color:#66d9ef">int</span> yy) <span style="color:#f92672">:</span> x(xx), y(yy){}
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get_x</span>() { <span style="color:#66d9ef">return</span> x; }
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get_y</span>() { <span style="color:#66d9ef">return</span> y; }
   <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> x, y;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Node node(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);
    <span style="color:#66d9ef">int</span> (Node<span style="color:#f92672">::*</span>p_x)() <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>Node<span style="color:#f92672">::</span>get_x; <span style="color:#75715e">// 需要加类名和作用域运算符
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> (Node<span style="color:#f92672">::*</span>p_y)() <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>Node<span style="color:#f92672">::</span>get_y;
	cout <span style="color:#f92672">&lt;&lt;</span> (node.<span style="color:#f92672">*</span>p_x)() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
	cout <span style="color:#f92672">&lt;&lt;</span> (node.<span style="color:#f92672">*</span>p_y)() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="指向静态成员函数的指针">指向静态成员函数的指针</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/* Author: fffzlfk */</span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> get() { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">666</span>; }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>p)() <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>A<span style="color:#f92672">::</span>get;
    cout <span style="color:#f92672">&lt;&lt;</span> p() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#f92672">*</span>p)(); <span style="color:#75715e">// 加不加*都可
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="对象引用的作用">对象引用的作用</h3>
<style type="text/css">.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative}</style>
<svg width="0" height="0" display="none" xmlns="http://www.w3.org/2000/svg"><symbol id="tip-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"/></symbol><symbol id="note-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="warning-notice" viewBox="0 0 576 512" preserveAspectRatio="xMidYMid meet"><path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="info-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/></symbol></svg><div class="notice tip" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"></use></svg></span>Tip</p><ol>
<li>避免通过值来传递对象，而是通过引用来传递</li>
<li>参数传递的是引用，没有构造函数或析构函数被调用，节约了系统资源，提高了运行效率</li>
</ol></div>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/* Author: fffzlfk */</span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Student();
	Student <span style="color:#a6e22e">returnS</span>(Student s) { <span style="color:#66d9ef">return</span> s; }
    Student(<span style="color:#66d9ef">const</span> Student <span style="color:#f92672">&amp;</span>e) { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Copy Constructor</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>; }
    <span style="color:#f92672">~</span>Student() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Destructor</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>; }
};
Student<span style="color:#f92672">::</span>Student() {}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Student stu1;
    stu1.returnS(stu1);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出为：<br>
Copy Constructor<br>
Copy Constructor<br>
Destructor<br>
Destructor<br>
Destructor<br>
修改为</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Student<span style="color:#f92672">&amp;</span> returnS(Student <span style="color:#f92672">&amp;</span>s) { <span style="color:#66d9ef">return</span> s; }
</code></pre></div><p>之后，输出：<br>
Destructor</p>
<h3 id="关于数据成员初始化">关于数据成员初始化</h3>
<table>
<thead>
<tr>
<th>数据成员</th>
<th>成员初始化列表</th>
<th>构造函数体内</th>
<th>类外</th>
</tr>
</thead>
<tbody>
<tr>
<td>普通数据成员</td>
<td>$\checkmark $</td>
<td>$\checkmark $</td>
<td></td>
</tr>
<tr>
<td>常数据成员</td>
<td>$\checkmark $</td>
<td></td>
<td></td>
</tr>
<tr>
<td>静态数据成员</td>
<td></td>
<td></td>
<td>$\checkmark $</td>
</tr>
<tr>
<td>静态常数据成员</td>
<td></td>
<td></td>
<td>$\checkmark $</td>
</tr>
</tbody>
</table>
<h3 id="常对象">常对象</h3>
<div class="notice tip" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"></use></svg></span>Tip</p><ol>
<li>
<p>常对象的所有数据成员都是常量，不能改变。因此，常对象必须初始化。</p>
</li>
<li>
<p>不能通过常对象调用普通的成员函数，可以调用常成员函数。</p>
</li>
<li>
<p>如果要修改常对象中某个数据成员的值，可以将数据成员声明为mutable，这样就可以用声明为const的成员函数来修改它的值。</p>
</li>
</ol></div>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/* Author: fffzlfk */</span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">mutable</span> <span style="color:#66d9ef">int</span> i; <span style="color:#75715e">// 可以用常成员函数来修改
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	A() {} <span style="color:#75715e">//常对象必须初始化
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f_const</span>() <span style="color:#66d9ef">const</span> {
		i<span style="color:#f92672">++</span>;
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;f_const()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
	}
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;f()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
	}
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">const</span> A a; <span style="color:#75715e">//常对象必须初始化
</span><span style="color:#75715e"></span>	a.f_const(); <span style="color:#75715e">//常对象只能调用常成员函数
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="常成员">常成员</h4>
<ul>
<li>
<p>常数据成员</p>
<div class="notice tip" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"></use></svg></span>Tip</p><ol>
<li>
<p>在任何函数中都不能对常数据成员赋值</p>
</li>
<li>
<p>只能通过构造函数的参数初始化表对常数据成员进行初始化</p>
</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> Hour;
Time<span style="color:#f92672">::</span>Time(<span style="color:#66d9ef">int</span> h) <span style="color:#f92672">:</span> Hour(h) {}
</code></pre></div><ol start="3">
<li>类的所有对象中的常数据成员的值均不能改变，但不同对象中的该数据成员可以不同（在定义对象时给出）</li>
</ol></div>

<ul>
<li>示例程序：</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/* Author: fffzlfk */</span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  A(<span style="color:#66d9ef">int</span> i) <span style="color:#f92672">:</span> a(i) {} <span style="color:#75715e">// 非静态常数据成员只能通过初始化表来获得初值
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>() {
    cout <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> b <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
  }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> a;
  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> b;
};
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> A<span style="color:#f92672">::</span>b <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">// 静态常数据成员只能在类外初始化
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  A a1(<span style="color:#ae81ff">100</span>), a2(<span style="color:#ae81ff">0</span>);
  a1.print();
  a2.print();
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div></li>
<li>
<p>常成员函数</p>
<div class="notice tip" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"></use></svg></span>Tip</p><ol>
<li>通过常成员函数来引用本类中的数据成员，但不能修改他们</li>
<li>const 是函数类型的一部分，在声明函数时都要有const，在调用时不必加const</li>
<li>常成员函数不能更新对象的数据成员，也不能调用该类中的非const成员函数</li>
<li>通过常对象只能调用它的常成员函数，而不能调用其他成员函数</li>
<li>常对象中的成员函数不是常成员函数，除非成员函数有const修饰</li>
<li>const关键字可以用于对重载函数的区分</li>
</ol></div>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/* Author: fffzlfk */</span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">R</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  R(<span style="color:#66d9ef">int</span> r1, <span style="color:#66d9ef">int</span> r2) {
    R1 <span style="color:#f92672">=</span> r1;
    R2 <span style="color:#f92672">=</span> r2;
  }
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>() {
    cout <span style="color:#f92672">&lt;&lt;</span> R1 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;-&#39;</span> <span style="color:#f92672">&lt;&lt;</span> R2 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
  }
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>() <span style="color:#66d9ef">const</span> {
    cout <span style="color:#f92672">&lt;&lt;</span> R1 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;+&#34;</span> <span style="color:#f92672">&lt;&lt;</span> R2 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
  }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">int</span> R1, R2;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  R a(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>);
  a.print(); <span style="color:#75715e">// 普通对象a调用普通成员函数
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> R b(<span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">5</span>);
  b.print(); <span style="color:#75715e">// 常对象b调用常成员函数
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div></li>
<li>
<p>const成员和非const成员之间的调用关系</p>
<table>
<thead>
<tr>
<th>数据成员</th>
<th>非const成员函数</th>
<th>const成员函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>非const数据成员</td>
<td>可以引用，也可以改变值</td>
<td><!-- raw HTML omitted -->可以引用，但不可以改变值<!-- raw HTML omitted --></td>
</tr>
<tr>
<td>const数据成员</td>
<td>可以引用，但不能改变值</td>
<td>可以引用，但不可以改变值</td>
</tr>
<tr>
<td>const对象的数据成员</td>
<td><!-- raw HTML omitted -->不允许引用和改变值<!-- raw HTML omitted --></td>
<td>可以引用，不可以改变值</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="const与指针">const与指针</h4>
<ul>
<li>
<p>指向对象的<!-- raw HTML omitted -->常指针<!-- raw HTML omitted -->指针本身的值不能改变，即其指向不能改变。</p>
<p><strong><!-- raw HTML omitted -->类名 *const 指针变量名 = 对象地址<!-- raw HTML omitted --></strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Time <span style="color:#a6e22e">t1</span>(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">15</span>), t2;
Time <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> ptr1 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>t1;
ptr1 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>t2; <span style="color:#75715e">//错误，ptr1不能改变指向
</span><span style="color:#75715e"></span>
</code></pre></div><div class="notice tip" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"></use></svg></span>Tip</p><p>常指针始终指向同一个对象，但是可以改变其所指对象中数据成员的值。</p></div>

</li>
<li>
<p><!-- raw HTML omitted -->指向常对象的指针<!-- raw HTML omitted --></p>
<p><strong><!-- raw HTML omitted -->const 类名 *指针变量名 = 对象地址<!-- raw HTML omitted --></strong></p>
<ul>
<li>
<p>如果存在一个常对象，只能用指向常对象的指针去指向它，而不能用非const型的指针去指向它。</p>
</li>
<li>
<p>指向常对象的指针还可以指向非const型的对象，此时不能通过指针改变该对象的值，但是通过该对象本身来改变。指针本身的值也可以改变。</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Time <span style="color:#a6e22e">t1</span>(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">15</span>), t2;
<span style="color:#66d9ef">const</span> Time <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>t1; <span style="color:#75715e">// p是指向常对象的指针，并指向t1对象
</span><span style="color:#75715e"></span>(<span style="color:#f92672">*</span>p).hour <span style="color:#f92672">=</span> <span style="color:#ae81ff">18</span>;      <span style="color:#75715e">// 错误，不能通过指针改变t1的值
</span><span style="color:#75715e"></span>t1.hour <span style="color:#f92672">=</span> <span style="color:#ae81ff">18</span>;        <span style="color:#75715e">// 正确，t1不是常对象
</span><span style="color:#75715e"></span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>t2;             <span style="color:#75715e">// 正确，p改为指向t2
</span></code></pre></div><div class="notice note" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#note-notice"></use></svg></span>Note</p><p>指向常对象的指针可以指向const和非const型的对象，而指向非const型对象的指针只能指向非const的对象。</p></div>

</li>
</ul>
<h3 id="对象数组">对象数组</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/* Author: fffzlfk */</span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Box</span> {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Box(<span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>, <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>, <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> <span style="color:#ae81ff">15</span>)
        <span style="color:#f92672">:</span> height(h), width(w), length(len) {}
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">volume</span>();

  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> height, width, length;
};

<span style="color:#66d9ef">int</span> Box<span style="color:#f92672">::</span>volume() { <span style="color:#66d9ef">return</span> height <span style="color:#f92672">*</span> width <span style="color:#f92672">*</span> length; }

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// Box a[2]{{10, 12, 15}, {15, 18, 20}}; C++11标准
</span><span style="color:#75715e"></span>    Box a[<span style="color:#ae81ff">2</span>]{Box(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">15</span>),
            Box(<span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">20</span>)};  <span style="color:#75715e">// Box a[2] = {Box(10, 12, 15), Box(15, 18,
</span><span style="color:#75715e"></span>                                <span style="color:#75715e">// 20)}; 加不加等号都可
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> a[<span style="color:#ae81ff">0</span>].volume() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> a[<span style="color:#ae81ff">1</span>].volume() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
}
</code></pre></div><h3 id="类模板">类模板</h3>
<p><!-- raw HTML omitted -->类模板是对一批仅有成员数据类型不同的类的抽象<!-- raw HTML omitted --></p>
<blockquote>
<p><a href="https://blog.csdn.net/WChQGouge/article/details/100085331"><em>关于函数模板</em></a></p>
</blockquote>
<h4 id="类模板中的成员函数的定义">类模板中的成员函数的定义</h4>
<ol>
<li>
<p>可以放在类模板的定义定义体中（此时与类中的成员函数定义方法一致）</p>
</li>
<li>
<p>也可以放在类模板的外部，此时成员函数的定义格式如下：</p>
</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#960050;background-color:#1e0010">类型参数</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">返回值类型</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">类模板名</span><span style="color:#f92672">&gt;&lt;</span><span style="color:#960050;background-color:#1e0010">类型参数</span><span style="color:#f92672">&gt;::&lt;</span><span style="color:#960050;background-color:#1e0010">函数名</span><span style="color:#f92672">&gt;</span> (<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">参数表</span><span style="color:#f92672">&gt;</span>) {
<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">函数体</span><span style="color:#f92672">&gt;</span>
}
</code></pre></div><div class="notice warn" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#warn-notice"></use></svg></span></p><p>在类模板外定义成员函数时，<!-- raw HTML omitted -->每一个<!-- raw HTML omitted -->函数前均加上：<br>
<strong>template &lt;class 类型参数&gt;</strong></p></div>

<h3 id="第二次上机题目">第二次上机题目</h3>
<ol>
<li>编写设计一个People（人）类。该类的数据成员有年龄（age）、身高（height）、体重（weight）和人数（num），其中人数为静态数据成员，成员函数有构造函数（People）、进食（Eating）、运动（Sporting）、睡眠（Sleeping）、显示（Show）和显示人数（ShowNum）。其中构造函数由已知参数年龄(a)、身高(h)和体重(w)构造对象，进食函数使体重加1，运动函数使身高加1，睡眠函数使年龄、身高、体重各加1，显示函数用于显示人的年龄、身高、体重，显示人数函数为静态成员函数，用于显示人的个数。假设年龄的单位为岁，身高的单位为厘米，体重的单位为市斤，要求所有数据成员为protected访问权限，所有成员函数为public访问权限，在主函数中通过对象直接访问类的所有成员函数。</li>
<li>定义一个描述学生（Student）基本情况的类，数据成员包括姓名(name)、学号(num)、数学成绩(mathScore)、英语成绩(englishScore)、人数(count)、数学总成绩(mathTotalScore)和英语总成绩(englishTotalScore)。其中姓名定义为长度为18的字符数组，其他数据成员类型为整型，数学总成绩、英语总成绩和人数为静态数据成员，函数成员包括构造函数、显示基本数据函数（ShowBase）和显示静态数据函数(showStatic)，其中构造函数由已知参数姓名(nm)、学号(nu)、数学成绩(math)和英语成绩(english)构造对象，显示基本数据函数用于显示学生的姓名、学号、数学成绩、英语成绩，显示静态数据函数为静态成员函数，用于显示人数、数学总成绩、英语总成绩；要求所有数据成员为private访问权限，所有成员函数为public访问权限，在主函数中定义若干个学生对象，分别显示学生基本信息，以及显示学生人数，数学总成绩与英语总成绩。</li>
<li>定义一个Dog，包含name、age、sex和weight等属性以及对这些属性操作的方法。要求用字符指针描述name，并且用对象指针来测试这个类。</li>
<li>管理个人活期账户：个人储蓄活期账户包括账号、户名、密码、余额、活期年利率等信息。要求能够对个人账户进行存钱、取钱、计算年利息、打印账户相关信息等操作。编写主函数测试账户相关功能。
5．建立一个对象数组，内放5个学生的数据（学号、成绩），（1）用指针指向数组首元素，输出第1，3，5个学生的数据；（2）设立一个函数max，用指向对象的指针作函数参数，在max函数中找出5个学生中成绩最高者，并输出其学号。</li>
</ol>
<h4 id="源码下载-1">源码下载</h4>
<p><a href="/0x02/test1.cc">1</a><br>
<a href="/0x02/test2.cc">2</a><br>
<a href="/0x02/test3.cc">3</a><br>
<a href="/0x02/test4.cc">4</a><br>
<a href="/0x02/test5.cc">5</a></p>
<h2 id="运算符重载">运算符重载</h2>
<h3 id="不能重载的运算符">不能重载的运算符</h3>
<table>
<thead>
<tr>
<th>不能重载的运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>::</td>
<td>作用域运算符</td>
</tr>
<tr>
<td>.</td>
<td>成员访问运算符</td>
</tr>
<tr>
<td>.*</td>
<td>成员指针</td>
</tr>
<tr>
<td>?:</td>
<td>条件运算符</td>
</tr>
<tr>
<td>sizeof</td>
<td>长度运算符</td>
</tr>
</tbody>
</table>
<h3 id="重载为类的成员函数">重载为类的成员函数</h3>
<blockquote>
<p><strong>&lt;函数类型&gt; operator &lt;运算符&gt;(&lt;参数表&gt;) {函数体}</strong></p>
</blockquote>
<ul>
<li>C++中不允许重载有三个操作数的运算符</li>
<li>运算符作为成员函数时<strong>最多有一个形参</strong>：参数可以是对象，对象的引用，或其它类型的参数</li>
<li>运算符重载的<strong>实质就是函数重载</strong></li>
<li>运算符重载的函数参数<strong>就是该运算符涉及的操作数</strong></li>
</ul>
<h4 id="单目运算符的重载--">单目运算符的重载++、&ndash;</h4>
<ul>
<li>++为<strong>前置运算符</strong>时：<strong><!-- raw HTML omitted --> operator++() {&hellip;}</strong></li>
<li>++为<strong>后置运算符</strong>时：<strong><!-- raw HTML omitted --> operator++(int) {&hellip;}</strong></li>
</ul>
<h3 id="友元函数">友元函数</h3>
<p>有时候需要某些函数访问对象的私有成员，可以通过声明该函数为类的友元函数</p>
<div class="notice tip" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"></use></svg></span>Tip</p><ul>
<li>友元函数是可以直接访问类的私有成员的非成员函数。</li>
<li>它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend，其格式如下：<br>
<strong>friend 类型 函数名(形式参数);</strong></li>
</ul></div>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
    <span style="color:#66d9ef">int</span> i;

  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">void</span> foo(A);
};
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(A a) { cout <span style="color:#f92672">&lt;&lt;</span> a.i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    A a;
    foo(a);
}
</code></pre></div><ul>
<li>
<p>大多数情况下友元函数是某个类的成员函数，即A类中的某个成员函数是B类中的友元函数，这个成员函数可以直接访问B类中的私有数据。这实现了类与类之间的沟通。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {               <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> {
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun</span>(B <span style="color:#f92672">&amp;</span>);          <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">void</span> A<span style="color:#f92672">::</span>fun(B <span style="color:#f92672">&amp;</span>b);
};                      };
</code></pre></div></li>
<li>
<p>友元类</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {             <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> {
  ...                   ...
  <span style="color:#75715e">// B类是A类的友元       // B类可以自由使用A类中的成员
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span>;     }<span style="color:#960050;background-color:#1e0010">；</span>
};
</code></pre></div></li>
</ul>
<h3 id="重载为类的友元函数">重载为类的友元函数</h3>
<p><strong>friend &lt;函数值类型&gt; operator&lt;运算符&gt;(&lt;参数表&gt;) {函数体}</strong></p>
<ul>
<li>运算符重载为类的友元函数****最多只能有两个参数**</li>
<li>如果重载双目运算符，则第一个参数代表左操作数，第二个参数代表右操作数</li>
</ul>
<h4 id="单目运算符重载">单目运算符重载</h4>
<ul>
<li>++为<strong>前置</strong>运算符时，它的运算符重载函数的一般格式为：<strong>A operator ++(A &amp;a)</strong></li>
<li>++为<strong>后置</strong>运算符时，它的运算符重载函数的一般格式为：<strong>A operator ++(A &amp;a, int)</strong>(使用哑元区分)</li>
</ul>
<h3 id="重载输入输出运算符">重载输入输出运算符</h3>
<ul>
<li>
<p><strong>输入</strong>运算符：<strong>friend istream &amp;  operater &raquo;(istream &amp;is, ClassName &amp;f){…}</strong></p>
</li>
<li>
<p><strong>输出</strong>运算符：<strong>friend  ostream &amp;  operater &laquo;(ostream &amp;, ClassName &amp;){&hellip;}</strong></p>
</li>
</ul>
<h3 id="函数对象">函数对象</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">operator</span>()(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;operator() called. &#34;</span> <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">&lt;&lt;</span> b <span style="color:#f92672">&lt;&lt;</span> endl;
        <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b;
    }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Test sum;
    <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> sum(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>);  <span style="color:#75715e">// sum看上去像是一个函数，故也称“函数对象”
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a + b = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> s <span style="color:#f92672">&lt;&lt;</span> endl;
}
</code></pre></div><h3 id="类型转换运算符重载">类型转换运算符重载</h3>
<h4 id="基本类型到类类型的转换">基本类型到类类型的转换</h4>
<ul>
<li>如果<strong>直接将数据赋值给对象</strong>，所赋入的数据要强制类型转换，这种转换<strong>需要调用构造函数</strong>。也就是利用<strong>构造函数</strong>能完成基本类型到类类型的转换</li>
<li>使用构造函数进行类型转换必须有一个前提，那就是在这个类中定义一个只有一个参数的构造函数（或者其他参数有默认值）——<strong>转换构造函数</strong></li>
</ul>
<h4 id="类类型到基本类型的转换">类类型到基本类型的转换</h4>
<ul>
<li>
<p>C++引入一种特殊的成员函数——<strong>类型转换函数</strong>。类型转换函数实际上就是一个类型转换运算符重载函数</p>
</li>
<li>
<p>类型转换函数专门用来将类类型转换为基本数据类型，它只能被重载为成员函数</p>
</li>
<li>
<p>重载类型转换运算符函数格式：<br>
<strong>operator〈返回基本类型名〉（）
{
……
return 〈基本类型值〉
}</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
    <span style="color:#66d9ef">int</span> i;

  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    A(<span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> i(a) {}
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">show</span>(<span style="color:#66d9ef">void</span>) { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
    <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">int</span>() { <span style="color:#66d9ef">return</span> i; }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    A a1(<span style="color:#ae81ff">10</span>), a2(<span style="color:#ae81ff">20</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> a1 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> a2 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div></li>
</ul>
<h3 id="示例代码">示例代码</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Complex</span> {
    <span style="color:#66d9ef">double</span> real, imag;

   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Complex(<span style="color:#66d9ef">double</span> r <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>, <span style="color:#66d9ef">double</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>) <span style="color:#f92672">:</span> real(r), imag(i) {}
    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">getReal</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> real; }
    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">getImag</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> imag; }
    Complex <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>();
    Complex <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>(<span style="color:#66d9ef">int</span>);
    Complex <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(Complex <span style="color:#f92672">&amp;</span>);
    Complex <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(<span style="color:#66d9ef">double</span> d);
    <span style="color:#66d9ef">friend</span> istream <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">&gt;&gt;</span>(istream <span style="color:#f92672">&amp;</span>, Complex <span style="color:#f92672">&amp;</span>);
    <span style="color:#66d9ef">friend</span> ostream <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;&lt;</span>(ostream <span style="color:#f92672">&amp;</span>, <span style="color:#66d9ef">const</span> Complex <span style="color:#f92672">&amp;</span>);
};

Complex Complex<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>() { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Complex</span>(<span style="color:#f92672">++</span>real, imag); }

Complex Complex<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>(<span style="color:#66d9ef">int</span> a) { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Complex</span>(real<span style="color:#f92672">++</span>, imag); }

Complex Complex<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(Complex <span style="color:#f92672">&amp;</span>c) {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Complex</span>(real <span style="color:#f92672">+</span> c.real, imag <span style="color:#f92672">+</span> c.imag);
}

Complex Complex<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(<span style="color:#66d9ef">double</span> d) { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Complex</span>(real <span style="color:#f92672">+</span> d, imag); }

istream <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">&gt;&gt;</span>(istream <span style="color:#f92672">&amp;</span>in, Complex <span style="color:#f92672">&amp;</span>c) {
    in <span style="color:#f92672">&gt;&gt;</span> c.real <span style="color:#f92672">&gt;&gt;</span> c.imag;
    <span style="color:#66d9ef">return</span> in;
}

ostream <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;&lt;</span>(ostream <span style="color:#f92672">&amp;</span>out, <span style="color:#66d9ef">const</span> Complex <span style="color:#f92672">&amp;</span>c) {
    out <span style="color:#f92672">&lt;&lt;</span> to_string(c.real) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;+&#34;</span> <span style="color:#f92672">+</span> to_string(c.imag) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;i&#34;</span>;
    <span style="color:#66d9ef">return</span> out;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Complex a(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">+</span> a <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> a<span style="color:#f92672">++</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">++</span>a <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;  <span style="color:#75715e">// 相当于a = Complex(10); 产生临时对象，调用构造函数和析构函数
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="继承与派生">继承与派生</h2>
<h3 id="派生类定义">派生类定义</h3>
<h4 id="三种继承方式派生类中基类成员的访问控制权限">三种继承方式派生类中基类成员的访问控制权限</h4>
<table>
<thead>
<tr>
<th></th>
<th>公有继承</th>
<th>私有继承</th>
<th>保护继承</th>
</tr>
</thead>
<tbody>
<tr>
<td>公有成员</td>
<td>公有</td>
<td>私有</td>
<td>保护</td>
</tr>
<tr>
<td>私有成员</td>
<td>派生类不可访问</td>
<td>派生类不可访问</td>
<td>派生类不可访问</td>
</tr>
<tr>
<td>保护成员</td>
<td>保护</td>
<td>私有</td>
<td>保护</td>
</tr>
</tbody>
</table>
<h3 id="派生类的构造函数和析构函数">派生类的构造函数和析构函数</h3>
<h4 id="派生类构造函数">派生类构造函数</h4>
<ul>
<li>
<p>不能在派生类构造函数体中显式调用基类构造函数</p>
</li>
<li>
<p>在成员初始化表中可以显式调用基类构造函数</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Rectangle(<span style="color:#66d9ef">float</span> x,<span style="color:#66d9ef">float</span> y,<span style="color:#66d9ef">float</span> w,<span style="color:#66d9ef">float</span> h) <span style="color:#f92672">:</span> Point(x,y)
{ W<span style="color:#f92672">=</span>w; H<span style="color:#f92672">=</span>h; }
<span style="color:#960050;background-color:#1e0010">或</span><span style="color:#f92672">:</span>
Rectangle(<span style="color:#66d9ef">float</span> x,<span style="color:#66d9ef">float</span> y,<span style="color:#66d9ef">float</span> w,<span style="color:#66d9ef">float</span> h) <span style="color:#f92672">:</span> Point(x,y),W(w),H(h) {}
</code></pre></div></li>
</ul>
<h4 id="构造函数和析构函数的调用顺序">构造函数和析构函数的调用顺序</h4>
<ul>
<li>
<p>构造函数调用顺序：基类的构造函数-&gt;对象成员构造函数-&gt;派生类构造函数</p>
</li>
<li>
<p>析构函数调用顺序刚好相反</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">O</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    O() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;O()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
    <span style="color:#f92672">~</span>O() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;~O()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    A() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
    <span style="color:#f92672">~</span>A() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;~A()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A {
    O o;

   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    B() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;B()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
    <span style="color:#f92672">~</span>B() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;~B()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    B b;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>A()
O()
B()
~B()
~O()
~A()
</code></pre></li>
<li>
<p>⚠️注意</p>
<ul>
<li>当基类中没有显式定义构造函数，或定义了无参数构造函数时，派生类构造函数的初始化表可以省略对基类构造函数的调用，而采用<strong>隐含调用</strong></li>
<li>当基类的构造函数使用<strong>一个或多个参数时候</strong>，<strong>派生类必须定义构造函数</strong>，提供将<strong>参数传递</strong>给基类的构造函数的途径。这时，派生类构造函数体可能为空，仅起到参数传递作用</li>
<li>无论是哪种继承方式，基类的私有成员在派生类中都是不可被访问的。只能通过基类的成员函数访问基类的私有数据成员。</li>
<li>如果在一个派生类中要访问基类中的私有成员，可以将这个派生类声明为基类的友元。
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {              <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derive</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {              
  <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derive</span>;        <span style="color:#75715e">// 直接使用Base中的私有成员
</span><span style="color:#75715e"></span>}                         }
</code></pre></div></li>
<li>友元关系是不能继承的：B类是A类的友元，C类是B类的派生类，则C类和A类之间没有任何友元关系，除非C类声明A类是友元。</li>
</ul>
</li>
</ul>
<h3 id="多继承与虚基类">多继承与虚基类</h3>
<h4 id="多继承派生类的定义">多继承派生类的定义</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#960050;background-color:#1e0010">&lt;派生类名</span><span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">继承方式</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">基类名</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">，…，</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">继承方式</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">基类名</span>n<span style="color:#f92672">&gt;</span>
{
    <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">派生类新定义成员</span><span style="color:#f92672">&gt;</span>
}<span style="color:#960050;background-color:#1e0010">；</span>
</code></pre></div><h4 id="多继承派生类的构造函数">多继承派生类的构造函数</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">派生类名</span><span style="color:#f92672">&gt;</span>(<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">总参数表</span><span style="color:#f92672">&gt;</span>)<span style="color:#f92672">:&lt;</span><span style="color:#960050;background-color:#1e0010">基类名</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span>(<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">参数表</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span>)<span style="color:#960050;background-color:#1e0010">，…，</span><span style="color:#f92672">&lt;</span> <span style="color:#960050;background-color:#1e0010">基类名</span>n<span style="color:#f92672">&gt;</span> (<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">参数表</span>n<span style="color:#f92672">&gt;</span>)
{
    <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">派生类数据成员的初始化</span><span style="color:#f92672">&gt;</span>
};
</code></pre></div><ul>
<li>
<p>构造函数的调用顺序是：先调用所有基类的构造函数，再调用对象成员构造函数，最后调用派生类的构造函数</p>
</li>
<li>
<p>处于同一层次的各基类构造函数的调用顺序取决于<strong>定义派生类时所指定的基类顺序</strong>，与派生类构造函数中所定义的成员初始化列表无关</p>
</li>
<li>
<p>如果有多个成员类对象，则构造函数额调用顺序是<strong>对象在类中被声明的顺序</strong>，而不是它们出现在成员初始化列表的顺序</p>
</li>
<li>
<p>析构函数的调用顺序与构造函数的调用顺序相反</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">M1</span> {
    <span style="color:#66d9ef">int</span> i;

   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    M1(<span style="color:#66d9ef">int</span> _i) <span style="color:#f92672">:</span> i(_i) { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;M1(&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span>  <span style="color:#e6db74">&#34;)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">M2</span> {
    <span style="color:#66d9ef">int</span> i;

   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    M2(<span style="color:#66d9ef">int</span> _i) <span style="color:#f92672">:</span> i(_i) { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;M2(&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span>  <span style="color:#e6db74">&#34;)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base1</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Base1() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base1()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base2</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Base2() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base2()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derive</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base1, <span style="color:#66d9ef">public</span> Base2 {
    M2 m2;
    M1 m1;

   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Derive(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) <span style="color:#f92672">:</span> m1(a), m2(b), Base2()  , Base1() {}
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Derive d(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>Base1()
Base2()
M2(9)
M1(8)
</code></pre></li>
</ul>
<h3 id="多继承引起的二义性问题">多继承引起的二义性问题</h3>
<h4 id="两个基类有同名成员">两个基类有同名成员</h4>
<ul>
<li>implementation
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
  <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">void</span> display() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;display() in A&#34;</span>   <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
  };

  <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> {
    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">void</span> display() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;display() in B&#34;</span>   <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
  };

  <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A, <span style="color:#66d9ef">public</span> B {
      
  };

  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
      C c;
      c.display();
      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
  }
</code></pre></div></li>
<li>编译错误

    <img src="https://s1.ax1x.com/2020/11/10/BL72ZT.jpg"  class="center"  style="border-radius: 5px; box-shadow: inset 2px 2px 5px black, 2px 2px 5px black;"  />

</li>
</ul>
<h4 id="两个基类和派生类三者都有同名成员">两个基类和派生类三者都有同名成员</h4>
<ul>
<li>基类的同名成员在派生类中被屏蔽，或者说，派生类新增加的同名成员隐藏了基类中的同名成员</li>
<li>implementation
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> display() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;display() in A&#34;</span>   <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> display() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;display() in B&#34;</span>   <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A, <span style="color:#66d9ef">public</span> B {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> display() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;display() in C&#34;</span>   <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    C c;
    c.display();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div></li>
<li>访问的是派生类C中的成员
<pre><code>display() in C
</code></pre></li>
</ul>
<h3 id="虚基类">虚基类</h3>
<h4 id="虚基类概念">虚基类概念</h4>
<ul>
<li>为了避免对基类成员访问的二义性问题，可以将<strong>直接基类（如A、B）的共同基类如N设置为虚基类</strong>，这样共同基类N在内存中只有一个副本存在</li>
<li>引进虚基类后，派生类对象中只存在一个虚基类成员的副本</li>
<li>为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类，否则仍然会出现对基类的多次继承。</li>
</ul>

    <img src="https://s1.ax1x.com/2020/11/10/BLOP3Q.jpg"  class="center"  style="width: 60% ;border-radius: 5px; box-shadow: inset 2px 2px 5px black, 2px 2px 5px black;"  />


<h4 id="构造函数的调用顺序">构造函数的调用顺序</h4>
<ul>
<li>先调用<strong>虚基类</strong>的构造函数，<strong>再调用非虚基类</strong>的构造函数</li>
<li>若同一层次包含多个虚基类，其调用顺序为<strong>定义时的顺序</strong></li>
<li>若虚基类构造函数由非虚基类派生而来，则仍先按先调用基类构造函数，再调用派生类构造函数的顺序
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base1</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Base1() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;class Base1&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base2</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Base2() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;class Base2&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Level1</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base2, <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">public</span>   Base1 {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Level1() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;class Level1&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Level2</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base2, <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">public</span>   Base1 {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Level2() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;class Level2&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TopLevel</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Level1, <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">public</span>  Level2 {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    TopLevel() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;class TopLevel&#34;</span> <span style="color:#f92672">&lt;&lt;</span>  endl; }
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    TopLevel obj;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出</p>
<pre><code>class Base1
class Base2
class Level2
class Base2
class Level1
class TopLevel
</code></pre></li>
</ul>
<h4 id="虚基类的初始化">虚基类的初始化</h4>
<p>如果在虚基类中只定义了带参数的构造函数，则要在其所有派生类（包括直接派生类或间接派生类）中，通过构造函数的初始化表对虚基类进行初始化。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
{ A(<span style="color:#66d9ef">int</span> i){} <span style="color:#960050;background-color:#1e0010">…</span> };

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span><span style="color:#f92672">:</span><span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">public</span> A
{ B(<span style="color:#66d9ef">int</span> n)<span style="color:#f92672">:</span>A(n){}<span style="color:#960050;background-color:#1e0010">…</span> };

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span><span style="color:#f92672">:</span><span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">public</span> A
{ C(<span style="color:#66d9ef">int</span> n)<span style="color:#f92672">:</span>A(n){}<span style="color:#960050;background-color:#1e0010">…</span> }; 

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> B, <span style="color:#66d9ef">public</span> C
{ D(<span style="color:#66d9ef">int</span> n)<span style="color:#f92672">:</span>A(n),B(n),C(n){}<span style="color:#960050;background-color:#1e0010">…</span> };
</code></pre></div><ul>
<li>⚠️注意
<ul>
<li>如果多继承不牵扯到对同一基类的派生，就没有必要定义虚基类</li>
<li>使用多继承要十分小心，经常会出现二义性问题</li>
<li>能用单一继承的问题就不要用多继承</li>
</ul>
</li>
</ul>
<h2 id="多态性与虚函数">多态性与虚函数</h2>
<h3 id="类型兼容规则">类型兼容规则</h3>
<ul>
<li>派生类的对象可以赋值给基类对象</li>
<li>派生类的对象可以初始化基类的引用</li>
<li>派生类的对象的地址可以赋给基类的指针变量</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> who() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base class&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derive1</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> who() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Derive1 class&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derive2</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> who() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Derive2 class&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Base obj1, <span style="color:#f92672">*</span>p;
    <span style="color:#75715e">//定义基类对象obj1和基类对象指针p
</span><span style="color:#75715e"></span>    Derive1 obj2;
    Derive2 obj3;
    p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>obj1;  <span style="color:#75715e">// p指向obj1
</span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>who();
    <span style="color:#75715e">//通过指针p调用obj1的公有成员函数//who()
</span><span style="color:#75715e"></span>    p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>obj2;  <span style="color:#75715e">// p指向obj2
</span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>who();
    <span style="color:#75715e">// p只能访问从基类继承下来的who()
</span><span style="color:#75715e"></span>    p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>obj3;
    <span style="color:#75715e">// p指向obj2
</span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>who();
    <span style="color:#75715e">// p只能访问从基类继承下来的who()
</span><span style="color:#75715e"></span>    obj2.who();
    obj3.who();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出</p>
<pre><code>Base class
Base class
Base class
Derive1 class
Derive2 class
</code></pre><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> {
    <span style="color:#66d9ef">int</span> num;

   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Student(<span style="color:#66d9ef">int</span> n) <span style="color:#f92672">:</span> num(n) {}
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">display</span>() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;num = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> num <span style="color:#f92672">&lt;&lt;</span> endl; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graduate</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Student {
    string name;

   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Graduate(<span style="color:#66d9ef">int</span> n, string _name) <span style="color:#f92672">:</span> Student(n), name(_name) {}
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">display</span>() {
        Student<span style="color:#f92672">::</span>display();
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;name = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> name <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Student stu(<span style="color:#ae81ff">1001</span>);
    Graduate grad(<span style="color:#ae81ff">2001</span>, <span style="color:#e6db74">&#34;Jack&#34;</span>);
    Student <span style="color:#f92672">*</span>pt <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>stu;
    pt<span style="color:#f92672">-&gt;</span>display();
    pt <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>grad;
    pt<span style="color:#f92672">-&gt;</span>display();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出</p>
<pre><code>num = 1001
num = 2001
</code></pre><h3 id="多态polymorphism">多态（Polymorphism）</h3>
<p>相似功能的不同函数使用一个名称来实现，从而可以使用相同的调用方式来调用这些具有不同功能的同名函数</p>
<h4 id="多态的分类">多态的分类</h4>
<ul>
<li>静态多态性（编译时的多态性）：通过函数重载实现</li>
<li>动态多态性（运行时的多态性）：通过虚函数实现</li>
</ul>
<h4 id="虚函数">虚函数</h4>
<p>虚函数就是在基类中被关键字virtual说明、并在一个或多个派生类中被重新定义的成员函数</p>
<p><strong>virtual &lt;函数值类型&gt; &lt;函数名&gt;(&lt;参数表&gt;);</strong></p>
<ul>
<li>
<p>程序运行时，不同类的对象调用各自的虚函数，这就是动态多态</p>
</li>
<li>
<p>实现动态的多态性时，必须使用<strong>基类类型的指针变量或对象引用</strong>，并使其<strong>指向不同的派生对象</strong>，并通过调用指针或引用所指向的虚函数才能实现动态的多态性</p>
</li>
<li>
<p>声明虚函数要注意</p>
<ul>
<li>静态成员函数和友元函数不能声明为虚函数</li>
<li>内联成员函数不能声明为虚函数</li>
<li>构造函数不能是虚函数</li>
<li>析构函数可以是虚函数
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Base() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Base() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base destructor&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Derived() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
    <span style="color:#f92672">~</span>Derived() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Derived destructor&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Base <span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Derived;
    <span style="color:#66d9ef">delete</span> b;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div></li>
</ul>
</li>
</ul>
<h4 id="联编">联编</h4>
<ul>
<li>联编的分类
<ul>
<li>
<p>静态联编：在<strong>编译阶段</strong>完成的联编</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> print() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A student&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GStudent</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Student {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> print() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A graduate student&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Student s1, <span style="color:#f92672">*</span>ps;
    GStudent s2;
    s1.print();
    s2.print();
    s2.Student<span style="color:#f92672">::</span>print();
    ps <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s1;
    ps<span style="color:#f92672">-&gt;</span>print();  <span style="color:#75715e">//基类指针和基类成员函数发生关联
</span><span style="color:#75715e"></span>    ps <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s2;
    ps<span style="color:#f92672">-&gt;</span>print();
    <span style="color:#75715e">//希望调用对象s2的输出函数，但调用的却是对象s1的输出函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出</p>
<pre><code>A student
A graduate student
A student
A student
A student
</code></pre></li>
<li>
<p>动态联编：<strong>根据具体的执行情况来动态的确定</strong>，在<strong>运行阶段</strong>完成</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
   <span style="color:#75715e">// virtual可省略
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> print() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a Student&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GStudent</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Student {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> print() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A graduate student&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Student s1, <span style="color:#f92672">*</span>ps;
    GStudent s2;
    s1.print();
    s2.print();
    s2.Student<span style="color:#f92672">::</span>print();
    ps <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s1;
    ps<span style="color:#f92672">-&gt;</span>print();
    ps <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s2;
    <span style="color:#75715e">// 对象指针调用虚函数，采用动态联编方式
</span><span style="color:#75715e"></span>    ps<span style="color:#f92672">-&gt;</span>print();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出</p>
<pre><code>a Student
A graduate student
a Student
a Student
A graduate student
</code></pre><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> print() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A studnet&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GStudent</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Student {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> print() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A graduate studnet&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun</span>(Student <span style="color:#f92672">&amp;</span>s) { s.print(); }
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Student s1;
    GStudent s2;
    fun(s1);
    fun(s2);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出</p>
<pre><code>A studnet
A graduate studnet
</code></pre><ul>
<li>⚠️注意
<ul>
<li><strong>virtual</strong>关键字只能用在虚函数声明中，不能用在虚函数的实现中</li>
<li>只有通过<strong>对象指针或对象引用</strong>来调用虚函数，才能实现动态联编。如果采用对象来调用虚函数，则采用的是静态联编方式</li>
<li>在派生类中重新定义虚函数时，返回值类型、函数名、参数个数、类型和顺序，都必须与<strong>基类的原型相同</strong></li>
<li>当在派生类中定义了虚函数的重载函数，但并没有重新定义虚函数时，与虚函数同名的重载函数<strong>覆盖</strong>了派生类中的虚函数。此时若试图通过派生类对象、指针调用派生类对象的虚函数就会产生错误
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> PI <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.1415</span>;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span> {
    <span style="color:#66d9ef">int</span> X, Y;

   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Point(<span style="color:#66d9ef">int</span> X <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">int</span> Y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>X <span style="color:#f92672">=</span> X;
        <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>Y <span style="color:#f92672">=</span> Y;
    }
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">area</span>() { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0.0</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Circle</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Point {
    <span style="color:#66d9ef">double</span> radius;

   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Circle(<span style="color:#66d9ef">int</span> X, <span style="color:#66d9ef">int</span> Y, <span style="color:#66d9ef">double</span> R) <span style="color:#f92672">:</span> Point(X, Y) { radius <span style="color:#f92672">=</span> R; }
    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">area</span>(<span style="color:#66d9ef">int</span> i) { <span style="color:#66d9ef">return</span> PI <span style="color:#f92672">*</span> radius <span style="color:#f92672">*</span> radius; }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Point P1(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;P1.area = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> P1.area() <span style="color:#f92672">&lt;&lt;</span> endl;
    Circle C1(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;C1.area = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> C1.area() <span style="color:#f92672">&lt;&lt;</span> endl;
    Point <span style="color:#f92672">*</span>Pp;
    Pp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>C1;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Pp.area = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> Pp<span style="color:#f92672">-&gt;</span>area() <span style="color:#f92672">&lt;&lt;</span> endl;
    Point <span style="color:#f92672">&amp;</span>Rp <span style="color:#f92672">=</span> C1;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Rp.area = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> Rp.area() <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>
    <img src="https://s3.ax1x.com/2020/11/18/DeW6O0.png"  class="center"  style="width: 120% ;border-radius: 5px; box-shadow: inset 2px 2px 5px black,2px 2px 5px black;"  />


</li>
<li>如果在派生类中没有重新定义虚函数，则不实现动态联编，派生类的对象将使用基类虚函数的代码</li>
<li>一个类中的虚函数说明只对派生类中重定义的函数有影响，对它的基类中的函数并没有影响
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> func(<span style="color:#66d9ef">int</span> x) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;This is Base class&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        <span style="color:#66d9ef">return</span> x;
    }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SubClass</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">int</span> func(<span style="color:#66d9ef">int</span> x) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;This is SubClass&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        <span style="color:#66d9ef">return</span> x;
    }
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SubSubClass</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> SubClass {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> func(<span style="color:#66d9ef">int</span> x) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;This is SubSubClass&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        <span style="color:#66d9ef">return</span> x;
    }
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    SubSubClass ss;
    Base <span style="color:#f92672">&amp;</span>b <span style="color:#f92672">=</span> ss;
    cout <span style="color:#f92672">&lt;&lt;</span> b.func(<span style="color:#ae81ff">5</span>) <span style="color:#f92672">&lt;&lt;</span> endl;
    SubClass <span style="color:#f92672">&amp;</span>s <span style="color:#f92672">=</span> ss;
    cout <span style="color:#f92672">&lt;&lt;</span> s.func(<span style="color:#ae81ff">5</span>) <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出</p>
<pre><code>This is Base class  5
This is Sub2 class  5
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="纯虚函数">纯虚函数</h4>
<p>纯虚函数用virtual声明，<strong>没有任何实现</strong>，必须由派生类重新定义该函数提供实现</p>
<ul>
<li>
<p>纯虚函数与函数体为空的虚函数</p>
<ul>
<li>区别
<ul>
<li>前者没有函数体，后者有函数体</li>
<li>前者所在的类是抽象类，不能直接实例化；后者所在的类是可以实例化的（该类中不含有其他纯虚函数）</li>
</ul>
</li>
<li>共同点
<ul>
<li>可以派生出新的类，然后在新类中给出虚函数的实现，而且这种实现可以具有动态特征</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
  <span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> x;

  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    A() { x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000</span>; }
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// 定义纯虚函数
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A {
    <span style="color:#66d9ef">int</span> y;

  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    B() { y <span style="color:#f92672">=</span> <span style="color:#ae81ff">2000</span>; }
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;y = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> y <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }  <span style="color:#75715e">// 重新定义纯虚函数
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A {
    <span style="color:#66d9ef">int</span> z;

  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    C() { z <span style="color:#f92672">=</span> <span style="color:#ae81ff">3000</span>; }
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;z = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> z <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }  <span style="color:#75715e">// 重新定义纯虚函数
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    A <span style="color:#f92672">*</span>pa;
    B b;
    C c;
    pa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>b;
    pa<span style="color:#f92672">-&gt;</span>print();
    pa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>c;
    pa<span style="color:#f92672">-&gt;</span>print();
    <span style="color:#75715e">// A a;          不能定义抽象类的对象
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// pa = &amp;a;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// pa-&gt;pritn();
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出</p>
<pre><code>y = 2000
z = 3000
</code></pre></li>
</ul>
<h4 id="抽象类">抽象类</h4>
<ul>
<li>
<p>包含一个或多个纯虚函数的类称为抽象类</p>
</li>
<li>
<p>如果派生类没有实现基类中的<strong>所有</strong>纯虚函数，派生类也是抽象类</p>
</li>
<li>
<p>抽象类无法实例化</p>
</li>
<li>
<p>抽象类不能用作<strong>参数类型、函数值类型或显式转换的类型</strong>，但可以声明指向抽象类的的指针或引用，通过指针或引用来指向并访问派生类对象，从而实现动态多态</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span> PI <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14159</span>;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Shapes</span>  <span style="color:#75715e">//抽象类
</span><span style="color:#75715e"></span>{
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> setvalue(<span style="color:#66d9ef">int</span> d, <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
        x <span style="color:#f92672">=</span> d;
        y <span style="color:#f92672">=</span> w;
    }
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">area</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">//纯虚函数
</span><span style="color:#75715e"></span>   <span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> x, y;
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Square</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Shapes {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> area()  <span style="color:#75715e">//计算矩形面积
</span><span style="color:#75715e"></span>    {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;area of rectangle:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> x <span style="color:#f92672">*</span> y <span style="color:#f92672">&lt;&lt;</span> endl;
    }
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Circle</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Shapes {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> area()  <span style="color:#75715e">//计算圆面积
</span><span style="color:#75715e"></span>    {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;area of circle:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> PI <span style="color:#f92672">*</span> x <span style="color:#f92672">*</span> x <span style="color:#f92672">&lt;&lt;</span> endl;
    }
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Shapes <span style="color:#f92672">*</span>ptr[<span style="color:#ae81ff">2</span>];  <span style="color:#75715e">//声明抽象类指针
</span><span style="color:#75715e"></span>    Square s1;       <span style="color:#75715e">//声明派生类对象
</span><span style="color:#75715e"></span>    Circle c1;       <span style="color:#75715e">//声明派生类对象
</span><span style="color:#75715e"></span>    ptr[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s1;
    <span style="color:#75715e">//抽象类指针指向派生类对象
</span><span style="color:#75715e"></span>    ptr[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>setvalue(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">5</span>);
    ptr[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>area();
    <span style="color:#75715e">//抽象类指针调用派生类成员函数,实现多态
</span><span style="color:#75715e"></span>    ptr[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>c1;
    <span style="color:#75715e">//抽象类指针指向派生类对象
</span><span style="color:#75715e"></span>    ptr[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>setvalue(<span style="color:#ae81ff">10</span>);
    ptr[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>area();
    <span style="color:#75715e">//抽象类指针调用派生类成员函数,实现多态
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出</p>
<pre><code>area of rectangle:50
area of circle:314.159
</code></pre></li>
</ul>
<h3 id="第三次上机题目">第三次上机题目</h3>
<ol>
<li>定义一个复数类Complex，重载运算符“+”，“-”，“*”，“/”,使之能用于复数的加、减、乘、除。运算符重载函数作为Complex类的成员函数。编程序，分别求两个复数之和、差、积和商。</li>
<li>对于2行3列矩阵，重载流插入运算符“&laquo;”和流提取运算符“&raquo;”，使之能用于矩阵的输入和输出。</li>
<li>定义Time类和Date类，Time类为Date类的友元类，通过Time类中的display函数引用Date类对象的私有数据，输出年、月、日和时、分、秒。</li>
<li>分别定义Teacher（教师）类和Cadre（干部）类，采用多继承方式由这两个类派生出新类Teacher_Cadre（教师兼干部）。要求：
<ul>
<li>在两个基类中都包含姓名、年龄、性别、地址、电话等数据成员。</li>
<li>在Teacher类中还包含数据成员titile（职称），在Cadre类中还包含数据成员post（职务），在Teacher_Cadre类中还包含数据成员wages（工资）。</li>
<li>对两个基类中的姓名、年龄、性别、地址、电话等数据成员用相同的名字，在引用这些数据成员时，指定作用域。</li>
<li>在类体中声明成员函数，在类外定义成员函数。</li>
<li>在派生类Teacher_Cadre的成员函数show中调用Teacher类中的display函数，输出姓名、年龄、性别、职称、地址、电话，然后再用cout语句输出职务与工资。</li>
</ul>
</li>
<li>写一个程序，定义抽象基类Shape，由它派生出5个派生类：Circle（圆形）、Square（正方形）、Rectangle（矩形）、Trapezoid（梯形）、Triangle（三角形）。用虚函数分别计算几种图形面积，并求它们的和。要求用基类指针数组，使它的每一个元素指向一个派生类对象。</li>
</ol>
<h4 id="源码下载-2">源码下载</h4>
<p><a href="/0x03/test1.cc">1</a><br>
<a href="/0x03/test2.cc">2</a><br>
<a href="/0x03/test3.cc">3</a><br>
<a href="/0x03/test4.cc">4</a><br>
<a href="/0x03/test5.cc">5</a></p>
<h2 id="输入输出流">输入输出流</h2>
<h3 id="流">流</h3>
<p>数据从一个位置流向另一个位置。流是字节的序列。</p>
<h3 id="io流类库的层次结构">I/O流类库的层次结构</h3>
<ul>
<li>C++编译系统提供的I/O流类库含有两个平行基类：
<ul>
<li>streambuf</li>
<li>ios</li>
</ul>
</li>
<li>ios类有4个直接派生类：
<ul>
<li>输入流类istream</li>
<li>输出流类ostream</li>
<li>文件流类基类fstreambase</li>
<li>字符串流类基类strstreambase

    <img src="https://i.postimg.cc/YSF0JJhX/1.jpg"  class="left"  style="width: 80%"  />

</li>
</ul>
</li>
</ul>
<h3 id="io流类库的头文件">I/O流类库的头文件</h3>
<ul>
<li><strong>iostream</strong>：I/O流类库的最主要的头文件，包含了对输入输出流进行操作的所需的基本信息，还包括cin、cout、cerr、clog共4个流对象</li>
<li><strong>fstream</strong>：用于用户管理的文件的I/O操作</li>
<li><strong>strstream</strong>：用于字符串流I/O</li>
<li><strong>stdiostream</strong>：用于混合使用C和C++的I/O操作</li>
<li><strong>iomanip</strong>：用于格式化I/O时应包含此头文件</li>
</ul>
<h3 id="输入输出的格式控制">输入输出的格式控制</h3>
<ul>
<li>两种格式化方式
<ul>
<li>用流对象的有关成员函数进行格式化</li>
<li>用专门的控制符进行格式化输入输出</li>
</ul>
</li>
</ul>
<h4 id="用流对象的成员函数格式化">用流对象的成员函数格式化</h4>
<ul>
<li>设置状态标志
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">long</span> ios<span style="color:#f92672">::</span>setf(<span style="color:#66d9ef">long</span> flags)
</code></pre></div></li>
<li>清楚状态标志
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">long</span> ios<span style="color:#f92672">::</span>unsetf(<span style="color:#66d9ef">long</span> flags)
</code></pre></div></li>
<li>取状态标志
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">long</span> ios<span style="color:#f92672">::</span>flags()
</code></pre></div></li>
<li>取状态标志并设置状态标志
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">long</span> ios<span style="color:#f92672">::</span>flags(<span style="color:#66d9ef">long</span> flag)
</code></pre></div></li>
</ul>
<p>⚠️以上三组函数必须用流式对象（cin或cout）来调用</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">showflags</span>(<span style="color:#66d9ef">long</span> f) {
    <span style="color:#66d9ef">long</span> i;
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x8000</span>; i; i <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> ((i <span style="color:#f92672">&amp;</span> f) <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;0&#34;</span>);
    }
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">long</span> f;
    f <span style="color:#f92672">=</span> cout.flags();
    showflags(f);
    cout.setf(ios<span style="color:#f92672">::</span>showpos <span style="color:#f92672">|</span> ios<span style="color:#f92672">::</span>scientific <span style="color:#f92672">|</span> ios<span style="color:#f92672">::</span>fixed);  <span style="color:#75715e">// 追加状态标志
</span><span style="color:#75715e"></span>    f <span style="color:#f92672">=</span> cout.flags();
    showflags(f);
    cout.unsetf(ios<span style="color:#f92672">::</span>scientific);  <span style="color:#75715e">// 从状态标志中去掉scientific
</span><span style="color:#75715e"></span>    f <span style="color:#f92672">=</span> cout.flags();
    showflags(f);
    f <span style="color:#f92672">=</span> cout.flags(ios<span style="color:#f92672">::</span>hex);  <span style="color:#75715e">// 重新设置状态标志
</span><span style="color:#75715e"></span>    showflags(f);              <span style="color:#75715e">// 重新设置状态标志之前
</span><span style="color:#75715e"></span>    f <span style="color:#f92672">=</span> cout.flags();
    showflags(f);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><ul>
<li>用流对象的成员函数设置输出宽度</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> ios<span style="color:#f92672">::</span>width(<span style="color:#66d9ef">int</span> len)
<span style="color:#66d9ef">int</span> ios<span style="color:#f92672">::</span>width()
</code></pre></div><ul>
<li>第一种设置输出宽度并返回原来的输出宽度；第二种返回当前输出宽度，默认输出宽度为0</li>
<li>只对其后的第一个输出项有效</li>
<li>设置填充字符</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">char</span> ios<span style="color:#f92672">::</span>fill(<span style="color:#66d9ef">char</span> ch)
<span style="color:#66d9ef">char</span> ios<span style="color:#f92672">::</span>fill()
</code></pre></div><ul>
<li>设置输出精度</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> ios<span style="color:#f92672">::</span>precision(<span style="color:#66d9ef">int</span> p)
<span style="color:#66d9ef">int</span> ios<span style="color:#f92672">::</span>precision()
</code></pre></div><ul>
<li>默认输出精度为6</li>
<li>用流成员函数put输出字符</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">cout.out(<span style="color:#e6db74">&#39;a&#39;</span>)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> cout.width();
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;width: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> endl;
    cout.width(<span style="color:#ae81ff">8</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> cout.width() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;new width&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">char</span> c <span style="color:#f92672">=</span> cout.fill();
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;filling word is: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;(ASCII code&#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">int</span>)c <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    cout.fill(<span style="color:#e6db74">&#39;*&#39;</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> cout.fill() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;(&#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">int</span>)cout.fill() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;)(new filling word)&#34;</span>
         <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> cout.precision();
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;precision: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> j <span style="color:#f92672">&lt;&lt;</span> endl;
    cout.precision(<span style="color:#ae81ff">8</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">123.456789</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;(example)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    cout <span style="color:#f92672">&lt;&lt;</span> cout.precision() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;(new precision)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>width:0
       8(new width)
filling word is: (ASCII code32)
*(42)(new filling word)
precision:6
123.45679(example)
8(new precision)
</code></pre><ul>
<li>用于字符输入的流成员函数
<ul>
<li>不带参数的get函数
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> c;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;enter a sentence:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">while</span> ((c <span style="color:#f92672">=</span> cin.get()) <span style="color:#f92672">!=</span> EOF) <span style="color:#75715e">// 函数的返回值就是读入的字符
</span><span style="color:#75715e"></span>        cout.put(c);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div></li>
<li>有一个参数的get函数
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">char</span> c;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;enter a sentence:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">while</span> (cin.get(
        c))  <span style="color:#75715e">// 读取一个字符赋给c，如果读取成功，返回真，如失败（如遇文件结束符）则返回假
</span><span style="color:#75715e"></span>        cout.put(c);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;end&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div></li>
<li>有三个参数的get函数
<ul>
<li>cin.get(字符数组/字符指针, 字符个数n, 终止字符)</li>
<li>从输入流中读取n-1个字符，赋给指定的字符数组（或字符指针指向的数组）</li>
<li>如果在读取n-1个字符之前遇到指定的终止字符，则提前读取结束</li>
<li>如果读取成功返回真，失败（遇文件结束符）则返回假</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">char</span> ch[<span style="color:#ae81ff">20</span>];
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;enter a sentence:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    cin.get(ch, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#39;/&#39;</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> ch <span style="color:#f92672">&lt;&lt;</span> endl;
    cin.get(ch, <span style="color:#ae81ff">20</span>, <span style="color:#e6db74">&#39;\n&#39;</span>);  <span style="color:#75715e">// cin.get(ch, 20);
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> ch <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>enter a sentence:
you!/her.
you!
/her.
</code></pre></li>
<li>用getline函数读入一行字符
<ul>
<li>cin.getline(字符数组（或字符指针）, 字符个数n, 终止字符)</li>
<li>从输入流中读取一行字符，其用法与带3个参数的get函数类似
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">char</span> ch[<span style="color:#ae81ff">20</span>];
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;enter a sentence:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    cin <span style="color:#f92672">&gt;&gt;</span> ch;
    cout <span style="color:#f92672">&lt;&lt;</span> ch <span style="color:#f92672">&lt;&lt;</span> endl;
    cin.getline(ch, <span style="color:#ae81ff">20</span>, <span style="color:#e6db74">&#39;/&#39;</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> ch <span style="color:#f92672">&lt;&lt;</span> endl;
    cin.getline(ch, <span style="color:#ae81ff">20</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> ch <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>enter a sentence:
I like C++./I study C++./I am happy.
I
 like C++.
I study C++./I am h
</code></pre></li>
</ul>
</li>
<li>eof函数
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>cin.eof())
</code></pre></div></li>
<li>peek函数
<ul>
<li>无参函数，表示“观察”，观测下一字符</li>
<li>返回值是当前指针指向的当前字符，但只是观测，指针仍停留在当前位置，并不后移</li>
<li>如果要访问的字符是文件结束符时，则函数值是EOF</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">c <span style="color:#f92672">=</span> cin.peek();
</code></pre></div></li>
<li>putback函数
<ul>
<li>将前面用get或getline函数从输入流中读取的字符ch返回到输入流，插入到当前指针位置，供后面读取</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">char</span> c[<span style="color:#ae81ff">20</span>];
    <span style="color:#66d9ef">int</span> ch;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;enter a sentence:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    cin.getline(c, <span style="color:#ae81ff">15</span>, <span style="color:#e6db74">&#39;/&#39;</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> c <span style="color:#f92672">&lt;&lt;</span> endl;
    ch <span style="color:#f92672">=</span> cin.peek(); <span style="color:#75715e">// 观看当前字符
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> ch <span style="color:#f92672">&lt;&lt;</span> endl;
    cin.putback(c[<span style="color:#ae81ff">0</span>]); <span style="color:#75715e">// 将&#39;I&#39;插入到指针所指处
</span><span style="color:#75715e"></span>    cin.getline(c, <span style="color:#ae81ff">15</span>, <span style="color:#e6db74">&#39;/&#39;</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> c <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>enter a sentence:
I am a boy./ am a student./
I am a boy.
32
I am a student
</code></pre></li>
<li>ignore函数
<ul>
<li>cin.ignore(n, 终止字符)</li>
<li>跳过输入流中n个字符，或在遇到指定的终止字符时提前结束（此时跳过包括终止字符在内的若干字符）</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ignore(<span style="color:#ae81ff">5</span>, <span style="color:#e6db74">&#39;A&#39;</span>); <span style="color:#75715e">// 跳过5个字符，遇&#39;A&#39;后不再跳
</span><span style="color:#75715e"></span>ignore(); <span style="color:#f92672">&lt;-&gt;</span> ignore(<span style="color:#ae81ff">1</span>, EOF);
</code></pre></div><ul>
<li>示例代码
<ul>
<li>不加ignore
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">char</span> ch[<span style="color:#ae81ff">20</span>];
    cin.get(ch, <span style="color:#ae81ff">20</span>, <span style="color:#e6db74">&#39;/&#39;</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;the first part is: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ch <span style="color:#f92672">&lt;&lt;</span> endl;
    cin.get(ch, <span style="color:#ae81ff">20</span>, <span style="color:#e6db74">&#39;/&#39;</span>);  <span style="color:#75715e">// get不跳过终止字符
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;the second part is: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ch <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>I like C++./I study C++./I am happy.
The first part is:I like C++.
The second part is:
</code></pre></li>
<li>加ignore
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">char</span> ch[<span style="color:#ae81ff">20</span>];
    cin.get(ch, <span style="color:#ae81ff">20</span>, <span style="color:#e6db74">&#39;/&#39;</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;the first part is: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ch <span style="color:#f92672">&lt;&lt;</span> endl;
    cin.ignore();          <span style="color:#75715e">// 跳过输入流中一个字符
</span><span style="color:#75715e"></span>    cin.get(ch, <span style="color:#ae81ff">20</span>, <span style="color:#e6db74">&#39;/&#39;</span>);  <span style="color:#75715e">// get不跳过终止字符
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;the second part is: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ch <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>I like C++./I study C++./I am happy.
The first part is:I like C++.
The second part is:I study C++.
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>用控制符格式化
<ul>
<li>这组控制符<strong>不属于任何类成员</strong>，定义在inomanip头文件中</li>
<li>将他们用在提取运算符&quot;&raquo;&ldquo;或插入运算符&rdquo;&laquo;&ldquo;后面来<strong>设定输入/输出格式</strong>，即在读写对象之间插入一个修改状态的操作</li>
<li>设置输入/输出宽度setw(int)
<ul>
<li>用整型参数来指定输入/输出域的宽度。使用时只对其后一项输入/输出有效</li>
<li>当用于输出时，若实际宽度小于设置宽度时，数据向右对齐，反之则按照数据的实际宽度输出</li>
<li>当用于输入时，若输入的数据宽度超过设置宽度时，超出的数据部分被截断而被作为下一项输入内容</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;12345&#34;</span>, <span style="color:#f92672">*</span>q <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;678&#34;</span>;
    <span style="color:#66d9ef">char</span> f[<span style="color:#ae81ff">4</span>], g[<span style="color:#ae81ff">4</span>];
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> p <span style="color:#f92672">&lt;&lt;</span> setw(<span style="color:#ae81ff">6</span>) <span style="color:#f92672">&lt;&lt;</span> q <span style="color:#f92672">&lt;&lt;</span> setw(<span style="color:#ae81ff">4</span>) <span style="color:#f92672">&lt;&lt;</span> p <span style="color:#f92672">&lt;&lt;</span> q <span style="color:#f92672">&lt;&lt;</span> endl;
    cin <span style="color:#f92672">&gt;&gt;</span> setw(<span style="color:#ae81ff">4</span>) <span style="color:#f92672">&gt;&gt;</span> f <span style="color:#f92672">&gt;&gt;</span> g;
    cout <span style="color:#f92672">&lt;&lt;</span> f <span style="color:#f92672">&lt;&lt;</span> endl <span style="color:#f92672">&lt;&lt;</span> g <span style="color:#f92672">&lt;&lt;</span> endl <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i : &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>12345   67812345678
12345
123
45
i:10
</code></pre></li>
<li>设置输出填充字符setfill(char)</li>
<li>setprecision(int)
<ul>
<li>在以fixed形式和scientific形式输出时参数为小数位数</li>
</ul>
</li>
<li>setiosflags(ios::fixed)用定点方式表示实数</li>
<li>setiosflags(ios::scientific)用科学记数法方式表示实数</li>
<li>setiosflags(ios::left)左对齐</li>
<li>setiosflags(ios::right)右对齐</li>
<li>setiosflags(ios::uppercase)大写表示</li>
<li>setiosflags(ios::showpos)正号</li>
<li>setiosflags(ios::skipws)忽略前导空格</li>
<li>resetiosflags() 终止已设置的输出格式状态，在括号中应指定内容</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iomanip&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">double</span> f<span style="color:#f92672">=</span><span style="color:#ae81ff">22.0</span><span style="color:#f92672">/</span><span style="color:#ae81ff">7</span>;
    <span style="color:#75715e">//在用浮点形式表示的输出中，setprecision(n)表示实数的有效位数
</span><span style="color:#75715e"></span>    cout<span style="color:#f92672">&lt;&lt;</span>f<span style="color:#f92672">&lt;&lt;</span>endl;                    <span style="color:#75715e">//默认有效位数为6
</span><span style="color:#75715e"></span>    cout<span style="color:#f92672">&lt;&lt;</span>setprecision(<span style="color:#ae81ff">3</span>)<span style="color:#f92672">&lt;&lt;</span>f<span style="color:#f92672">&lt;&lt;</span>endl;   <span style="color:#75715e">//设置有效位数为3
</span><span style="color:#75715e">//在用定点形式表示的输出中，setprecision(n)表示实数的小数位数
</span><span style="color:#75715e"></span>    cout<span style="color:#f92672">&lt;&lt;</span>setiosflags(ios<span style="color:#f92672">::</span>fixed); 
    cout<span style="color:#f92672">&lt;&lt;</span>setprecision(<span style="color:#ae81ff">8</span>)<span style="color:#f92672">&lt;&lt;</span>f<span style="color:#f92672">&lt;&lt;</span>endl;   <span style="color:#75715e">//小数位数为8
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>3.14286
3.14
3.14285714
</code></pre><ul>
<li>设置输入/输出整型数数制dec、hex和oct</li>
<li>控制换行的控制符endl</li>
<li>代表输出单字符'\0&rsquo;的控制符ends</li>
</ul>
</li>
</ul>
<h2 id="大作业">大作业</h2>
<script type="text/javascript" src="/js/pdf-js/build/pdf.js"></script>
<style>
#the-canvas {
  border: 1px solid black;
  direction: ltr;
  width: 100%;
  height: auto;
}
#paginator{
    text-align: center;
    margin-bottom: 10px;
}
</style>

<div id="paginator">
    <button id="prev">Previous</button>
    <button id="next">Next</button>
    &nbsp; &nbsp;
    <span>Page: <span id="page_num"></span> / <span id="page_count"></span></span>
</div>
<div id="embed-pdf-container">
    <canvas id="the-canvas"></canvas>
</div>

<script type="text/javascript">
window.onload = function() {



var url = "\\pdf\\OOP-bighomework.pdf";


var pdfjsLib = window['pdfjs-dist/build/pdf'];


pdfjsLib.GlobalWorkerOptions.workerSrc = '/js/pdf-js/build/pdf.worker.js';


var pdfDoc = null,
    pageNum = 1,
    pageRendering = false,
    pageNumPending = null,
    scale = 3,
    canvas = document.getElementById('the-canvas'),
    ctx = canvas.getContext('2d');



function renderPage(num) {
  pageRendering = true;
  
  pdfDoc.getPage(num).then(function(page) {
    var viewport = page.getViewport({scale: scale});
    canvas.height = viewport.height;
    canvas.width = viewport.width;

    
    var renderContext = {
      canvasContext: ctx,
      viewport: viewport
    };
    var renderTask = page.render(renderContext);

    
    renderTask.promise.then(function() {
      pageRendering = false;
      if (pageNumPending !== null) {
        
        renderPage(pageNumPending);
        pageNumPending = null;
      }
    });
  });

  
  document.getElementById('page_num').textContent = num;
}



function queueRenderPage(num) {
  if (pageRendering) {
    pageNumPending = num;
  } else {
    renderPage(num);
  }
}



function onPrevPage() {
  if (pageNum <= 1) {
    return;
  }
  pageNum--;
  queueRenderPage(pageNum);
}
document.getElementById('prev').addEventListener('click', onPrevPage);



function onNextPage() {
  if (pageNum >= pdfDoc.numPages) {
    return;
  }
  pageNum++;
  queueRenderPage(pageNum);
}
document.getElementById('next').addEventListener('click', onNextPage);



pdfjsLib.getDocument(url).promise.then(function(pdfDoc_) {
  pdfDoc = pdfDoc_;
  document.getElementById('page_count').textContent = pdfDoc.numPages;

  
  renderPage(pageNum);
});
}

</script>

      </div>
    </article>

    <hr />

    <div class="post-info">
      
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>

        <span class="tag"><a href="https://fffzlfk.gitlab.io/tags/c&#43;&#43;/">C&#43;&#43;</a></span>
        
    </p>

      

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
        3719 Words
      </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        
          2020-10-06 12:25
        

         
          
        
      </p>
    </div>
      <hr />
      <div class="sharing-buttons">
        
<a class="resp-sharing-button__link" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ffffzlfk.gitlab.io%2fposts%2foopc%2b%2b%2f" target="_blank" rel="noopener" aria-label="" title="Share on facebook">
  <div class="resp-sharing-button resp-sharing-button--facebook resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://twitter.com/intent/tweet/?url=https%3a%2f%2ffffzlfk.gitlab.io%2fposts%2foopc%2b%2b%2f" target="_blank" rel="noopener" aria-label="" title="Share on twitter">
  <div class="resp-sharing-button resp-sharing-button--twitter resp-sharing-button--small">
      <div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://www.tumblr.com/widgets/share/tool?posttype=link&amp;title=OOP%28C%2b%2b%29&amp;caption=OOP%28C%2b%2b%29&amp;canonicalUrl=https%3a%2f%2ffffzlfk.gitlab.io%2fposts%2foopc%2b%2b%2f" target="_blank" rel="noopener" aria-label="" title="Share on tumblr">
  <div class="resp-sharing-button resp-sharing-button--tumblr resp-sharing-button--small">
    <div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.563 24c-5.093 0-7.031-3.756-7.031-6.411V9.747H5.116V6.648c3.63-1.313 4.512-4.596 4.71-6.469C9.84.051 9.941 0 9.999 0h3.517v6.114h4.801v3.633h-4.82v7.47c.016 1.001.375 2.371 2.207 2.371h.09c.631-.02 1.486-.205 1.936-.419l1.156 3.425c-.436.636-2.4 1.374-4.156 1.404h-.178l.011.002z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="mailto:?subject=OOP%28C%2b%2b%29&amp;body=https%3a%2f%2ffffzlfk.gitlab.io%2fposts%2foopc%2b%2b%2f" target="_self" rel="noopener" aria-label="" title="Share via email">
  <div class="resp-sharing-button resp-sharing-button--email resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://pinterest.com/pin/create/button/?url=https%3a%2f%2ffffzlfk.gitlab.io%2fposts%2foopc%2b%2b%2f&amp;media=https%3a%2f%2ffffzlfk.gitlab.io%2fposts%2foopc%2b%2b%2f;description=OOP%28C%2b%2b%29" target="_blank" rel="noopener" aria-label="" title="Share on pinterest">
  <div class="resp-sharing-button resp-sharing-button--pinterest resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M12.017 0C5.396 0 .029 5.367.029 11.987c0 5.079 3.158 9.417 7.618 11.162-.105-.949-.199-2.403.041-3.439.219-.937 1.406-5.957 1.406-5.957s-.359-.72-.359-1.781c0-1.663.967-2.911 2.168-2.911 1.024 0 1.518.769 1.518 1.688 0 1.029-.653 2.567-.992 3.992-.285 1.193.6 2.165 1.775 2.165 2.128 0 3.768-2.245 3.768-5.487 0-2.861-2.063-4.869-5.008-4.869-3.41 0-5.409 2.562-5.409 5.199 0 1.033.394 2.143.889 2.741.099.12.112.225.085.345-.09.375-.293 1.199-.334 1.363-.053.225-.172.271-.401.165-1.495-.69-2.433-2.878-2.433-4.646 0-3.776 2.748-7.252 7.92-7.252 4.158 0 7.392 2.967 7.392 6.923 0 4.135-2.607 7.462-6.233 7.462-1.214 0-2.354-.629-2.758-1.379l-.749 2.848c-.269 1.045-1.004 2.352-1.498 3.146 1.123.345 2.306.535 3.55.535 6.607 0 11.985-5.365 11.985-11.987C23.97 5.39 18.592.026 11.985.026L12.017 0z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ffffzlfk.gitlab.io%2fposts%2foopc%2b%2b%2f&amp;title=OOP%28C%2b%2b%29&amp;summary=OOP%28C%2b%2b%29&amp;source=https%3a%2f%2ffffzlfk.gitlab.io%2fposts%2foopc%2b%2b%2f" target="_blank" rel="noopener" aria-label="" title="Share on linkedin">
  <div class="resp-sharing-button resp-sharing-button--linkedin resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://reddit.com/submit/?url=https%3a%2f%2ffffzlfk.gitlab.io%2fposts%2foopc%2b%2b%2f&amp;resubmit=true&amp;title=OOP%28C%2b%2b%29" target="_blank" rel="noopener" aria-label="" title="Share on reddit">
  <div class="resp-sharing-button resp-sharing-button--reddit resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M12 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0zm5.01 4.744c.688 0 1.25.561 1.25 1.249a1.25 1.25 0 0 1-2.498.056l-2.597-.547-.8 3.747c1.824.07 3.48.632 4.674 1.488.308-.309.73-.491 1.207-.491.968 0 1.754.786 1.754 1.754 0 .716-.435 1.333-1.01 1.614a3.111 3.111 0 0 1 .042.52c0 2.694-3.13 4.87-7.004 4.87-3.874 0-7.004-2.176-7.004-4.87 0-.183.015-.366.043-.534A1.748 1.748 0 0 1 4.028 12c0-.968.786-1.754 1.754-1.754.463 0 .898.196 1.207.49 1.207-.883 2.878-1.43 4.744-1.487l.885-4.182a.342.342 0 0 1 .14-.197.35.35 0 0 1 .238-.042l2.906.617a1.214 1.214 0 0 1 1.108-.701zM9.25 12C8.561 12 8 12.562 8 13.25c0 .687.561 1.248 1.25 1.248.687 0 1.248-.561 1.248-1.249 0-.688-.561-1.249-1.249-1.249zm5.5 0c-.687 0-1.248.561-1.248 1.25 0 .687.561 1.248 1.249 1.248.688 0 1.249-.561 1.249-1.249 0-.687-.562-1.249-1.25-1.249zm-5.466 3.99a.327.327 0 0 0-.231.094.33.33 0 0 0 0 .463c.842.842 2.484.913 2.961.913.477 0 2.105-.056 2.961-.913a.361.361 0 0 0 .029-.463.33.33 0 0 0-.464 0c-.547.533-1.684.73-2.512.73-.828 0-1.979-.196-2.512-.73a.326.326 0 0 0-.232-.095z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://www.xing.com/app/user?op=share;url=https%3a%2f%2ffffzlfk.gitlab.io%2fposts%2foopc%2b%2b%2f;title=OOP%28C%2b%2b%29" target="_blank" rel="noopener" aria-label="" title="Share on xing">
  <div class="resp-sharing-button resp-sharing-button--xing resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M18.188 0c-.517 0-.741.325-.927.66 0 0-7.455 13.224-7.702 13.657.015.024 4.919 9.023 4.919 9.023.17.308.436.66.967.66h3.454c.211 0 .375-.078.463-.22.089-.151.089-.346-.009-.536l-4.879-8.916c-.004-.006-.004-.016 0-.022L22.139.756c.095-.191.097-.387.006-.535C22.056.078 21.894 0 21.686 0h-3.498zM3.648 4.74c-.211 0-.385.074-.473.216-.09.149-.078.339.02.531l2.34 4.05c.004.01.004.016 0 .021L1.86 16.051c-.099.188-.093.381 0 .529.085.142.239.234.45.234h3.461c.518 0 .766-.348.945-.667l3.734-6.609-2.378-4.155c-.172-.315-.434-.659-.962-.659H3.648v.016z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="whatsapp://send?text=OOP%28C%2b%2b%29%20https%3a%2f%2ffffzlfk.gitlab.io%2fposts%2foopc%2b%2b%2f" target="_blank" rel="noopener" aria-label="" title="Share on whatsapp">
  <div class="resp-sharing-button resp-sharing-button--whatsapp resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 00-3.48-8.413Z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2ffffzlfk.gitlab.io%2fposts%2foopc%2b%2b%2f&amp;t=OOP%28C%2b%2b%29" target="_blank" rel="noopener" aria-label="" title="Share on hacker news">
  <div class="resp-sharing-button resp-sharing-button--hackernews resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
			<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M0 24V0h24v24H0zM6.951 5.896l4.112 7.708v5.064h1.583v-4.972l4.148-7.799h-1.749l-2.457 4.875c-.372.745-.688 1.434-.688 1.434s-.297-.708-.651-1.434L8.831 5.896h-1.88z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://telegram.me/share/url?text=OOP%28C%2b%2b%29&amp;url=https%3a%2f%2ffffzlfk.gitlab.io%2fposts%2foopc%2b%2b%2f" target="_blank" rel="noopener" aria-label="" title="Share on telegram">
  <div class="resp-sharing-button resp-sharing-button--telegram resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
    </div>
  </div>
</a>

      </div>

    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>

        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="https://fffzlfk.gitlab.io/posts/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%BD%9C%E4%B8%9A%E9%A2%98/">
                <span class="button__icon">←</span>
                <span class="button__text">算法（第四版）</span>
              </a>
            </span>
          

          
            <span class="button next">
              <a href="https://fffzlfk.gitlab.io/posts/leetcode%E6%9D%82%E9%A2%982/">
                <span class="button__text">LeetCode杂题2</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    


    

  </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2021</span>
            
            
                <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></span>
            <span><a href="https://fffzlfk.gitlab.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/fffzlfk">fffzlfk</a></span>
          </div>
    </div>
</footer>
<script src="https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js"></script>

            
        </div>

        




<script type="text/javascript" src="/bundle.min.074523d4a7ea4c66d0617d43c2d0ea3783a6599876123627c61b28fa46b5c6005b6526f9cdfcd9a3bde4791145652e1b2dfd9ec30abb69fd067621dd3a852d25.js" integrity="sha512-B0Uj1KfqTGbQYX1DwtDqN4OmWZh2EjYnxhso&#43;ka1xgBbZSb5zfzZo73keRFFZS4bLf2ewwq7af0GdiHdOoUtJQ=="></script>



    </body>
</html>
