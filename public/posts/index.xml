<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on fffzlfk&#39;s Blog</title>
        <link>https://fffzlfk.gitlab.io/posts/</link>
        <description>Recent content in Posts on fffzlfk&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Tue, 02 Feb 2021 14:23:44 +0800</lastBuildDate>
        <atom:link href="https://fffzlfk.gitlab.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Python装饰器</title>
            <link>https://fffzlfk.gitlab.io/posts/python%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
            <pubDate>Tue, 02 Feb 2021 14:23:44 +0800</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/posts/python%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
            <description>引入 当我们想在一个函数执行前后干点什么事情的时候，可以这么写：
def foo(): print(&amp;#39;foo()!!!&amp;#39;) def bar(): print(&amp;#39;Before&amp;#39;) foo() print(&amp;#39;After&amp;#39;) bar() 装饰器实现 但这样看着总是很别扭，我们可以写成这样：
def foo(): print(&amp;#39;foo()!!!&amp;#39;) def bar(func): def inner(): print(f&amp;#39;Before {func.__name__}&amp;#39;) func() print(f&amp;#39;After {func.__name__}&amp;#39;) return inner bar(foo)() .notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative}Note
在Python中function是第一公民，所以可以它作为参数
这样我们就实现了一个简单的装饰器，我们可以发现这样在调用的时候比较麻烦，Python还提供了这样了一个语法糖：
def bar(func): def inner(): print(f&amp;#39;In Bar Before {func.__name__}&amp;#39;) func() print(f&amp;#39;In Bar After {func.__name__}&amp;#39;) return inner @bar def foo(): print(&amp;#39;foo()!!!&amp;#39;) foo() 除此之外，Python装饰器可以有多个，相当与一层层的包裹：
def bar(func): def inner(): print(f&amp;#39;In Bar Before {func.</description>
            <content type="html"><![CDATA[<h2 id="引入">引入</h2>
<p>当我们想在一个函数执行前后干点什么事情的时候，可以这么写：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">foo</span>():
	<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;foo()!!!&#39;</span>)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bar</span>():
	<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Before&#39;</span>)
	foo()
	<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;After&#39;</span>)

bar()
</code></pre></div><h2 id="装饰器实现">装饰器实现</h2>
<p>但这样看着总是很别扭，我们可以写成这样：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">foo</span>():
	<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;foo()!!!&#39;</span>)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bar</span>(func):
	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inner</span>():
		<span style="color:#66d9ef">print</span>(f<span style="color:#e6db74">&#39;Before {func.__name__}&#39;</span>)
		func()
		<span style="color:#66d9ef">print</span>(f<span style="color:#e6db74">&#39;After {func.__name__}&#39;</span>)
	<span style="color:#66d9ef">return</span> inner

bar(foo)()
</code></pre></div><style type="text/css">.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative}</style>
<svg width="0" height="0" display="none" xmlns="http://www.w3.org/2000/svg"><symbol id="tip-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"/></symbol><symbol id="note-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="warning-notice" viewBox="0 0 576 512" preserveAspectRatio="xMidYMid meet"><path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="info-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/></symbol></svg><div class="notice note" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#note-notice"></use></svg></span>Note</p><p>在Python中function是第一公民，所以可以它作为参数</p></div>

<p>这样我们就实现了一个简单的装饰器，我们可以发现这样在调用的时候比较麻烦，Python还提供了这样了一个语法糖：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bar</span>(func):
	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inner</span>():
		<span style="color:#66d9ef">print</span>(f<span style="color:#e6db74">&#39;In Bar Before {func.__name__}&#39;</span>)
		func()
		<span style="color:#66d9ef">print</span>(f<span style="color:#e6db74">&#39;In Bar After {func.__name__}&#39;</span>)
	<span style="color:#66d9ef">return</span> inner

<span style="color:#a6e22e">@bar</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">foo</span>():
	<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;foo()!!!&#39;</span>)

foo()
</code></pre></div><p>除此之外，Python装饰器可以有多个，相当与一层层的包裹：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bar</span>(func):
	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inner</span>():
		<span style="color:#66d9ef">print</span>(f<span style="color:#e6db74">&#39;In Bar Before {func.__name__}&#39;</span>)
		func()
		<span style="color:#66d9ef">print</span>(f<span style="color:#e6db74">&#39;In Bar After {func.__name__}&#39;</span>)
	<span style="color:#66d9ef">return</span> inner

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">baz</span>(func):
	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inner</span>():
		<span style="color:#66d9ef">print</span>(f<span style="color:#e6db74">&#39;In Baz Before {func.__name__}&#39;</span>)
		func()
		<span style="color:#66d9ef">print</span>(f<span style="color:#e6db74">&#39;In Baz After {func.__name__}&#39;</span>)
	<span style="color:#66d9ef">return</span> inner


<span style="color:#a6e22e">@bar</span>
<span style="color:#a6e22e">@baz</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">foo</span>():
	<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;foo()!!!&#39;</span>)

foo()
</code></pre></div><p>上述代码的输出为：</p>
<pre><code>In Bar Before inner
In Baz Before foo
foo()!!!
In Baz After foo
In Bar After inner
</code></pre><h2 id="一个应用场景">一个应用场景</h2>
<p>我们有一个这样的函数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> time

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">slow_method</span>():
	time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">2</span>)
	<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Done!&#39;</span>)
</code></pre></div><p>我们想知道这个函数的运行时间，我们可以用装饰器来实现:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> time

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">timeit</span>(func):
	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inner</span>():
		s <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>time()
		func()
		e <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>time()
		<span style="color:#66d9ef">print</span>(f<span style="color:#e6db74">&#39;{func.__name__} Finished in {e - s}s.&#39;</span>)
	<span style="color:#66d9ef">return</span> inner

<span style="color:#a6e22e">@timeit</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">slow_method</span>():
	time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">2</span>)
	<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Done!&#39;</span>)

slow_method()
</code></pre></div><p>运行结果：</p>
<pre><code>Done!
slow_method Finished in 2.0159008502960205s.
</code></pre><p>这样我们就实现了我们的需求。</p>
<p>当被装饰的函数有参数时，同样可以：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> time

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">timeit</span>(func):
	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inner</span>(<span style="color:#f92672">*</span>args):
		s <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>time()
		func(<span style="color:#f92672">*</span>args)
		e <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>time()
		<span style="color:#66d9ef">print</span>(f<span style="color:#e6db74">&#39;{func.__name__} Finished in {e - s}s.&#39;</span>)
	<span style="color:#66d9ef">return</span> inner

<span style="color:#a6e22e">@timeit</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">slow_method</span>(a, b):
	time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">2</span>)
	<span style="color:#66d9ef">print</span>(f<span style="color:#e6db74">&#39;{a} + {b} = {a+b}&#39;</span>)
	<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Done!&#39;</span>)

slow_method(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
</code></pre></div><p>运行结果</p>
<pre><code>1 + 2 = 3
Done!
slow_method Finished in 2.0069477558135986s.
</code></pre><h2 id="巧用装饰器来实现记忆化递归">巧用装饰器来实现记忆化递归</h2>
<p>首先我们有一个朴素的Fibonacci函数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fib</span>(n):
	<span style="color:#66d9ef">if</span> n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>: <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">return</span> fib(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> fib(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>)
</code></pre></div><p>很明显我们知道这个函数是十分低效的，我们可以使用记忆化递归来优化这个函数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">cache <span style="color:#f92672">=</span> {}

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fib</span>(n):
	<span style="color:#66d9ef">if</span> n <span style="color:#f92672">in</span> cache: <span style="color:#66d9ef">return</span> cache[n]
	<span style="color:#66d9ef">if</span> n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>: <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
	cache[n] <span style="color:#f92672">=</span> fib(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> fib(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>)
	<span style="color:#66d9ef">return</span> cache[n]

<span style="color:#66d9ef">print</span>(fib(<span style="color:#ae81ff">333</span>))
</code></pre></div><p>这样我们就能使fib函数快很多。但实现稍微有点麻烦，我们可以用装饰器来简化代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyCache</span>(object):
	<span style="color:#66d9ef">def</span> __init__(self, func):
		self<span style="color:#f92672">.</span>func <span style="color:#f92672">=</span> func
		self<span style="color:#f92672">.</span>cache <span style="color:#f92672">=</span> {}

	<span style="color:#66d9ef">def</span> __call__(self, <span style="color:#f92672">*</span>args):
		<span style="color:#66d9ef">if</span> args <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>cache:
			self<span style="color:#f92672">.</span>cache[args] <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>func(<span style="color:#f92672">*</span>args)
		<span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>cache[args]

<span style="color:#a6e22e">@MyCache</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fib</span>(n):
	<span style="color:#66d9ef">if</span> n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>: <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">return</span> fib(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> fib(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>)


<span style="color:#66d9ef">print</span>(fib(<span style="color:#ae81ff">333</span>))
</code></pre></div><p>这样我们就非常优雅的实现了fib函数。</p>
]]></content>
        </item>
        
        <item>
            <title>AcWing寒假每日一题</title>
            <link>https://fffzlfk.gitlab.io/posts/acwing%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</link>
            <pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/posts/acwing%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</guid>
            <description>Week 1 货仓选址 题目链接
思路 绝对值不等式：$|a_1 - x| + |a_2 - x| + |a_3 - x| + &amp;hellip; + |a_n - x| \ge |a_n-a_1| + |a_{n-1}-a_{2}|+&amp;hellip; $ 结论：当n为奇数，x应在中位数；当n为偶数时，x应在中间两个数之间。
代码 #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std; const int N = 100005; int a[N]; int n; int main() { cin &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; n; i++) cin &amp;gt;&amp;gt; a[i]; sort(a, a + n); int ans = 0; for (int i = 0; i &amp;lt; n; i++) ans += abs(a[i]-a[n/2]); cout &amp;lt;&amp;lt; ans; return 0; } 数字三角形-DP 题目链接</description>
            <content type="html"><![CDATA[<h2 id="week-1">Week 1</h2>
<h3 id="货仓选址">货仓选址</h3>
<p><a href="https://www.acwing.com/problem/content/description/106/">题目链接</a></p>
<h4 id="思路">思路</h4>
<p>绝对值不等式：$|a_1 - x| + |a_2 - x| + |a_3 - x| + &hellip; + |a_n - x| \ge |a_n-a_1| + |a_{n-1}-a_{2}|+&hellip; $
结论：当n为奇数，x应在中位数；当n为偶数时，x应在中间两个数之间。</p>
<h4 id="代码">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">100005</span>;
<span style="color:#66d9ef">int</span> a[N];
<span style="color:#66d9ef">int</span> n;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
        cin <span style="color:#f92672">&gt;&gt;</span> a[i];
    sort(a, a <span style="color:#f92672">+</span> n);
    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) ans <span style="color:#f92672">+=</span> abs(a[i]<span style="color:#f92672">-</span>a[n<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>]);
    cout <span style="color:#f92672">&lt;&lt;</span> ans;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="数字三角形-dp">数字三角形-DP</h3>
<p><a href="https://www.acwing.com/problem/content/900/">题目链接</a></p>
<h4 id="思路-1">思路</h4>
<p>从下到上，$ f[i][j] = max(f[i+1][j]+w[i][j], f[i+1][j+1]+w[i][j]) $</p>
<h4 id="代码-1">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">505</span>;

<span style="color:#66d9ef">int</span> f[N][N], w[N][N];
<span style="color:#66d9ef">int</span> n;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> i; j<span style="color:#f92672">++</span>)
            cin <span style="color:#f92672">&gt;&gt;</span> w[i][j];
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
        f[n][i] <span style="color:#f92672">=</span> w[n][i];
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">--</span>)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> i; j<span style="color:#f92672">++</span>)
            f[i][j] <span style="color:#f92672">=</span> max(f[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j]<span style="color:#f92672">+</span>w[i][j], f[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span>w[i][j]);
    cout <span style="color:#f92672">&lt;&lt;</span> f[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="简化等价变换版代码">简化(等价变换)版代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">505</span>;

<span style="color:#66d9ef">int</span> f[N][N];
<span style="color:#66d9ef">int</span> n;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> i; j<span style="color:#f92672">++</span>)
            cin <span style="color:#f92672">&gt;&gt;</span> f[i][j];

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">--</span>)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> i; j<span style="color:#f92672">++</span>)
            f[i][j] <span style="color:#f92672">+=</span> max(f[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j], f[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]);
    cout <span style="color:#f92672">&lt;&lt;</span> f[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="week-2">Week 2</h2>
<h3 id="蛇形矩阵">蛇形矩阵</h3>
<p><a href="https://www.acwing.com/problem/content/description/758/">题目链接</a></p>
<h4 id="代码-2">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">105</span>;

<span style="color:#66d9ef">int</span> n, m;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dx[]{<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>}, dy[]{<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};
<span style="color:#66d9ef">int</span> q[N][N];

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, d <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n <span style="color:#f92672">*</span> m; i<span style="color:#f92672">++</span>) {
        q[x][y] <span style="color:#f92672">=</span> i;
        <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> dx[d], b <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> dy[d];
        <span style="color:#66d9ef">if</span> (a <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> a <span style="color:#f92672">&gt;=</span> n <span style="color:#f92672">||</span> b <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> b <span style="color:#f92672">&gt;=</span> m <span style="color:#f92672">||</span> q[a][b]) {
            d <span style="color:#f92672">=</span> (d <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span>;
            a <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> dx[d], b <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> dy[d];
        }
        x <span style="color:#f92672">=</span> a, y <span style="color:#f92672">=</span> b;
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> m; j<span style="color:#f92672">++</span>)
            cout <span style="color:#f92672">&lt;&lt;</span> q[i][j] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span>;
        cout <span style="color:#f92672">&lt;&lt;</span> endl;
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="红与黑-flood-fill算法">红与黑-Flood Fill算法</h3>
<p><a href="https://www.acwing.com/problem/content/description/1115/">题目链接</a></p>
<h4 id="思路-2">思路</h4>
<p>Flood-Fill</p>
<ul>
<li>BFS（最短距离）</li>
</ul>
<pre><code>while 队列为空
{
    取出队头t
    枚举t的4个邻格
    if 格子是陆地并且未开发
        标记为已被开发
        插入队列
}
</code></pre><ul>
<li>DFS（更方便）</li>
</ul>
<pre><code>dfs(x, y)
{
    将(x, y)标记为已开发
    枚举(x, y)的四个邻格
    if 格子是陆地并且未开发
        dfs该格子
}
</code></pre><h4 id="代码-3">代码</h4>
<h5 id="bfs">BFS</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#define x first
</span><span style="color:#75715e">#define y second
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">typedef</span> pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> PII;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">25</span>;
<span style="color:#66d9ef">int</span> n, m;
<span style="color:#66d9ef">char</span> g[N][N];

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bfs</span>(<span style="color:#66d9ef">int</span> sx, <span style="color:#66d9ef">int</span> sy) {
	queue<span style="color:#f92672">&lt;</span>PII<span style="color:#f92672">&gt;</span> Q;
	Q.push({sx, sy});
	g[sx][sy] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;#&#39;</span>;
	<span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dx[]{<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>}, dy[]{<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};
	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>Q.empty()) {
		<span style="color:#66d9ef">auto</span> t <span style="color:#f92672">=</span> Q.front();
		Q.pop();
		res<span style="color:#f92672">++</span>;
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
			<span style="color:#66d9ef">int</span> nx <span style="color:#f92672">=</span> t.x <span style="color:#f92672">+</span> dx[i], ny <span style="color:#f92672">=</span> t.y <span style="color:#f92672">+</span> dy[i];
			<span style="color:#66d9ef">if</span> (nx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> nx <span style="color:#f92672">&gt;=</span> n <span style="color:#f92672">||</span> ny <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> ny <span style="color:#f92672">&gt;=</span> m <span style="color:#f92672">||</span> g[nx][ny] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;.&#39;</span>) <span style="color:#66d9ef">continue</span>;
			g[nx][ny] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;#&#39;</span>;
			Q.emplace(nx, ny);
		}
	}
	<span style="color:#66d9ef">return</span> res;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">while</span> (cin <span style="color:#f92672">&gt;&gt;</span> m <span style="color:#f92672">&gt;&gt;</span> n , n <span style="color:#f92672">||</span> m) {
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
			cin <span style="color:#f92672">&gt;&gt;</span> g[i];
		<span style="color:#66d9ef">int</span> x, y;
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
			<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> m; j<span style="color:#f92672">++</span>)
				<span style="color:#66d9ef">if</span> (g[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;@&#39;</span>) {
					x <span style="color:#f92672">=</span> i;
					y <span style="color:#f92672">=</span> j;
				}

		cout <span style="color:#f92672">&lt;&lt;</span> bfs(x, y) <span style="color:#f92672">&lt;&lt;</span> endl;
	}	
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h5 id="dfs">DFS</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">25</span>;
<span style="color:#66d9ef">char</span> g[N][N];
<span style="color:#66d9ef">int</span> n, m;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dx[]{<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>}, dy[]{<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
    g[x][y] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;#&#39;</span>;
    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">int</span> nx <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> dx[i], ny <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> dy[i];
        <span style="color:#66d9ef">if</span> (nx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> nx <span style="color:#f92672">&gt;=</span> n <span style="color:#f92672">||</span> ny <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> ny <span style="color:#f92672">&gt;=</span> m <span style="color:#f92672">||</span> g[nx][ny] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;.&#39;</span>) <span style="color:#66d9ef">continue</span>;
        res <span style="color:#f92672">+=</span> dfs(nx, ny);
    }
    <span style="color:#66d9ef">return</span> res;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">while</span> (cin <span style="color:#f92672">&gt;&gt;</span> m <span style="color:#f92672">&gt;&gt;</span> n, n <span style="color:#f92672">||</span> m) {
        <span style="color:#66d9ef">int</span> x, y;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
            cin <span style="color:#f92672">&gt;&gt;</span> g[i];
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> m; j<span style="color:#f92672">++</span>)
             <span style="color:#66d9ef">if</span> (g[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;@&#39;</span>) {
                 x <span style="color:#f92672">=</span> i;
                 y <span style="color:#f92672">=</span> j;
             }
        }
        cout <span style="color:#f92672">&lt;&lt;</span> dfs(x, y) <span style="color:#f92672">&lt;&lt;</span> endl;
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="回文平方">回文平方</h3>
<p><a href="https://www.acwing.com/problem/content/1348/">题目链接</a></p>
<h4 id="代码-4">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">char</span> <span style="color:#a6e22e">get</span>(<span style="color:#66d9ef">int</span> n) { <span style="color:#66d9ef">return</span> n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">9</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;0&#39;</span> <span style="color:#f92672">+</span> n : <span style="color:#e6db74">&#39;A&#39;</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">+</span> n; }

string <span style="color:#a6e22e">base</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> b) {
    string s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
    <span style="color:#66d9ef">while</span> (n) {
        s <span style="color:#f92672">+=</span> get(n <span style="color:#f92672">%</span> b);
        n <span style="color:#f92672">/=</span> b;
    }
    reverse(s.begin(), s.end());
    <span style="color:#66d9ef">return</span> s;
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">check</span>(<span style="color:#66d9ef">const</span> string <span style="color:#f92672">&amp;</span>s) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, j <span style="color:#f92672">=</span> s.length() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> s.length(); i<span style="color:#f92672">++</span>, j<span style="color:#f92672">--</span>)
        <span style="color:#66d9ef">if</span> (s[i] <span style="color:#f92672">!=</span> s[j]) <span style="color:#66d9ef">return</span> false;
    <span style="color:#66d9ef">return</span> true;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> b;
    cin <span style="color:#f92672">&gt;&gt;</span> b;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">300</span>; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">auto</span> t <span style="color:#f92672">=</span> base(i <span style="color:#f92672">*</span> i, b);
        <span style="color:#66d9ef">if</span> (check(t)) {
            cout <span style="color:#f92672">&lt;&lt;</span> base(i, b) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> t <span style="color:#f92672">&lt;&lt;</span> endl;
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="剪绳子-浮点数二分">剪绳子-浮点数二分</h3>
<p><a href="https://www.acwing.com/problem/content/682/">题目链接</a></p>
<h4 id="思路-3">思路</h4>
<p>二分
最优化-&gt;判定问题</p>
<ul>
<li>情况1：可以[mid,  r]</li>
<li>情况2：不可以[l, mid)</li>
</ul>
<p>保留k位小数：r-l &lt; 1e-4</p>
<h4 id="代码-5">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">100005</span>;

<span style="color:#66d9ef">int</span> n, m;
<span style="color:#66d9ef">int</span> w[N];

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">check</span>(<span style="color:#66d9ef">double</span> mid) {
    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) cnt <span style="color:#f92672">+=</span> w[i] <span style="color:#f92672">/</span> mid;
    <span style="color:#66d9ef">return</span> cnt <span style="color:#f92672">&gt;=</span> m;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) cin <span style="color:#f92672">&gt;&gt;</span> w[i];
    <span style="color:#66d9ef">double</span> l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>, r <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e9</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">100</span>; i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// while (r-l &gt; 1e-4)
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">double</span> mid <span style="color:#f92672">=</span> (l <span style="color:#f92672">+</span> r) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">if</span> (check(mid))
            l <span style="color:#f92672">=</span> mid;
        <span style="color:#66d9ef">else</span>
            r <span style="color:#f92672">=</span> mid;
    }
    printf(<span style="color:#e6db74">&#34;%.2f</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, l);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="扩展题">扩展题</h4>
<p><a href="https://www.acwing.com/problem/content/792/">题目链接</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">double</span> n;

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">check</span>(<span style="color:#66d9ef">double</span> mid) {
    <span style="color:#66d9ef">return</span> mid<span style="color:#f92672">*</span>mid<span style="color:#f92672">*</span>mid <span style="color:#f92672">&lt;</span> n;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    <span style="color:#66d9ef">double</span> l <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">22.0</span>, r <span style="color:#f92672">=</span> <span style="color:#ae81ff">22.0</span>;
    <span style="color:#66d9ef">while</span> (r <span style="color:#f92672">-</span> l <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1e-8</span>) {
        <span style="color:#66d9ef">double</span> mid <span style="color:#f92672">=</span> (l<span style="color:#f92672">+</span>r) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">if</span> (check(mid)) l <span style="color:#f92672">=</span> mid;
        <span style="color:#66d9ef">else</span> r <span style="color:#f92672">=</span> mid;
    }
    printf(<span style="color:#e6db74">&#34;%.6f</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, l);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="分巧克力-整数二分">分巧克力-整数二分</h3>
<p><a href="https://www.acwing.com/problem/content/1229/">题目链接</a></p>
<h4 id="思路-4">思路</h4>
<p>$ \sum_{i=0}^{n-1} \lfloor \frac {h_i} {mid} \rfloor \times \lfloor \frac{w_i}{mid} \rfloor\ge k $</p>
<ul>
<li>成立：$[mid, r], l = mid$</li>
<li>不成立：$[l, mid-1], r = mid-1 $</li>
</ul>
<h4 id="代码-6">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">using</span> ll <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>;
<span style="color:#66d9ef">int</span> h[N], w[N];
<span style="color:#66d9ef">int</span> n, k;

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">check</span>(<span style="color:#66d9ef">int</span> mid) {
    ll s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
        s <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1LL</span> <span style="color:#f92672">*</span> (h[i]<span style="color:#f92672">/</span>mid) <span style="color:#f92672">*</span> (w[i]<span style="color:#f92672">/</span>mid);
        <span style="color:#66d9ef">if</span> (s <span style="color:#f92672">&gt;=</span> k) <span style="color:#66d9ef">return</span> true;
    }
    <span style="color:#66d9ef">return</span> false;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> k;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
        cin <span style="color:#f92672">&gt;&gt;</span> h[i] <span style="color:#f92672">&gt;&gt;</span> w[i];
    <span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, r <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span>;
    <span style="color:#66d9ef">while</span> (l <span style="color:#f92672">&lt;</span> r) {
        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (check(mid)) l <span style="color:#f92672">=</span> mid;
        <span style="color:#66d9ef">else</span> r <span style="color:#f92672">=</span> mid<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
    cout <span style="color:#f92672">&lt;&lt;</span> l <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="二分模板">二分模板</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bsearch_1</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r) {
    <span style="color:#66d9ef">while</span> (l <span style="color:#f92672">&lt;</span> r) {
        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (check(mid)) r <span style="color:#f92672">=</span> mid;
        <span style="color:#66d9ef">else</span> l <span style="color:#f92672">=</span> mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">return</span> l
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bsearch_2</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r) {
    <span style="color:#66d9ef">while</span> (l <span style="color:#f92672">&lt;</span> r) {
        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (check(mid)) l <span style="color:#f92672">=</span> mid;
        <span style="color:#66d9ef">else</span> r <span style="color:#f92672">=</span> mid<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
}
</code></pre></div><h4 id="扩展题-1">扩展题</h4>
<ul>
<li>
<p>数的范围</p>
<p><a href="https://www.acwing.com/problem/content/791/">题目链接</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> n, q;
<span style="color:#66d9ef">int</span> a[<span style="color:#ae81ff">100010</span>];

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> q;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
        cin <span style="color:#f92672">&gt;&gt;</span> a[i];
    <span style="color:#66d9ef">int</span> k;
    <span style="color:#66d9ef">while</span> (q<span style="color:#f92672">--</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> k;
        <span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> lower_bound(a, a<span style="color:#f92672">+</span>n, k)<span style="color:#f92672">-</span>a;
        <span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> upper_bound(a, a<span style="color:#f92672">+</span>n, k)<span style="color:#f92672">-</span>a;
        printf(<span style="color:#e6db74">&#34;%d &#34;</span>, a[l]<span style="color:#f92672">==</span>k<span style="color:#f92672">?</span> l : <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, a[r<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">==</span>k<span style="color:#f92672">?</span> r<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div></li>
<li>
<p>旋转数组的最小数字-不具有单调性，但具有二段性</p>
<p><a href="https://www.acwing.com/problem/content/description/20/">题目链接</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> findMin(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
        <span style="color:#66d9ef">if</span> (nums.empty()) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> nums.size();
        <span style="color:#66d9ef">while</span> (n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> nums[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> nums[n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) n<span style="color:#f92672">--</span>;
        <span style="color:#66d9ef">if</span> (nums[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;=</span> nums[n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#66d9ef">return</span> nums[<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, r <span style="color:#f92672">=</span> n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">while</span> (l <span style="color:#f92672">&lt;</span> r) {
            <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">if</span> (nums[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;</span> nums[mid]) r <span style="color:#f92672">=</span> mid;
            <span style="color:#66d9ef">else</span> l <span style="color:#f92672">=</span> mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
        }
        <span style="color:#66d9ef">return</span> nums[r];
    }
};
</code></pre></div></li>
</ul>
<h3 id="校门外的树-区间合并">校门外的树-区间合并</h3>
<p><a href="https://www.acwing.com/problem/content/424/">题目链接</a></p>
<h4 id="思路-5">思路</h4>
<p>先求出所有移动树木的操作的区间的并集，那么马路上剩余部分即为最终剩下树木的部分。</p>
<p>区间合并算法</p>
<ul>
<li>将所有区间按左端点从小到大排序</li>
<li>从左到右遍历每个区间[L, R]
<ul>
<li>$ l_i \le R $， $R = max(R, r_i) $</li>
<li>$ l_i &gt; R$, 则将[L, R] 存下来，L, R&lt;- $ l_i, r_i $</li>
</ul>
</li>
</ul>
<h4 id="代码-7">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">#define x first
</span><span style="color:#75715e">#define y second
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">105</span>;
pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> seg[N];

<span style="color:#66d9ef">int</span> l, m;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> l <span style="color:#f92672">&gt;&gt;</span> m;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>)
        cin <span style="color:#f92672">&gt;&gt;</span> seg[i].x <span style="color:#f92672">&gt;&gt;</span> seg[i].y;
    sort(seg, seg<span style="color:#f92672">+</span>m);
    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">int</span> L <span style="color:#f92672">=</span> seg[<span style="color:#ae81ff">0</span>].x, R <span style="color:#f92672">=</span> seg[<span style="color:#ae81ff">0</span>].y;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">if</span> (seg[i].x <span style="color:#f92672">&lt;=</span> R) R <span style="color:#f92672">=</span> max(R, seg[i].y);
        <span style="color:#66d9ef">else</span> {
            res <span style="color:#f92672">-=</span> R <span style="color:#f92672">-</span> L <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            L <span style="color:#f92672">=</span> seg[i].x;
            R <span style="color:#f92672">=</span> seg[i].y;
        }
    res <span style="color:#f92672">-=</span> R <span style="color:#f92672">-</span> L <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> res <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="扩展题-挤牛奶">扩展题-挤牛奶</h4>
<p><a href="https://www.acwing.com/problem/content/1343/">题目链接</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">#define x first
</span><span style="color:#75715e">#define y second
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">5005</span>;
pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> seg[N];
<span style="color:#66d9ef">int</span> n;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
        cin <span style="color:#f92672">&gt;&gt;</span> seg[i].x <span style="color:#f92672">&gt;&gt;</span> seg[i].y;
    sort(seg, seg<span style="color:#f92672">+</span>n);
    <span style="color:#66d9ef">int</span> L <span style="color:#f92672">=</span> seg[<span style="color:#ae81ff">0</span>].x, R <span style="color:#f92672">=</span> seg[<span style="color:#ae81ff">0</span>].y;
    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, b <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">if</span> (seg[i].x <span style="color:#f92672">&lt;=</span> R) R <span style="color:#f92672">=</span> max(R, seg[i].y);
        <span style="color:#66d9ef">else</span>  {
            b <span style="color:#f92672">=</span> max(b, seg[i].x<span style="color:#f92672">-</span>R);
            a <span style="color:#f92672">=</span> max(a, R<span style="color:#f92672">-</span>L);
            L <span style="color:#f92672">=</span> seg[i].x;
            R <span style="color:#f92672">=</span> seg[i].y;
        }
    a <span style="color:#f92672">=</span> max(a, R<span style="color:#f92672">-</span>L);
    cout <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> b <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="奖学金">奖学金</h3>
<p><a href="https://www.acwing.com/problem/content/431/">题目链接</a></p>
<h4 id="代码-8">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {
    <span style="color:#66d9ef">int</span> id;
    <span style="color:#66d9ef">int</span> grades[<span style="color:#ae81ff">3</span>];
    
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get_sum</span>() <span style="color:#66d9ef">const</span> {
        <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; i<span style="color:#f92672">++</span>)
            s <span style="color:#f92672">+=</span> grades[i];
        <span style="color:#66d9ef">return</span> s;
    }
    
    <span style="color:#66d9ef">friend</span> istream<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&gt;&gt;</span>(istream<span style="color:#f92672">&amp;</span> in, node <span style="color:#f92672">&amp;</span>a) {
        a.id <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>cnt;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; i<span style="color:#f92672">++</span>)
            in <span style="color:#f92672">&gt;&gt;</span> a.grades[i];
        <span style="color:#66d9ef">return</span> in;
    }
    
    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">const</span> node <span style="color:#f92672">&amp;</span>a, <span style="color:#66d9ef">const</span> node <span style="color:#f92672">&amp;</span>b) {
        <span style="color:#66d9ef">int</span> sa <span style="color:#f92672">=</span> a.get_sum(), sb <span style="color:#f92672">=</span> b.get_sum();
        <span style="color:#66d9ef">if</span> (sa <span style="color:#f92672">!=</span> sb) <span style="color:#66d9ef">return</span> sa <span style="color:#f92672">&lt;</span> sb;
        <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (a.grades[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> b.grades[<span style="color:#ae81ff">0</span>]) <span style="color:#66d9ef">return</span> a.grades[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> b.grades[<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> a.id <span style="color:#f92672">&gt;</span> b.id;
    }
};

<span style="color:#66d9ef">int</span> n;
priority_queue<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">&gt;</span> Q;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    node tmp;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> tmp;
        Q.push(tmp);
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">auto</span> t <span style="color:#f92672">=</span> Q.top();
        Q.pop();
        cout <span style="color:#f92672">&lt;&lt;</span> t.id <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> t.get_sum() <span style="color:#f92672">&lt;&lt;</span> endl;
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="week-3">Week 3</h2>
<h3 id="翻硬币-递推">翻硬币-递推</h3>
<p><a href="https://www.acwing.com/problem/content/1210/">题目链接</a></p>
<h4 id="思路-6">思路</h4>
<p>枚举递推：每一个操作是唯一确定的</p>
<h4 id="代码-9">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

string a, b;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">turn</span>(<span style="color:#66d9ef">int</span> i) { a[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;*&#39;</span> <span style="color:#f92672">?</span> a[i] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;o&#39;</span> <span style="color:#f92672">:</span> a[i] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;*&#39;</span>; }

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b;
    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> a.length()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">if</span> (a[i] <span style="color:#f92672">!=</span> b[i]) {
            turn(i);
            turn(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
            <span style="color:#f92672">++</span>res;
        }
    cout <span style="color:#f92672">&lt;&lt;</span> res <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="扩展题-费解的开关">扩展题-费解的开关</h4>
<ul>
<li><strong>思路</strong>
<ul>
<li>枚举第一行的点击方法，共32种，完成第一行的点击后，固定第一行，</li>
<li>从第一行开始递推，若达到第n行不全为0，说明这种点击方式不合法。</li>
<li>在所有合法的点击方式中取点击次数最少的就是答案。</li>
<li>对第一行的32次枚举涵盖了该问题的整个状态空间，因此该做法是正确的</li>
<li></li>
<li>时间复杂度：<code>32*20*5*500 = 一百六十万</code></li>
<li><code>对第一行操作有32种可能 * 对前四行有20种操作可能 * 每一次操作都要改变5个灯的状态 * 最多读入的时候可能有500次light矩阵</code></li>
<li>最关键的两个性质</li>
<li>每一个位置最多只会被点击一次</li>
<li>如果固定了第一行，那么满足题意的点击方案最多只有一种</li>
</ul>
</li>
<li><strong>代码</strong>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;climits&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">char</span> s[<span style="color:#ae81ff">5</span>][<span style="color:#ae81ff">5</span>];

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">turn</span>(<span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> j) {
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dx[]{<span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>}, dy[]{<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>; k<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">int</span> nx <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> dx[k], ny <span style="color:#f92672">=</span> j <span style="color:#f92672">+</span> dy[k];
        <span style="color:#66d9ef">if</span> (nx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> nx <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">||</span> ny <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> ny <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">5</span>) <span style="color:#66d9ef">continue</span>;
        s[nx][ny] <span style="color:#f92672">^=</span> <span style="color:#ae81ff">1</span>;
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">work</span>() {
    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> INT_MAX;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">5</span>; k<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">char</span> back[<span style="color:#ae81ff">5</span>][<span style="color:#ae81ff">5</span>];
        memcpy(back, s, <span style="color:#66d9ef">sizeof</span> s);
        <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>; j<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">if</span> ((k <span style="color:#f92672">&gt;&gt;</span> j) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) {
                turn(<span style="color:#ae81ff">0</span>, j);
                <span style="color:#f92672">++</span>cnt;
            }
        }
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>; j<span style="color:#f92672">++</span>)
                <span style="color:#66d9ef">if</span> (s[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span>) {
                    turn(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, j);
                    <span style="color:#f92672">++</span>cnt;
                }
        <span style="color:#66d9ef">bool</span> ok <span style="color:#f92672">=</span> true;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>; j<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span> (s[<span style="color:#ae81ff">4</span>][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span>) ok <span style="color:#f92672">=</span> false;
        <span style="color:#66d9ef">if</span> (ok) res <span style="color:#f92672">=</span> min(res, cnt);
        memcpy(s, back, <span style="color:#66d9ef">sizeof</span> back);
    }
    <span style="color:#66d9ef">return</span> res <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">6</span> <span style="color:#f92672">?</span> res : <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> n;
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    <span style="color:#66d9ef">while</span> (n<span style="color:#f92672">--</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>; i<span style="color:#f92672">++</span>)
            cin <span style="color:#f92672">&gt;&gt;</span> s[i];
        cout <span style="color:#f92672">&lt;&lt;</span> work() <span style="color:#f92672">&lt;&lt;</span> endl;
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div></li>
</ul>
<h3 id="找硬币">找硬币</h3>
<p><a href="https://www.acwing.com/problem/content/1534/">题目链接</a></p>
<h4 id="哈希表做法on">哈希表做法$O(n)$</h4>
<h5 id="思路-7">思路</h5>
<p>对于当前的元素t，查看之前集合中是否存在m-t，若存在则更新答案，否则添加到集合中。</p>
<h5 id="代码-10">代码</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;climits&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unordered_set&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> n, m;
unordered_set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> S;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
    <span style="color:#66d9ef">int</span> v1 <span style="color:#f92672">=</span> INT_MAX, v2;
    <span style="color:#66d9ef">int</span> a, b;
    <span style="color:#66d9ef">while</span> (n<span style="color:#f92672">--</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> a;
        b <span style="color:#f92672">=</span> m <span style="color:#f92672">-</span> a;
        <span style="color:#66d9ef">if</span> (S.count(b)) {
            <span style="color:#66d9ef">if</span> (a <span style="color:#f92672">&gt;</span> b) swap(a, b);
            <span style="color:#66d9ef">if</span> (v1 <span style="color:#f92672">&gt;</span> a) {
                v1 <span style="color:#f92672">=</span> a;
                v2 <span style="color:#f92672">=</span> b;
            }
        } <span style="color:#66d9ef">else</span> S.insert(a);
    }
    printf(v1 <span style="color:#f92672">==</span> INT_MAX <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;No Solution&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;%d %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, v1, v2);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="双指针做法onlogn">双指针做法$O(nlogn)$</h4>
<h5 id="思路-8">思路</h5>
<style type="text/css">.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative}</style>
<svg width="0" height="0" display="none" xmlns="http://www.w3.org/2000/svg"><symbol id="tip-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"/></symbol><symbol id="note-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="warning-notice" viewBox="0 0 576 512" preserveAspectRatio="xMidYMid meet"><path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="info-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/></symbol></svg><div class="notice note" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#note-notice"></use></svg></span>Note</p><p>双指针算法：如果<code>i++</code>和<code>j--</code>单调性相反就能用双指针做法。</p></div>

<p>$a[i]+a[j] \le m \ and \ j 最大$</p>
<h5 id="代码-11">代码</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> n, m;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>;
<span style="color:#66d9ef">int</span> a[N];
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
        cin <span style="color:#f92672">&gt;&gt;</span> a[i];
    sort(a, a<span style="color:#f92672">+</span>n);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, j <span style="color:#f92672">=</span> n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> j <span style="color:#f92672">&amp;&amp;</span> a[i] <span style="color:#f92672">+</span> a[j] <span style="color:#f92672">&gt;</span> m) j<span style="color:#f92672">--</span>;
        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> j <span style="color:#f92672">&amp;&amp;</span> a[i]<span style="color:#f92672">+</span>a[j] <span style="color:#f92672">==</span> m) {
            cout <span style="color:#f92672">&lt;&lt;</span> a[i] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> a[j] <span style="color:#f92672">&lt;&lt;</span> endl;
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
        }
    }
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;No Solution&#34;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="十三号星期五">十三号星期五</h3>
<p><a href="https://www.acwing.com/problem/content/1343/">题目链接</a></p>
<h4 id="思路-9">思路</h4>
<ul>
<li>枚举每个月第一天距离1900-1-1过了多少天days</li>
<li>星期：$(days+12)\  mod \ 7 $</li>
</ul>
<h4 id="代码-12">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> month[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">28</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">31</span>};
<span style="color:#66d9ef">int</span> n;
<span style="color:#66d9ef">int</span> weekdays[<span style="color:#ae81ff">7</span>];

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    <span style="color:#66d9ef">int</span> days <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> year <span style="color:#f92672">=</span> <span style="color:#ae81ff">1900</span>; year <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1900</span><span style="color:#f92672">+</span>n; year<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">12</span>; i<span style="color:#f92672">++</span>) {
            weekdays[(days <span style="color:#f92672">+</span> <span style="color:#ae81ff">12</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">7</span>]<span style="color:#f92672">++</span>;
            days <span style="color:#f92672">+=</span> month[i];
            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> (year <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> year <span style="color:#f92672">%</span> <span style="color:#ae81ff">100</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> year <span style="color:#f92672">%</span> <span style="color:#ae81ff">400</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)) days<span style="color:#f92672">++</span>; 
        }
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>, j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">7</span>; i <span style="color:#f92672">=</span> (i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">7</span>, j<span style="color:#f92672">++</span>)
        cout <span style="color:#f92672">&lt;&lt;</span> weekdays[i] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="平方矩阵-ii">平方矩阵 II</h3>
<p><a href="https://www.acwing.com/problem/content/756/">题目链接</a></p>
<h4 id="代码-13">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> n;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">while</span> (cin <span style="color:#f92672">&gt;&gt;</span> n, n) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>)
                cout <span style="color:#f92672">&lt;&lt;</span> abs(j<span style="color:#f92672">-</span>i) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span>;
            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
        }
        cout <span style="color:#f92672">&lt;&lt;</span> endl;
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="longest-increasing-subsequence">Longest-increasing-subsequence</h4>
<p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">题目链接</a></p>
<h5 id="思路-10">思路</h5>
<ul>
<li>dp[i]: 长度为i的LIS的最后一个元素的最小值</li>
<li>eg:[0,3,1,6,2,2,7] for each x:
<ul>
<li>0, dp = [0]</li>
<li>3, dp = [0, 3]</li>
<li>1, dp = [0, 1]</li>
<li>6, dp = [0, 1, 6]</li>
<li>2, dp = [0, 1, 2]</li>
<li>2, dp = [0, 1, 2]</li>
<li>7, dp = [0, 1, 2, 7]</li>
</ul>
</li>
<li>ans = len(dp)</li>
</ul>
<h5 id="代码-14">代码</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lengthOfLIS</span>(self, nums: List[int]) <span style="color:#f92672">-&gt;</span> int:
        dp <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> nums:
            i <span style="color:#f92672">=</span> bisect_left(dp, x)
            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> len(dp):
                dp<span style="color:#f92672">.</span>append(x)
            <span style="color:#66d9ef">else</span>:
                dp[i] <span style="color:#f92672">=</span> x
        <span style="color:#66d9ef">return</span> len(dp)
</code></pre></div><h3 id="棋盘挑战-八皇后问题">棋盘挑战-八皇后问题</h3>
<p><a href="https://www.acwing.com/problem/content/1434/">题目链接</a></p>
<h4 id="思路-11">思路</h4>
<ul>
<li>如何判断某些位置能不能填：对角线用截距编号
<ul>
<li>dg: y=x+b, b = y-x+n</li>
<li>udg: y=-x+b, b = y+x</li>
</ul>
</li>
</ul>
<h4 id="代码-15">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">15</span>;

<span style="color:#66d9ef">int</span> path[N], col[N], dg[<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>N], udg[<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>N];

<span style="color:#66d9ef">int</span> n, ans;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> x) {
    <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&gt;</span> n) {
        ans<span style="color:#f92672">++</span>;
        <span style="color:#66d9ef">if</span> (ans <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">3</span>) {
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
                cout <span style="color:#f92672">&lt;&lt;</span> path[i] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span>;
            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
        }
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; y <span style="color:#f92672">&lt;=</span> n; y<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>col[y] <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>dg[y<span style="color:#f92672">-</span>x<span style="color:#f92672">+</span>n] <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>udg[y<span style="color:#f92672">+</span>x]) {
            path[x] <span style="color:#f92672">=</span> y;
            col[y] <span style="color:#f92672">=</span> dg[y<span style="color:#f92672">-</span>x<span style="color:#f92672">+</span>n] <span style="color:#f92672">=</span> udg[y<span style="color:#f92672">+</span>x] <span style="color:#f92672">=</span> true;
            dfs(x<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
            col[y] <span style="color:#f92672">=</span> dg[y<span style="color:#f92672">-</span>x<span style="color:#f92672">+</span>n] <span style="color:#f92672">=</span> udg[y<span style="color:#f92672">+</span>x] <span style="color:#f92672">=</span> false;
            <span style="color:#75715e">// path[x] = 0;
</span><span style="color:#75715e"></span>        }
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    dfs(<span style="color:#ae81ff">1</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> ans;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="扩展题-解数独">扩展题-解数独</h4>
<p><a href="https://leetcode-cn.com/problems/sudoku-solver/">题目链接</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    vector<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> P;
    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">check</span>(<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;&amp;</span> board, <span style="color:#66d9ef">int</span> r, <span style="color:#66d9ef">int</span> c, <span style="color:#66d9ef">char</span> n) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">9</span>; i<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span> (board[r][i] <span style="color:#f92672">==</span> n <span style="color:#f92672">||</span> board[i][c] <span style="color:#f92672">==</span> n) <span style="color:#66d9ef">return</span> false;
        r <span style="color:#f92672">=</span> r <span style="color:#f92672">/</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>;
        c <span style="color:#f92672">=</span> c <span style="color:#f92672">/</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> r; i <span style="color:#f92672">&lt;</span> r <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>; i<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> c; j <span style="color:#f92672">&lt;</span> c <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>; j<span style="color:#f92672">++</span>)
                <span style="color:#66d9ef">if</span> (board[i][j] <span style="color:#f92672">==</span> n) <span style="color:#66d9ef">return</span> false;
        <span style="color:#66d9ef">return</span> true;
    }
    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">dfs</span>(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;&amp;</span> board, <span style="color:#66d9ef">int</span> idx) {
        <span style="color:#66d9ef">if</span> (idx <span style="color:#f92672">==</span> (<span style="color:#66d9ef">int</span>)P.size()) <span style="color:#66d9ef">return</span> true;
        <span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> P[idx].first, c <span style="color:#f92672">=</span> P[idx].second;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">9</span>; i<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span> (check(board, r, c, i<span style="color:#f92672">+</span><span style="color:#e6db74">&#39;0&#39;</span>)) {
                board[r][c] <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span><span style="color:#e6db74">&#39;0&#39;</span>;
                <span style="color:#66d9ef">if</span> (dfs(board, idx<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)) <span style="color:#66d9ef">return</span> true;
                board[r][c] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;.&#39;</span>;
            }
        <span style="color:#66d9ef">return</span> false;
    }
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solveSudoku</span>(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;&amp;</span> board) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">9</span>; i<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">9</span>; j<span style="color:#f92672">++</span>)
                <span style="color:#66d9ef">if</span> (board[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;.&#39;</span>)
                    P.emplace_back(i, j);
        dfs(board, <span style="color:#ae81ff">0</span>);
    }
};
</code></pre></div><h3 id="货币系统-完全背包">货币系统-完全背包</h3>
<p><a href="https://www.acwing.com/problem/content/description/1373/">题目链接</a></p>
<h4 id="思路-12">思路</h4>

    <img src="https://img-blog.csdnimg.cn/20210122225542349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYyOTI4NQ==,size_16,color_FFFFFF,t_70"  class="center"  style="zoom: 80% ;"  />


<h4 id="代码-16">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">using</span> ll <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>, M <span style="color:#f92672">=</span> <span style="color:#ae81ff">10005</span>;
ll f[N][M];
<span style="color:#66d9ef">int</span> n, m;
<span style="color:#66d9ef">int</span> w[N];
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
        cin <span style="color:#f92672">&gt;&gt;</span> w[i];
    f[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;=</span> m; j<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k <span style="color:#f92672">*</span> w[i] <span style="color:#f92672">&lt;=</span> j; k<span style="color:#f92672">++</span>)
                f[i][j] <span style="color:#f92672">+=</span> f[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span>k<span style="color:#f92672">*</span>w[i]];
    cout <span style="color:#f92672">&lt;&lt;</span> f[n][m] <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="时间优化">时间优化</h4>
<ol>
<li>$ f[i][j] = f[i-1][j]+f[i-1][j-w[i]]+f[i-1][j-2w[i]]+&hellip;+f[i-1][j-kw[i]] $</li>
<li>$ f[i][j-v] = f[i-1][j-w[i]]+f[i-1][j-2w[i]]+&hellip;+f[i-1][j-kw[i]] $</li>
<li>由1-2得：$ f[i][j] = f[i-1][j]+f[i][j-v] $</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">using</span> ll <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>, M <span style="color:#f92672">=</span> <span style="color:#ae81ff">10005</span>;
ll f[N][M];
<span style="color:#66d9ef">int</span> n, m;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
    f[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">int</span> v;
        cin <span style="color:#f92672">&gt;&gt;</span> v;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;=</span> m; j<span style="color:#f92672">++</span>) {
            f[i][j] <span style="color:#f92672">=</span> f[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j];
            <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">&gt;=</span> v) f[i][j] <span style="color:#f92672">+=</span> f[i][j<span style="color:#f92672">-</span>v];
        }
    }
    cout <span style="color:#f92672">&lt;&lt;</span> f[n][m] <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="空间优化">空间优化</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">using</span> ll <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>, M <span style="color:#f92672">=</span> <span style="color:#ae81ff">10005</span>;
ll f[M];
<span style="color:#66d9ef">int</span> n, m;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
    f[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">int</span> v;
        cin <span style="color:#f92672">&gt;&gt;</span> v;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> v; j <span style="color:#f92672">&lt;=</span> m; j<span style="color:#f92672">++</span>) {
            f[j] <span style="color:#f92672">+=</span> f[j<span style="color:#f92672">-</span>v];
            <span style="color:#75715e">// f[i][j] = f[i-1][j] + f[i][j-v]
</span><span style="color:#75715e"></span>        }
    }
    cout <span style="color:#f92672">&lt;&lt;</span> f[m] <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="阶乘">阶乘</h3>
<p><a href="https://www.acwing.com/problem/content/1383/">题目链接</a></p>
<h4 id="思路-13">思路</h4>
<ul>
<li>$ n! = 2^{\alpha}*5^{\beta}*x $</li>
<li>$ ans = \frac{n!}{10^k}\ mod\ 10=$</li>
</ul>
<p>我们进行观察，因为0只可能由2的倍数和5的倍数相乘得到，所以在进行乘法的过程中，我们将2和5的倍数给清理掉，这样就保证了不会出现0，然后我们控制其范围，每次相乘取其个位，因为个位肯定是非零元素，十位以后的数字完全没有必要保留下来，最后，我们将多处理的2或者5重新乘回去再取余即可</p>
<h4 id="代码-17">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> n;
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    <span style="color:#66d9ef">int</span> d2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, d5 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> i;
        <span style="color:#66d9ef">while</span> (x <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) x <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>, d2<span style="color:#f92672">++</span>;
        <span style="color:#66d9ef">while</span> (x <span style="color:#f92672">%</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) x <span style="color:#f92672">/=</span> <span style="color:#ae81ff">5</span>, d5<span style="color:#f92672">++</span>;
        ans <span style="color:#f92672">=</span> ans <span style="color:#f92672">*</span> x <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> d2<span style="color:#f92672">-</span>d5; i<span style="color:#f92672">++</span>)
        ans <span style="color:#f92672">=</span> ans <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> ans;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="week-4">Week 4</h2>
<h3 id="滑雪场设计-枚举">滑雪场设计-枚举</h3>
<h4 id="思路-14">思路</h4>
<ul>
<li>最优解中，所有的高度都在$[0, 100]$之间</li>
<li>只需枚举所有可能的区间</li>
</ul>
<h4 id="代码-18">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;climits&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1005</span>;
<span style="color:#66d9ef">int</span> a[N];

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> n;
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) cin <span style="color:#f92672">&gt;&gt;</span> a[i];
    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> INT_MAX;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; l <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">100</span><span style="color:#f92672">-</span><span style="color:#ae81ff">17</span>; l<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> l<span style="color:#f92672">+</span><span style="color:#ae81ff">17</span>, cost <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span> (a[i] <span style="color:#f92672">&lt;</span> l) cost <span style="color:#f92672">+=</span> (l<span style="color:#f92672">-</span>a[i])<span style="color:#f92672">*</span>(l<span style="color:#f92672">-</span>a[i]);
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (a[i] <span style="color:#f92672">&gt;</span> r) cost <span style="color:#f92672">+=</span> (a[i]<span style="color:#f92672">-</span>r)<span style="color:#f92672">*</span>(a[i]<span style="color:#f92672">-</span>r);
        ans <span style="color:#f92672">=</span> min(ans, cost);
    }
    cout <span style="color:#f92672">&lt;&lt;</span> ans;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="整数集合划分-贪心">整数集合划分-贪心</h3>
<p><a href="https://www.acwing.com/activity/content/problem/content/3449/1/">题目链接</a></p>
<h4 id="代码-19">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> a[<span style="color:#ae81ff">100005</span>], res;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
<span style="color:#75715e">#ifndef ONLINE_JUDGE
</span><span style="color:#75715e"></span>	freopen(<span style="color:#e6db74">&#34;input.txt&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>, stdin);
	freopen(<span style="color:#e6db74">&#34;output.txt&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>, stdout);
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> n;
	cin <span style="color:#f92672">&gt;&gt;</span> n;
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
		cin <span style="color:#f92672">&gt;&gt;</span> a[i];
	}
	sort(a, a <span style="color:#f92672">+</span> n);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
		<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&gt;=</span> n <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>) res <span style="color:#f92672">+=</span> a[i];
		<span style="color:#66d9ef">else</span> res <span style="color:#f92672">-=</span> a[i];
	}
	cout <span style="color:#f92672">&lt;&lt;</span> n <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">&lt;&lt;</span> res;
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="扩展题-双向搜索">扩展题-双向搜索</h4>
<p><a href="https://www.acwing.com/problem/content/description/173/">题目链接</a></p>
<ul>
<li>
<p>思路</p>
<ul>
<li>先搜索前<code>N/2</code>个物品可以凑出来的所有重量，存到数组中去</li>
<li>对所有重量排序，判重</li>
<li>在搜索后一半物品可以凑出来的所有重量<code>y</code>，在前一半物品搜索出来的重量二分出一个<code>y</code>，使得<code>x+y&lt;=w</code>, <code>x+y</code>最大</li>
</ul>
</li>
<li>
<p>优化</p>
<ul>
<li>从大到小枚举所有重量，使得搜索到的和更快达到目标</li>
<li>均衡两次搜索时间</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">using</span> ll <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">46</span>;
<span style="color:#66d9ef">int</span> n, w, g[N], k, cnt, wgt[<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#ae81ff">23</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>)];
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs_1</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> s) {
	<span style="color:#66d9ef">if</span> (x <span style="color:#f92672">==</span> k) {
		wgt[cnt<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> s;
		<span style="color:#66d9ef">return</span>;
	}
	<span style="color:#66d9ef">if</span> (s <span style="color:#f92672">*</span> <span style="color:#ae81ff">1ll</span> <span style="color:#f92672">+</span> g[x] <span style="color:#f92672">&lt;=</span> w) dfs_1(x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, s <span style="color:#f92672">+</span> g[x]);
	dfs_1(x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, s);
}
<span style="color:#66d9ef">int</span> ans;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs_2</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> s) {
	<span style="color:#66d9ef">if</span> (x <span style="color:#f92672">==</span> n) {
		<span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, r <span style="color:#f92672">=</span> cnt <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
		<span style="color:#66d9ef">while</span> (l <span style="color:#f92672">&lt;</span> r) {
			<span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
			<span style="color:#66d9ef">if</span> (s <span style="color:#f92672">*</span> <span style="color:#ae81ff">1ll</span> <span style="color:#f92672">+</span> wgt[mid] <span style="color:#f92672">&lt;=</span> w) l <span style="color:#f92672">=</span> mid;
			<span style="color:#66d9ef">else</span> r <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
		}
		<span style="color:#66d9ef">if</span> (s <span style="color:#f92672">*</span> <span style="color:#ae81ff">1ll</span> <span style="color:#f92672">+</span> wgt[l] <span style="color:#f92672">&lt;=</span> w) ans <span style="color:#f92672">=</span> max(ans, s <span style="color:#f92672">+</span> wgt[l]);
		<span style="color:#66d9ef">return</span>;
	}
	<span style="color:#66d9ef">if</span> (s <span style="color:#f92672">*</span> <span style="color:#ae81ff">1ll</span> <span style="color:#f92672">+</span> g[x] <span style="color:#f92672">&lt;=</span> w) dfs_2(x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, s <span style="color:#f92672">+</span> g[x]);
	dfs_2(x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, s);
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
<span style="color:#75715e">#ifndef ONLINE_JUDGE
</span><span style="color:#75715e"></span>	freopen(<span style="color:#e6db74">&#34;input.txt&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>, stdin);
	freopen(<span style="color:#e6db74">&#34;output.txt&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>, stdout);
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>	scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>w, <span style="color:#f92672">&amp;</span>n);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>g[i]);
	sort(g, g <span style="color:#f92672">+</span> n, greater<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>());
	k <span style="color:#f92672">=</span> n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>;
	dfs_1(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
	sort(wgt, wgt <span style="color:#f92672">+</span> cnt);
	cnt <span style="color:#f92672">=</span> unique(wgt, wgt <span style="color:#f92672">+</span> cnt) <span style="color:#f92672">-</span> wgt;
	dfs_2(k, <span style="color:#ae81ff">0</span>);
	cout <span style="color:#f92672">&lt;&lt;</span> ans;
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="合唱队形-lis">合唱队形-LIS</h3>
<p><a href="https://www.acwing.com/problem/content/description/484/">题目链接</a></p>
<h4 id="思路-15">思路</h4>
<ul>
<li><code>f[i]</code>: 从前往后，以<code>a[i]</code>结尾的最长上升子序列的长度</li>
<li><code>g[i]</code>: 从后往前，以<code>a[i]</code>结尾的最长上升子序列的长度</li>
<li>$ ans = n - max(f[i]+g[i]) + 1$</li>
</ul>
<h4 id="代码-20">代码</h4>
<p>$ n^2 $</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">105</span>;
<span style="color:#66d9ef">int</span> n, a[N];
<span style="color:#66d9ef">int</span> f[N], g[N];

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) cin <span style="color:#f92672">&gt;&gt;</span> a[i];
    
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        f[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> i; j<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span> (a[i] <span style="color:#f92672">&gt;</span> a[j]) f[i] <span style="color:#f92672">=</span> max(f[i], f[j]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
    }
    
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">--</span>) {
        g[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> n; j <span style="color:#f92672">&gt;</span> i; j<span style="color:#f92672">--</span>)
            <span style="color:#66d9ef">if</span> (a[i] <span style="color:#f92672">&gt;</span> a[j]) g[i] <span style="color:#f92672">=</span> max(g[i], g[j]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
    }
    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; k <span style="color:#f92672">&lt;=</span> n; k<span style="color:#f92672">++</span>) ans <span style="color:#f92672">=</span> max(ans, f[k] <span style="color:#f92672">+</span> g[k]);
    
    cout <span style="color:#f92672">&lt;&lt;</span> n <span style="color:#f92672">-</span> ans <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;

</code></pre></div><p>$ nlogn $</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">105</span>;
<span style="color:#66d9ef">int</span> f[N], g[N], a[N], n;
<span style="color:#66d9ef">int</span> len1[N], len2[N];
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) cin <span style="color:#f92672">&gt;&gt;</span> a[i];
    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> lower_bound(f, f<span style="color:#f92672">+</span>cnt, a[i])<span style="color:#f92672">-</span>f;
        <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">==</span> cnt) f[cnt<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> a[i];
        <span style="color:#66d9ef">else</span> f[it] <span style="color:#f92672">=</span> a[i];
        len1[i] <span style="color:#f92672">=</span> cnt;
    }
    cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {
        <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> lower_bound(g, g<span style="color:#f92672">+</span>cnt, a[i])<span style="color:#f92672">-</span>g;
        <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">==</span> cnt) g[cnt<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> a[i];
        <span style="color:#66d9ef">else</span> g[it] <span style="color:#f92672">=</span> a[i];
        len2[i] <span style="color:#f92672">=</span> cnt;
    }
    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) ans <span style="color:#f92672">=</span> max(ans, len1[i]<span style="color:#f92672">+</span>len2[i]);
    cout <span style="color:#f92672">&lt;&lt;</span> n <span style="color:#f92672">-</span> ans <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="火星人-排列">火星人-排列</h3>
<h4 id="思路-16">思路</h4>
<p>实现next_permutation()</p>
<h4 id="代码-21">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">10005</span>;
<span style="color:#66d9ef">int</span> n, m, a[N];

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) cin <span style="color:#f92672">&gt;&gt;</span> a[i];
    <span style="color:#66d9ef">while</span> (m<span style="color:#f92672">--</span>) {
        <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">while</span> (a[k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> a[k]) k<span style="color:#f92672">--</span>;
        k<span style="color:#f92672">--</span>;
        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> k;
        <span style="color:#66d9ef">while</span> (t <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> a[t<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> a[k]) t<span style="color:#f92672">++</span>;
        swap(a[t], a[k]);
        reverse(a<span style="color:#f92672">+</span>k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, a<span style="color:#f92672">+</span>n);
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) cout <span style="color:#f92672">&lt;&lt;</span> a[i] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="星空之夜-flood-fill">星空之夜-Flood-fill</h3>
<h4 id="思路-17">思路</h4>
<ul>
<li>判断形状是否相似
<ul>
<li>哈希：两两之间的距离之和</li>
</ul>
</li>
</ul>
<h4 id="代码-22">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">using</span> P <span style="color:#f92672">=</span> pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>;
<span style="color:#75715e">#define x first
</span><span style="color:#75715e">#define y second
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">105</span>;
P c[N<span style="color:#f92672">*</span>N];
<span style="color:#66d9ef">int</span> cnt;
<span style="color:#66d9ef">char</span> g[N][N];
<span style="color:#66d9ef">int</span> n, m;

<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">get_dist</span>(P a, P b) {
    <span style="color:#66d9ef">return</span> sqrt((a.x<span style="color:#f92672">-</span>b.x)<span style="color:#f92672">*</span>(a.x<span style="color:#f92672">-</span>b.x)<span style="color:#f92672">+</span>(a.y<span style="color:#f92672">-</span>b.y)<span style="color:#f92672">*</span>(a.y<span style="color:#f92672">-</span>b.y));
}

<span style="color:#66d9ef">double</span> <span style="color:#a6e22e">get_hash</span>() {
    <span style="color:#66d9ef">double</span> s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> cnt; i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> cnt; j<span style="color:#f92672">++</span>)
            s <span style="color:#f92672">+=</span> get_dist(c[i], c[j]);
    <span style="color:#66d9ef">return</span> s;
}

<span style="color:#66d9ef">char</span> <span style="color:#a6e22e">get_id</span>(<span style="color:#66d9ef">double</span> d) {
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">double</span> hash[<span style="color:#ae81ff">30</span>];
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> idx; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (fabs(hash[i] <span style="color:#f92672">-</span> d) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1e-8</span>)
            <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#f92672">+</span> i;
    }
    hash[idx<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> d;
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#f92672">+</span> idx <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> j) {
    g[i][j] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;0&#39;</span>;
    c[cnt<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> {i, j};
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; x <span style="color:#f92672">&lt;=</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; x<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; y <span style="color:#f92672">&lt;=</span> j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; y<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> x <span style="color:#f92672">&gt;=</span> n <span style="color:#f92672">||</span> y <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> y <span style="color:#f92672">&gt;=</span> m <span style="color:#f92672">||</span> g[x][y] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span>) <span style="color:#66d9ef">continue</span>;
            dfs(x, y);
        }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> m <span style="color:#f92672">&gt;&gt;</span> n;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) cin <span style="color:#f92672">&gt;&gt;</span> g[i];
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> m; j<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">if</span> (g[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span>) {
                cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
                dfs(i, j);
                <span style="color:#66d9ef">auto</span> d <span style="color:#f92672">=</span> get_hash();
                <span style="color:#66d9ef">auto</span> id <span style="color:#f92672">=</span> get_id(d);
                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k <span style="color:#f92672">&lt;</span> cnt; k<span style="color:#f92672">++</span>) g[c[k].x][c[k].y] <span style="color:#f92672">=</span> id;
            }
        }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) cout <span style="color:#f92672">&lt;&lt;</span> g[i] <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="摘花生-dp">摘花生-DP</h3>
<p><a href="https://www.acwing.com/problem/content/description/1017/">题目链接</a></p>
<h4 id="思路-18">思路</h4>
<ol>
<li>状态表示
<ul>
<li>集合：定义f[i][j]为从(1, 1)到达(i, j)的所有方案</li>
<li>属性：最大值</li>
</ul>
</li>
<li>状态转移
<ul>
<li>(i, j)从(i-1, j)即上方过来</li>
<li>(i, j)从(i, j-1)即左方过来</li>
</ul>
</li>
<li>空间压缩
<ul>
<li>f[i][j]只需要用到这一层和上一层的f元素，所以可以压缩成滚动数组。在此之上，还可以直接压缩成一维数组。</li>
</ul>
</li>
</ol>
<h4 id="代码-23">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">105</span>;
<span style="color:#66d9ef">int</span> f[N];
<span style="color:#66d9ef">int</span> n, m, t;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> T;
    cin <span style="color:#f92672">&gt;&gt;</span> T;
    <span style="color:#66d9ef">while</span> (T<span style="color:#f92672">--</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> m; j<span style="color:#f92672">++</span>) {
                cin <span style="color:#f92672">&gt;&gt;</span> t;
                f[j] <span style="color:#f92672">=</span> max(f[j], f[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">+</span> t;
            }
        cout <span style="color:#f92672">&lt;&lt;</span> f[m] <span style="color:#f92672">&lt;&lt;</span> endl;
        memset(f, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span> f);
    }
}
</code></pre></div><h3 id="最大的和-最大子矩形">最大的和-最大子矩形</h3>
<h4 id="思路-19">思路</h4>
<ul>
<li>前缀和数组<code>A[i][j]</code>表示 $ \sum_{i=1}^{n}{a[i][j]} $</li>
<li>枚举矩形上下边界</li>
<li>求最大连续子序列和</li>
</ul>
<h4 id="代码-24">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;climits&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">105</span>;
<span style="color:#66d9ef">int</span> a[N][N], n;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>) {
            cin <span style="color:#f92672">&gt;&gt;</span> a[i][j];
            a[i][j] <span style="color:#f92672">+=</span> a[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j];
        }
    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> INT_MIN;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; k <span style="color:#f92672">&lt;=</span> n; k<span style="color:#f92672">++</span>) {
                <span style="color:#75715e">// s = (s &lt; 0 ? a[j][k]-a[i-1][k] : a[j][k]-a[i-1][k] + s);
</span><span style="color:#75715e"></span>                s <span style="color:#f92672">=</span> max(s, <span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> a[j][k] <span style="color:#f92672">-</span> a[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][k];
                ans <span style="color:#f92672">=</span> max(ans, s);
            }
        }
    }
    cout <span style="color:#f92672">&lt;&lt;</span> ans;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="最大的和-线性dp">最大的和-线性DP</h3>
<p><a href="https://www.acwing.com/problem/content/1053/">题目链接</a></p>
<h4 id="代码-25">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;climits&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">50005</span>;
<span style="color:#66d9ef">int</span> n, a[N], f[N], g[N]; <span style="color:#75715e">// f[i]: 1~i最大连续子段和，g[i]:n~i最大连续子段和
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> T;
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>T);
    <span style="color:#66d9ef">while</span> (T<span style="color:#f92672">--</span>) {
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
        fill(f, f<span style="color:#f92672">+</span>n<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>, INT_MIN);
        fill(g, g<span style="color:#f92672">+</span>n<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>, INT_MIN);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>a[i]);
        <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
            s <span style="color:#f92672">=</span> max(s, <span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> a[i];
            f[i] <span style="color:#f92672">=</span> max(f[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], s);
        }
        s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">--</span>) {
            s <span style="color:#f92672">=</span> max(s, <span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> a[i];
            g[i] <span style="color:#f92672">=</span> max(g[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], s);
        }
        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> INT_MIN;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
            ans <span style="color:#f92672">=</span> max(ans, f[i] <span style="color:#f92672">+</span> g[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]);
        cout <span style="color:#f92672">&lt;&lt;</span> ans <span style="color:#f92672">&lt;&lt;</span> endl;
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="最大异或对-trie">最大异或对-trie</h3>
<p><a href="https://www.acwing.com/problem/content/submission/145/">题目链接</a></p>
<h4 id="代码-26">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>, M <span style="color:#f92672">=</span> <span style="color:#ae81ff">3e6</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>;
<span style="color:#66d9ef">int</span> a[N], son[M][<span style="color:#ae81ff">2</span>], idx, n;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> x) {
    <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>; <span style="color:#f92672">~</span>i; i<span style="color:#f92672">--</span>) {
        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> x <span style="color:#f92672">&gt;&gt;</span> i <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>son[p][t]) son[p][t] <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>idx;
        p <span style="color:#f92672">=</span> son[p][t];
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">int</span> x) {
    <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>; <span style="color:#f92672">~</span>i; i<span style="color:#f92672">--</span>) {
        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> x <span style="color:#f92672">&gt;&gt;</span> i <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (son[p][<span style="color:#f92672">!</span>t]) {
            res <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> i;
            p <span style="color:#f92672">=</span> son[p][<span style="color:#f92672">!</span>t];
        } <span style="color:#66d9ef">else</span> {
            p <span style="color:#f92672">=</span> son[p][t];
        }
    }
    <span style="color:#66d9ef">return</span> res;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> a[i];
        insert(a[i]);
        ans <span style="color:#f92672">=</span> max(ans, query(a[i]));
    }
    cout <span style="color:#f92672">&lt;&lt;</span> ans;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="牛亦或-trie前缀和">牛亦或-trie+前缀和</h4>
<p><a href="https://www.acwing.com/problem/content/description/1416/">题目链接</a></p>
<h4 id="代码-27">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>, M <span style="color:#f92672">=</span> <span style="color:#ae81ff">2e6</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>;
<span style="color:#66d9ef">int</span> son[M][<span style="color:#ae81ff">2</span>], a[N], id[M], idx, n;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> k) {
    <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>; <span style="color:#f92672">~</span>i; i<span style="color:#f92672">--</span>) {
        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> x <span style="color:#f92672">&gt;&gt;</span> i <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>son[p][t]) son[p][t] <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>idx;
        p <span style="color:#f92672">=</span> son[p][t];
    }
    id[p] <span style="color:#f92672">=</span> k;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">int</span> x) {
    <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>; <span style="color:#f92672">~</span>i; i<span style="color:#f92672">--</span>) {
        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> x <span style="color:#f92672">&gt;&gt;</span> i <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (son[p][<span style="color:#f92672">!</span>t]) {
            p <span style="color:#f92672">=</span> son[p][<span style="color:#f92672">!</span>t];
        } <span style="color:#66d9ef">else</span> {
            p <span style="color:#f92672">=</span> son[p][t];
        }
    }
    <span style="color:#66d9ef">return</span> id[p];
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> a[i];
        a[i] <span style="color:#f92672">^=</span> a[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
    }
    insert(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, l, r;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> query(a[i]);
        <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> a[i] <span style="color:#f92672">^</span> a[k];
        <span style="color:#66d9ef">if</span> (s <span style="color:#f92672">&gt;</span> ans) {
            ans <span style="color:#f92672">=</span> s;
            l <span style="color:#f92672">=</span> k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r <span style="color:#f92672">=</span> i;
        }
        insert(a[i], i);
    }
    cout <span style="color:#f92672">&lt;&lt;</span> ans <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> l <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">&lt;&lt;</span> r <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="week-5">Week 5</h2>
<h3 id="开心的金明-01背包">开心的金明-01背包</h3>
<p><a href="https://www.acwing.com/problem/content/428/">题目链接</a></p>
<h4 id="代码-28">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> f[<span style="color:#ae81ff">30005</span>];
<span style="color:#66d9ef">int</span> n, m;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
    <span style="color:#66d9ef">int</span> v, w;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> v <span style="color:#f92672">&gt;&gt;</span> w;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> n; j <span style="color:#f92672">&gt;=</span> v; j<span style="color:#f92672">--</span>)
            f[j] <span style="color:#f92672">=</span> max(f[j], f[j<span style="color:#f92672">-</span>v]<span style="color:#f92672">+</span>w<span style="color:#f92672">*</span>v);
    }
    cout <span style="color:#f92672">&lt;&lt;</span> f[n] <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="k倍区间-前缀和">K倍区间-前缀和</h3>
<p><a href="https://www.acwing.com/problem/content/1232/">题目链接</a></p>
<h4 id="思路-20">思路</h4>
<p>求区间和，可以通过前缀和来求出。<code>sum[r]−sum[l−1]</code>就是区间<code>[l,r]</code>的和。如果区间<code>[l,r]</code>的和是k的倍数则有<code>(sum[r]−sum[l−1])</code>，即<code>sum[r]</code>。因此，我们可以得到一个结论，对前缀和取模之后，两个相等的前缀和就能组成一个k倍区间。</p>
<p>有了这个结论之后，我们就可以使用两层for循环来计数k倍区间的个数，但是由于数据比较大，我们不能这样做。那么我们能不能在计算前缀和的过程中同时来统计k倍区间的个数呢？当然可以。我们可以用一个数组cnt，规定<code>cnt[i]</code>表示当前位置之前，前缀和取模后等于i的个数，以后每出现一次前缀和（取模后）和它相等，那么k倍区间就加上<code>cnt[sum[i]]</code>，然后<code>cnt[sum[i]]++</code>。这样似乎不容易理解，我们用样例举个例子。</p>
<p>对于数列 1 2 3 4 5，k = 2</p>
<p>对前1个数的和模k后为1，在此之前有0个前缀和取模后为1，总个数+0</p>
<p>对前2个数的和模k后为1，在此之前有1个前缀和取模后为1，总个数+1</p>
<p>对前3个数的和模k后为0，在此之前有0个前缀和取模后为0, 总个数+0</p>
<p>对前4个数的和模k后为0，在此之前有1个前缀和取模后为0，总个数+1</p>
<p>对前5个数的和模k后为1，在此之前有2个前缀和取模后为1，总个数+2</p>
<p>但是我们还忽略了一点，就是我们这样做我们少计算了区间·<code>[0,i]</code>构成的k倍区间，其个数为<code>cnt[0]</code>。</p>
<h4 id="代码-29">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>;
<span style="color:#66d9ef">int</span> a[N], n, k, cnt[N];

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> k;
    <span style="color:#66d9ef">long</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> a[i];
        a[i] <span style="color:#f92672">=</span> (a[i] <span style="color:#f92672">+</span> a[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">%</span> k;
        ans <span style="color:#f92672">+=</span> cnt[a[i]];
        cnt[a[i]]<span style="color:#f92672">++</span>;
    }
    cout <span style="color:#f92672">&lt;&lt;</span> ans <span style="color:#f92672">+</span> cnt[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="数独检查-模拟">数独检查-模拟</h3>
<p><a href="https://www.acwing.com/problem/content/description/705/">题目链接</a></p>
<h4 id="代码-30">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>;
<span style="color:#66d9ef">int</span> n, m;
<span style="color:#66d9ef">int</span> g[N<span style="color:#f92672">*</span>N][N<span style="color:#f92672">*</span>N];
<span style="color:#66d9ef">bool</span> st[N<span style="color:#f92672">*</span>N];

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">check_row</span>() {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>) {
        memset(st, false, <span style="color:#66d9ef">sizeof</span> st);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> m; j<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> g[i][j];
            <span style="color:#66d9ef">if</span> (t <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> t <span style="color:#f92672">&gt;</span> m) <span style="color:#66d9ef">return</span> false;
            <span style="color:#66d9ef">if</span> (st[t]) <span style="color:#66d9ef">return</span> false;
            st[t] <span style="color:#f92672">=</span> true;
        }
    }
    <span style="color:#66d9ef">return</span> true;
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">check_col</span>() {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>) {
        memset(st, false, <span style="color:#66d9ef">sizeof</span> st);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> m; j<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> g[j][i];
            <span style="color:#66d9ef">if</span> (t <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> t <span style="color:#f92672">&gt;</span> m) <span style="color:#66d9ef">return</span> false;
            <span style="color:#66d9ef">if</span> (st[t]) <span style="color:#66d9ef">return</span> false;
            st[t] <span style="color:#f92672">=</span> true;
        }
    }
    <span style="color:#66d9ef">return</span> true;
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">check_cell</span>() {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i <span style="color:#f92672">+=</span> n)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> m; j <span style="color:#f92672">+=</span> n) {
            memset(st, false, <span style="color:#66d9ef">sizeof</span> st);
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> dx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; dx <span style="color:#f92672">&lt;</span> n; dx<span style="color:#f92672">++</span>)
                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> dy <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; dy <span style="color:#f92672">&lt;</span> n; dy<span style="color:#f92672">++</span>) {
                    <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> g[i<span style="color:#f92672">+</span>dx][j<span style="color:#f92672">+</span>dy];
                    <span style="color:#66d9ef">if</span> (t <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> t <span style="color:#f92672">&gt;</span> m) <span style="color:#66d9ef">return</span> false;
                    <span style="color:#66d9ef">if</span> (st[t]) <span style="color:#66d9ef">return</span> false;
                    st[t] <span style="color:#f92672">=</span> true;
                }
        }
    <span style="color:#66d9ef">return</span> true;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> T;
    cin <span style="color:#f92672">&gt;&gt;</span> T;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; t <span style="color:#f92672">&lt;=</span> T; t<span style="color:#f92672">++</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> n;
        m <span style="color:#f92672">=</span> n <span style="color:#f92672">*</span> n;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> m; j<span style="color:#f92672">++</span>) cin <span style="color:#f92672">&gt;&gt;</span> g[i][j];
        
        printf(check_row() <span style="color:#f92672">&amp;&amp;</span> check_col() <span style="color:#f92672">&amp;&amp;</span> check_cell() <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Case #%d: Yes</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Case #%d: No</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, t);
    }
    
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="最长公共子序列-lcs">最长公共子序列-LCS</h3>
<p><a href="https://www.acwing.com/problem/content/899/">题目链接</a></p>
<h4 id="思路-21">思路</h4>

    <img src="https://i.postimg.cc/y8BJBtnM/2.jpg"  class="center"  style="zoom: 50% ;"  />


<h4 id="代码-31">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1005</span>;
<span style="color:#66d9ef">int</span> n, m, f[N][N];
<span style="color:#66d9ef">char</span> a[N], b[N];

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;&gt;</span> b <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> m; j<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span> (a[i] <span style="color:#f92672">==</span> b[j]) f[i][j] <span style="color:#f92672">=</span> f[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">else</span> f[i][j] <span style="color:#f92672">=</span> max(f[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j], f[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);
    cout <span style="color:#f92672">&lt;&lt;</span> f[n][m];
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="数独简单版-数独">数独简单版-数独</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">char</span> g[<span style="color:#ae81ff">10</span>][<span style="color:#ae81ff">10</span>];
<span style="color:#66d9ef">bool</span> row[<span style="color:#ae81ff">10</span>][<span style="color:#ae81ff">10</span>], col[<span style="color:#ae81ff">10</span>][<span style="color:#ae81ff">10</span>], cell[<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">10</span>];

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
    <span style="color:#66d9ef">if</span> (y <span style="color:#f92672">==</span> <span style="color:#ae81ff">9</span>) {
        x<span style="color:#f92672">++</span>, y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    }
    <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">==</span> <span style="color:#ae81ff">9</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">9</span>; i<span style="color:#f92672">++</span>) cout <span style="color:#f92672">&lt;&lt;</span> g[i] <span style="color:#f92672">&lt;&lt;</span> endl;
        <span style="color:#66d9ef">return</span> true;
    }
    <span style="color:#66d9ef">if</span> (g[x][y] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;.&#39;</span>) <span style="color:#66d9ef">return</span> dfs(x, y<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">9</span>; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>row[x][i] <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>col[y][i] <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>cell[x<span style="color:#f92672">/</span><span style="color:#ae81ff">3</span>][y<span style="color:#f92672">/</span><span style="color:#ae81ff">3</span>][i]) {
            g[x][y] <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;0&#39;</span>;
            row[x][i] <span style="color:#f92672">=</span> col[y][i] <span style="color:#f92672">=</span> cell[x<span style="color:#f92672">/</span><span style="color:#ae81ff">3</span>][y<span style="color:#f92672">/</span><span style="color:#ae81ff">3</span>][i] <span style="color:#f92672">=</span> true;
            <span style="color:#66d9ef">if</span> (dfs(x, y<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)) <span style="color:#66d9ef">return</span> true;
            row[x][i] <span style="color:#f92672">=</span> col[y][i] <span style="color:#f92672">=</span> cell[x<span style="color:#f92672">/</span><span style="color:#ae81ff">3</span>][y<span style="color:#f92672">/</span><span style="color:#ae81ff">3</span>][i] <span style="color:#f92672">=</span> false;
            g[x][y] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;.&#39;</span>;
        }
    }
    <span style="color:#66d9ef">return</span> false;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">9</span>; i<span style="color:#f92672">++</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> g[i];
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">9</span>; j<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span> (g[i][j] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;.&#39;</span>) {
                <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> g[i][j] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>;
                row[i][t] <span style="color:#f92672">=</span> col[j][t] <span style="color:#f92672">=</span> cell[i<span style="color:#f92672">/</span><span style="color:#ae81ff">3</span>][j<span style="color:#f92672">/</span><span style="color:#ae81ff">3</span>][t] <span style="color:#f92672">=</span> true;
            }
    }
    dfs(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
}
</code></pre></div><h3 id="献给阿尔吉侬的花束-bfs">献给阿尔吉侬的花束-BFS</h3>
<p><a href="https://www.acwing.com/problem/content/description/1103/">题目链接</a></p>
<h4 id="代码-32">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">205</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dx[]{<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>}, dy[]{<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};

<span style="color:#66d9ef">char</span> g[N][N];
<span style="color:#66d9ef">int</span> dist[N][N];
<span style="color:#66d9ef">int</span> r, c;

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">bfs</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
    memset(dist, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span> dist);
    queue<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> Q;
    Q.push({x, y});
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>Q.empty()) {
        <span style="color:#66d9ef">auto</span> [tx, ty] <span style="color:#f92672">=</span> Q.front();
        Q.pop();
        <span style="color:#66d9ef">if</span> (g[tx][ty] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;E&#39;</span>) {
            cout <span style="color:#f92672">&lt;&lt;</span> dist[tx][ty] <span style="color:#f92672">&lt;&lt;</span> endl;
            <span style="color:#66d9ef">return</span> true;
        }
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">int</span> nx <span style="color:#f92672">=</span> tx <span style="color:#f92672">+</span> dx[i], ny <span style="color:#f92672">=</span> ty <span style="color:#f92672">+</span> dy[i];
            <span style="color:#66d9ef">if</span> (nx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> nx <span style="color:#f92672">&gt;=</span> r <span style="color:#f92672">||</span> ny <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> ny <span style="color:#f92672">&gt;=</span> c <span style="color:#f92672">||</span>  g[nx][ny] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;#&#39;</span>) <span style="color:#66d9ef">continue</span>;
            Q.push({nx, ny});
            <span style="color:#66d9ef">if</span> (g[nx][ny] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;E&#39;</span>)
                g[nx][ny] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;#&#39;</span>;
            dist[nx][ny] <span style="color:#f92672">=</span> dist[tx][ty] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        }
    }
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;oop!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> false;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> T;
    cin <span style="color:#f92672">&gt;&gt;</span> T;
    <span style="color:#66d9ef">while</span> (T<span style="color:#f92672">--</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> r <span style="color:#f92672">&gt;&gt;</span> c;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> r; i<span style="color:#f92672">++</span>) cin <span style="color:#f92672">&gt;&gt;</span> g[i];
        <span style="color:#66d9ef">bool</span> is_break <span style="color:#f92672">=</span> false;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> r; i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> c; j<span style="color:#f92672">++</span>)
                <span style="color:#66d9ef">if</span> (g[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;S&#39;</span>) {
                    bfs(i, j);
                    is_break <span style="color:#f92672">=</span> true;
                    <span style="color:#66d9ef">break</span>;
                }
            <span style="color:#66d9ef">if</span> (is_break) <span style="color:#66d9ef">break</span>;
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>SQL</title>
            <link>https://fffzlfk.gitlab.io/posts/sql/</link>
            <pubDate>Sat, 24 Oct 2020 20:22:42 +0800</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/posts/sql/</guid>
            <description>SQL概述 SQL的特点  综合统一：集DQ、DDL、DML、DCL于一体 高度非过程化：不用考虑如何实现，只需提出“做什么”，不关心“怎么做” 面向集合的操作方式：查询、插入、删除、更新操作对象及结果都是集合 以同一种语法结构提供两种使用方法：可交互式和嵌入式使用 以简捷的自然语言实现对数据库的定义、操作和控制功能：定义了少量的关键字实现对数据库的定义、操纵和控制功能  SQL所使用的动词（核心功能）    SQL功能 动词     数据查询 SELECT   数据定义 CREATE, DROP, ALTER   数据操作 INSERT, UPDATE, DELETE   数据控制 GRANT, REVOKE    数据定义 SQL的数据定义语句 SQL中的数据类型 基本表的定义 创建基本表 CREATE TABLE &amp;lt;表名&amp;gt; ( &amp;lt;列名&amp;gt; &amp;lt;数据类型&amp;gt;[&amp;lt;列级完整性约束条件&amp;gt;] [, &amp;lt;列名&amp;gt; &amp;lt;数据类型&amp;gt;[&amp;lt;列级完整性约束条件&amp;gt;] ] … [, &amp;lt;表级完整性约束条件&amp;gt; ] ) ;  常用的完整性约束  主码约束：PRIMARY KEY (&amp;lt;列名1&amp;gt;, &amp;lt;列名2&amp;gt;,…) 非空值约束：NOT NULL 唯一性约束：UNIQUE 参照完整性约束：FOREIGN KEY (&amp;lt;列名&amp;gt;) REFERENCES &amp;lt;表名&amp;gt;(&amp;lt;列名&amp;gt;) 一般性约束：CHECK(&amp;lt;谓词&amp;gt;)    删除基本表 DROP TABLE &amp;lt;表名&amp;gt; [RESTRICT|CASCADE];   RESTRICT：删除表是有限制的：</description>
            <content type="html"><![CDATA[<h2 id="sql概述">SQL概述</h2>
<h3 id="sql的特点">SQL的特点</h3>
<ol>
<li><strong>综合统一</strong>：集DQ、DDL、DML、DCL于一体</li>
<li><strong>高度非过程化</strong>：不用考虑如何实现，只需提出“做什么”，不关心“怎么做”</li>
<li><strong>面向集合的操作方式</strong>：查询、插入、删除、更新操作对象及结果都是集合</li>
<li><strong>以同一种语法结构提供两种使用方法</strong>：可交互式和嵌入式使用</li>
<li><strong>以简捷的自然语言实现对数据库的定义、操作和控制功能</strong>：定义了少量的关键字实现对数据库的定义、操纵和控制功能</li>
</ol>
<h3 id="sql所使用的动词核心功能">SQL所使用的动词（核心功能）</h3>
<table>
<thead>
<tr>
<th>SQL功能</th>
<th>动词</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据查询</td>
<td>SELECT</td>
</tr>
<tr>
<td>数据定义</td>
<td>CREATE, DROP, ALTER</td>
</tr>
<tr>
<td>数据操作</td>
<td>INSERT, UPDATE, DELETE</td>
</tr>
<tr>
<td>数据控制</td>
<td>GRANT, REVOKE</td>
</tr>
</tbody>
</table>
<h2 id="数据定义">数据定义</h2>
<h3 id="sql的数据定义语句">SQL的数据定义语句</h3>

    <img src="https://i.postimg.cc/3JJJHQR6/1.png"  class="center"  style="border-radius: 8px; width: 75% ;"  />


<h3 id="sql中的数据类型">SQL中的数据类型</h3>

    <img src="https://i.postimg.cc/BbdCGB3Q/2.png"  class="center"  style="border-radius: 8px; width: 75% ;"  />


<h3 id="基本表的定义">基本表的定义</h3>
<h4 id="创建基本表">创建基本表</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">表名</span><span style="color:#f92672">&gt;</span>
    	　  ( <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">列名</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">数据类型</span><span style="color:#f92672">&gt;</span>[<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">列级完整性约束条件</span><span style="color:#f92672">&gt;</span>]
      　　[, <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">列名</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">数据类型</span><span style="color:#f92672">&gt;</span>[<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">列级完整性约束条件</span><span style="color:#f92672">&gt;</span>] ] <span style="color:#960050;background-color:#1e0010">…</span>
      　　[, <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">表级完整性约束条件</span><span style="color:#f92672">&gt;</span> ]  ) ;
</code></pre></div><ul>
<li>常用的完整性约束
<ul>
<li>主码约束：<strong>PRIMARY  KEY (&lt;列名1&gt;, &lt;列名2&gt;,…)</strong></li>
<li>非空值约束：<strong>NOT NULL</strong></li>
<li>唯一性约束：<strong>UNIQUE</strong></li>
<li>参照完整性约束：<strong>FOREIGN KEY (&lt;列名&gt;) REFERENCES  &lt;表名&gt;(&lt;列名&gt;)</strong></li>
<li>一般性约束：<strong>CHECK(&lt;谓词&gt;)</strong></li>
</ul>
</li>
</ul>

    <img src="https://i.postimg.cc/k5M65Y7Y/3.png"  class="left"  style="border-radius: 8px; width: 75% ;"  />


<h4 id="删除基本表">删除基本表</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DROP</span>  <span style="color:#66d9ef">TABLE</span>  <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">表名</span><span style="color:#f92672">&gt;</span> [<span style="color:#66d9ef">RESTRICT</span><span style="color:#f92672">|</span><span style="color:#66d9ef">CASCADE</span>]; 
</code></pre></div><ul>
<li>
<p><strong>RESTRICT</strong>：删除表是有限制的：</p>
<ul>
<li>欲删除的基本表不能被其他表的约束所引用</li>
<li>如果存在依赖该表的对象，则此表不能被删除</li>
</ul>
</li>
<li>
<p><strong>CASCADE</strong>：级联，删除该表没有限制。
在删除基本表的同时，相关的依赖对象一起删除</p>
<p>⚠️<strong>缺省是RESTRICT</strong></p>
</li>
</ul>
<h4 id="修改基本表">修改基本表</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">ALTER</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">表名</span><span style="color:#f92672">&gt;</span>
	[<span style="color:#66d9ef">ADD</span>[<span style="color:#66d9ef">COLUMN</span>] <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">新列名</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">数据类型</span><span style="color:#f92672">&gt;</span> [ <span style="color:#960050;background-color:#1e0010">完整性约束</span> ]]
	[<span style="color:#66d9ef">ADD</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">表级完整性约束</span><span style="color:#f92672">&gt;</span>]
	[<span style="color:#66d9ef">DROP</span> [ <span style="color:#66d9ef">COLUMN</span> ] <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">列名</span><span style="color:#f92672">&gt;</span> [<span style="color:#66d9ef">CASCADE</span><span style="color:#f92672">|</span><span style="color:#66d9ef">RESTRICT</span>]]
    [<span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">CONSTRAINT</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">完整性约束名</span><span style="color:#f92672">&gt;</span>[<span style="color:#66d9ef">RESTRICT</span><span style="color:#f92672">|</span><span style="color:#66d9ef">CASCADE</span>]]
	[<span style="color:#66d9ef">ALTER</span> <span style="color:#66d9ef">COLUMN</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">列名</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">数据类型</span><span style="color:#f92672">&gt;</span>];
</code></pre></div><ul>
<li>&lt;表名&gt;：要修改的基本表</li>
<li><strong>ADD子句</strong>：增加新列和新的完整性约束条件</li>
<li><strong>DROP COLUMN子句</strong>: 用于删除表中的列</li>
<li><strong>DROP CONSTRAINT</strong>子句：删除指定的完整性约束条件</li>
<li><strong>ALTER COLUMN</strong>子句：用于修改列名和数据类型</li>
</ul>
<p>⚠️删除属性列</p>
<ul>
<li>间接删除(由DBA或表的Owner操作)
<ol>
<li>把表中要保留的列及其内容复制到一个新表中</li>
<li>删除原表</li>
<li>再将新表重命名为原表名</li>
</ol>
</li>
<li>直接删除(SQL-99)<br>
　例：ALTER  TABLE  S  Drop  Scome ;</li>
</ul>
<h3 id="索引的定义">索引的定义</h3>
<h4 id="索引的分类">索引的分类</h4>
<ol>
<li><strong>普通索引(Normal Index)</strong>：一个索引值可能对应多条存储记录</li>
<li><strong>单一索引(Unique Index)</strong>：每一个索引值只对应唯一的数据记录。</li>
<li><strong>聚簇索引(Cluster Index)</strong>：基本表按照索引项顺序组织存储。
<ul>
<li>一个基本表上最多只能建立一个聚簇索引</li>
<li>在最经常查询的列上建立聚簇索引</li>
<li>经常更新的列不宜建立聚簇索引</li>
</ul>
</li>
</ol>
<h4 id="创建索引">创建索引</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">CREATE</span> [<span style="color:#66d9ef">UNIQUE</span>] <span style="color:#f92672">|</span> [<span style="color:#66d9ef">CLUSTER</span>] <span style="color:#66d9ef">INDEX</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">索引名</span><span style="color:#f92672">&gt;</span>
 	　<span style="color:#66d9ef">ON</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">表名</span><span style="color:#f92672">&gt;</span>(<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">列名</span><span style="color:#f92672">&gt;</span>[<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">次序</span><span style="color:#f92672">&gt;</span>][,<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">列名</span><span style="color:#f92672">&gt;</span>[<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">次序</span><span style="color:#f92672">&gt;</span>] ]<span style="color:#960050;background-color:#1e0010">…</span>);
</code></pre></div><ul>
<li>用&lt;表名&gt;指定要建索引的基本表名字</li>
<li>索引可以建立在该表的一列或多列上，各列名之间用逗号分隔</li>
<li>用&lt;次序&gt;指定索引值的排列次序。升序：ASC，降序：DESC，缺省值：ASC</li>
<li>UNIQUE表明此索引的每一个索引值对应唯一的数据记录</li>
<li>CLUSTER表示要建立的索引是聚簇索引</li>
</ul>
<p>例7: 为学生表S和选课表SC建立索引。其中S表按学号升序建唯一索引，按年龄降序建立普通索引，SC表按学号升序和课程号降序建唯一索引。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">	<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">UNIQUE</span> <span style="color:#66d9ef">INDEX</span> Stusno <span style="color:#66d9ef">ON</span> S (Sno);
	<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> Stusage <span style="color:#66d9ef">ON</span> S (Sage <span style="color:#66d9ef">DESC</span>);
	<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">UNIQUE</span> <span style="color:#66d9ef">INDEX</span> SCno 
                    <span style="color:#66d9ef">ON</span> SC(Sno <span style="color:#66d9ef">ASC</span>, Cno <span style="color:#66d9ef">DESC</span>);
</code></pre></div><h4 id="删除索引">删除索引</h4>
<p><strong>DROP INDEX  &lt;索引名&gt;;</strong></p>
<h4 id="修改索引">修改索引</h4>
<p><strong>ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;;</strong></p>
<h2 id="数据查询">数据查询</h2>
<ul>
<li>
<p>查询语法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> [<span style="color:#66d9ef">ALL</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">DISTINCT</span>] <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">目标列表达式</span><span style="color:#f92672">&gt;</span> [,<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">目标列表达式</span><span style="color:#f92672">&gt;</span>] <span style="color:#960050;background-color:#1e0010">…</span>
<span style="color:#66d9ef">FROM</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">表名或视图名</span><span style="color:#f92672">&gt;</span>[, <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">表名或视图名</span><span style="color:#f92672">&gt;</span> ] <span style="color:#960050;background-color:#1e0010">…</span>
[ <span style="color:#66d9ef">WHERE</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">条件表达式</span><span style="color:#f92672">&gt;</span> ]
[ <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">列名</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span> [ <span style="color:#66d9ef">HAVING</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">条件表达式</span><span style="color:#f92672">&gt;</span> ] ]
[ <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">列名</span><span style="color:#ae81ff">2</span><span style="color:#f92672">&gt;</span> [ <span style="color:#66d9ef">ASC</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">DESC</span> ] ] ;
</code></pre></div></li>
</ul>
<h3 id="单表查询">单表查询</h3>
<ul>
<li>
<p>目标列为表达式的查询</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span>  Sname, <span style="color:#ae81ff">1996</span> <span style="color:#f92672">-</span> Sage
<span style="color:#66d9ef">FROM</span>  Student ;
</code></pre></div></li>
<li>
<p>使用别名改变查询结果的列标题</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span>  Sname  NAME, <span style="color:#e6db74">&#39;Year of Birth:&#39;</span>  BIRTH,
      <span style="color:#ae81ff">1996</span> <span style="color:#f92672">-</span> Sage  BIRTHYEAR, 
      ISLOWER ( Sdept )  DEPARTMENT
</code></pre></div></li>
<li>
<p>消除结果中重复的行</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"> <span style="color:#66d9ef">SELECT</span>  <span style="color:#f92672">**</span><span style="color:#66d9ef">DISTINCT</span><span style="color:#f92672">**</span>  Sno <span style="color:#66d9ef">FROM</span>  SC ;
</code></pre></div></li>
<li>
<p>限定查询范围</p>
<table>
<thead>
<tr>
<th>查询条件</th>
<th>谓　词</th>
</tr>
</thead>
<tbody>
<tr>
<td>比　　较</td>
<td>= , &lt; ,  &gt; ,    &lt;= ,  &gt;= ,  &lt;&gt; ,    != ,  !&gt; ,  !&lt;    ;   NOT + 上述比较符</td>
</tr>
<tr>
<td>确定范围</td>
<td>BETWEEN … AND … ,   NOT  BETWEEN … AND …</td>
</tr>
<tr>
<td>确定集合</td>
<td>IN,  NOT IN</td>
</tr>
<tr>
<td>字符匹配</td>
<td>LIKE,  NOT LIKE</td>
</tr>
<tr>
<td>空　　值</td>
<td>IS NULL,  IS NOT NULL</td>
</tr>
<tr>
<td>多重条件</td>
<td>AND,  OR   -</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>确定范围</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span>  Sname, Sdept, Sage
<span style="color:#66d9ef">FROM</span>  Student
<span style="color:#66d9ef">WHERE</span>  Sage  <span style="color:#66d9ef">BETWEEN</span>  <span style="color:#ae81ff">20</span>  <span style="color:#66d9ef">AND</span>  <span style="color:#ae81ff">23</span> ;
</code></pre></div></li>
<li>
<p>确定集合</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span>  Sname, Ssex
<span style="color:#66d9ef">FROM</span>  Student
<span style="color:#66d9ef">WHERE</span>  Sdept  <span style="color:#66d9ef">NOT</span>  <span style="color:#66d9ef">IN</span> (<span style="color:#e6db74">&#39;IS&#39;</span>, <span style="color:#e6db74">&#39;MA&#39;</span>, <span style="color:#e6db74">&#39;CS&#39;</span>) ;
</code></pre></div></li>
<li>
<p>字符串匹配</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">[<span style="color:#66d9ef">NOT</span>] <span style="color:#66d9ef">LIKE</span>  <span style="color:#960050;background-color:#1e0010">‘</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">匹配模板</span><span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">’</span>  [<span style="color:#66d9ef">ESCAPE</span> <span style="color:#960050;background-color:#1e0010">‘</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">换码字符</span><span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">’</span>]
</code></pre></div><ul>
<li>
<p><strong>%(百分号)：代表任意长度(可以为0)的字符串。</strong></p>
<p>例：a%b表示以a开头，以b结尾的任意长度的字符串。如acb，addgb，ab 等都满足该匹配串。</p>
</li>
<li>
<p><strong>_(下横线)：代表任意单个字符。</strong></p>
<p>例：a_b表示以a开头，以b结尾的长度为3的任意字符串。如acb，afb等都满足该匹配串，一个汉字两个下横线</p>
</li>
<li>
<p><strong>当要查询的字符串本身就含有 % 或 _ 时，要使用  <code>ESCAPE '&lt;换码字符&gt;'</code>短语对通配符进行转义。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span>  Cno, Ccredit
<span style="color:#66d9ef">FROM</span>  Course
<span style="color:#66d9ef">WHERE</span>  Cname  <span style="color:#66d9ef">LIKE</span>  <span style="color:#e6db74">&#39;DB\_Design&#39;</span>  <span style="color:#66d9ef">ESCAPE</span> <span style="color:#e6db74">&#39;\&#39;</span> ;
;<span style="color:#960050;background-color:#1e0010">转义符‘\’表示模板中出现在其后的第一个字符不再是通配符，而是字符本身。</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>涉及空值的查询</p>
<p><strong>使用谓词 IS NULL 或 IS NOT NULL，“IS NULL” 不能用 “= NULL” 代替！</strong></p>
</li>
</ul>
</li>
<li>
<p>排序输出</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span>
</code></pre></div><ul>
<li><strong>升序：ASC ，排列为空值的元组最后显示 （空值最大）</strong></li>
<li><strong>降序：DESC</strong></li>
</ul>
</li>
<li>
<p>聚集函数</p>
<ul>
<li>计数 COUNT (使用 DISTINCT 避免重复计数)</li>
<li>计算总和 SUM</li>
<li>计算平均值 AVG</li>
<li>求最大值 MAX</li>
<li>求最小值 MIN</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">[ <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span>  <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">列名</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span>[, <span style="color:#960050;background-color:#1e0010">列名</span><span style="color:#ae81ff">2</span><span style="color:#960050;background-color:#1e0010">…</span>] [ <span style="color:#66d9ef">HAVING</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">条件表达式</span><span style="color:#f92672">&gt;</span> ] ] 
</code></pre></div><p>未对查询结果分组，集函数将作用于整个查询结果</p>
<p>对查询结果分组后，集函数将分别作用于每个组</p>
<p>⚠️<strong>使用GROUP BY子句后，SELECT子句的列名表中只能出现分组属性和集函数</strong></p>
<p>集函数只能用于SELECT子句和 HAVING短语之中，而<strong>绝对不能出现在 WHERE 子句</strong>中(WHERE子句执行过程是对记录逐一检验，并没有结果集，故无法施加集函数)。</p>
<p><img src="http://media.sumblog.cn/blog/20181223/nPMQrirY1FGp.png?imageMogr2/thumbnail/!60p" alt=""></p>
</li>
</ul>
<h3 id="连接查询">连接查询</h3>
<ul>
<li>
<p>等值连接、自然连接</p>
<p>SELECT子句和WHERE子句中出现的两个同名属性前要加所属表名作前辍以区别，无同名则可省前辍。</p>
</li>
<li>
<p>自身连接</p>
<p>需要给表起<strong>别名</strong>以示区别，由于所有的属性名都是同名属性， 因此必须使用<strong>别名前缀</strong></p>
</li>
<li>
<p>外连接 <strong>Outer Join</strong></p>
<ul>
<li>左外连接：在连接的右边出现空行</li>
<li>右外连接：在连接的左边出现空行</li>
<li>左右外链接：在连接的左右出现空行</li>
</ul>
<style type="text/css">.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative}</style>
<svg width="0" height="0" display="none" xmlns="http://www.w3.org/2000/svg"><symbol id="tip-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"/></symbol><symbol id="note-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="warning-notice" viewBox="0 0 576 512" preserveAspectRatio="xMidYMid meet"><path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="info-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/></symbol></svg><div class="notice note" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#note-notice"></use></svg></span>Note</p><p>连接类型<br>
- 内连接（INNER JOIN）<br>
- 左外连接（LEFT OUTER JOIN）<br>
- 右外连接（RIGHT OUTER JOIN）<br>
- 全外连接（FULL OUTER JOIN）</p></div>

</li>
</ul>
<h3 id="嵌套查询">嵌套查询</h3>
<h4 id="带有in谓词的子查询">带有IN谓词的子查询</h4>
<h4 id="带有比较运算符的子查询">带有比较运算符的子查询</h4>
<ul>
<li>⚠️特别注意：子查询一定要跟在比较符之后！</li>
</ul>
<h4 id="带有anysome或all谓词的查询">带有ANY(SOME)或ALL谓词的查询</h4>

    <img src="https://s1.ax1x.com/2020/11/05/BWeMzd.jpg"  class="center"  style="border-radius: 8px; width: 75% ;"  />


<h4 id="带有exists谓词的子查询">带有EXISTS谓词的子查询</h4>
<ul>
<li>
<p>EXISTS谓词的意义：</p>
<ul>
<li>是存在量词在SQL中的应用</li>
<li>带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值“true”或逻辑假值“false”
<ul>
<li>若内层查询结果非空，则返回真值</li>
<li>若内层查询结果为空，则返回假值</li>
</ul>
</li>
<li>由EXISTS引出的子查询，其目标列表达式通常都用*：因为带EXISTS的子查询只返回真值或假值，给出列名无实际意义

    <img src="https://s1.ax1x.com/2020/11/05/BWm9Tf.jpg"  class="center"  style="broder-radius: 8px; width: 75%;"  />

</li>
</ul>

    <img src="https://s1.ax1x.com/2020/11/05/BWnpv9.jpg"  class="center"  style="broder-radius: 8px; width: 75%;"  />



    <img src="https://s1.ax1x.com/2020/11/05/BWnnvd.jpg"  class="center"  style="broder-radius: 8px; width: 75%;"  />


</li>
</ul>
<h4 id="嵌套查询小结">嵌套查询小结</h4>
<p><strong>嵌套查询分为相关子查询和不相关子查询</strong></p>
<ul>
<li>不相关子查询的执行不依赖于父查询的任何条件
<ul>
<li>语句上不出现父查询中的属性</li>
<li>执行上首先运行，且只运行一次即可得到确定的结果</li>
<li>子查询的结果集将作为父查询的条件使用</li>
</ul>
</li>
<li>相关子查询的执行与父查询的当前值相关
<ul>
<li>语句上出现父查询中的属性</li>
<li>执行上父查询的当前值会作为子查询的条件</li>
</ul>
</li>
<li>子查询的属性不会出现在父查询的输出上(Select 子句)</li>
<li>子查询不能使用ORDER BY子句， ORDER BY子句只能对最终结果排序</li>
</ul>
<h3 id="集合查询">集合查询</h3>
<p>将两个SELECT-FROM-WHERE查询块用集合操作命令联结起来的查询</p>
<h4 id="集合操作命令">集合操作命令</h4>
<ul>
<li>并操作（UNION）</li>
<li>交操作（INTERSECT）</li>
<li>差操作（EXCEPT）</li>
</ul>
<h4 id="语句形式">语句形式</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">查询块</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">UNION</span> [<span style="color:#66d9ef">ALL</span>] <span style="color:#f92672">|</span> <span style="color:#66d9ef">INTERSECT</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">EXCEPT</span>
<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">查询块</span><span style="color:#f92672">&gt;</span> ;
</code></pre></div>
    <img src="https://s1.ax1x.com/2020/11/05/BWuPzQ.jpg"  class="center"  style="broder-radius: 8px; width: 75%;"  />


<h2 id="数据更新">数据更新</h2>
<h3 id="插入数据">插入数据</h3>
<h4 id="插入单个元组">插入单个元组</h4>

    <img src="https://s3.ax1x.com/2020/11/12/Bz4Ald.jpg"  class="center"  style="width: 70% ;border-radius: 5px; box-shadow: inset 2px 2px 5px black, 2px 2px 5px black;"  />


<h4 id="插入子查询结果">插入子查询结果</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">INSERT</span> 
<span style="color:#66d9ef">INTO</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">表名</span><span style="color:#f92672">&gt;</span>  [(<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">属性列</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span> [, <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">属性列</span><span style="color:#ae81ff">2</span><span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">…</span>  )]
<span style="color:#960050;background-color:#1e0010">子查询</span> ;
</code></pre></div><h3 id="修改数据">修改数据</h3>

    <img src="https://s3.ax1x.com/2020/11/12/Bz5PH0.jpg"  class="center"  style="width: 70% ;border-radius: 5px; box-shadow: inset 2px 2px 5px black, 2px 2px 5px black;"  />


<h3 id="删除数据">删除数据</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DELETE</span>
<span style="color:#66d9ef">FROM</span>  <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">表名</span><span style="color:#f92672">&gt;</span>
[<span style="color:#66d9ef">WHERE</span>  <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">条件</span><span style="color:#f92672">&gt;</span>] ;
</code></pre></div><h3 id="注意事项">注意事项</h3>
<p>DBMS在执行插入、删除、修改语句时必须保证数据库的完整性和一致性。</p>
<h2 id="大作业">大作业</h2>
<script type="text/javascript" src="/js/pdf-js/build/pdf.js"></script>
<style>
#the-canvas {
  border: 1px solid black;
  direction: ltr;
  width: 100%;
  height: auto;
}
#paginator{
    text-align: center;
    margin-bottom: 10px;
}
</style>

<div id="paginator">
    <button id="prev">Previous</button>
    <button id="next">Next</button>
    &nbsp; &nbsp;
    <span>Page: <span id="page_num"></span> / <span id="page_count"></span></span>
</div>
<div id="embed-pdf-container">
    <canvas id="the-canvas"></canvas>
</div>

<script type="text/javascript">
window.onload = function() {



var url = "\\pdf\\database.pdf";


var pdfjsLib = window['pdfjs-dist/build/pdf'];


pdfjsLib.GlobalWorkerOptions.workerSrc = '/js/pdf-js/build/pdf.worker.js';


var pdfDoc = null,
    pageNum = 1,
    pageRendering = false,
    pageNumPending = null,
    scale = 3,
    canvas = document.getElementById('the-canvas'),
    ctx = canvas.getContext('2d');



function renderPage(num) {
  pageRendering = true;
  
  pdfDoc.getPage(num).then(function(page) {
    var viewport = page.getViewport({scale: scale});
    canvas.height = viewport.height;
    canvas.width = viewport.width;

    
    var renderContext = {
      canvasContext: ctx,
      viewport: viewport
    };
    var renderTask = page.render(renderContext);

    
    renderTask.promise.then(function() {
      pageRendering = false;
      if (pageNumPending !== null) {
        
        renderPage(pageNumPending);
        pageNumPending = null;
      }
    });
  });

  
  document.getElementById('page_num').textContent = num;
}



function queueRenderPage(num) {
  if (pageRendering) {
    pageNumPending = num;
  } else {
    renderPage(num);
  }
}



function onPrevPage() {
  if (pageNum <= 1) {
    return;
  }
  pageNum--;
  queueRenderPage(pageNum);
}
document.getElementById('prev').addEventListener('click', onPrevPage);



function onNextPage() {
  if (pageNum >= pdfDoc.numPages) {
    return;
  }
  pageNum++;
  queueRenderPage(pageNum);
}
document.getElementById('next').addEventListener('click', onNextPage);



pdfjsLib.getDocument(url).promise.then(function(pdfDoc_) {
  pdfDoc = pdfDoc_;
  document.getElementById('page_count').textContent = pdfDoc.numPages;

  
  renderPage(pageNum);
});
}

</script>
]]></content>
        </item>
        
        <item>
            <title>微机原理</title>
            <link>https://fffzlfk.gitlab.io/posts/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/</link>
            <pubDate>Sat, 17 Oct 2020 21:07:26 +0800</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/posts/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/</guid>
            <description>单核处理器8086/8088 寄存器结构 通用寄存器    Reg 特殊用途     AX,AL I/O 指令的数据寄存器；乘法指令存放被乘数或积(隐含)，除法指令存放被除数或商(隐含)   AH LAHF指令的目标寄存器(隐含)   AL 数制转换或十进制运算指令和XLAT指令的累加器(隐含)   BX 间接寻址的基址寄存器 XLAT指令的基址寄存器(隐含)   CX 串操作和LOOP指令的计数器(隐含)   DX 字乘法/除法指令存放乘积高16位或被除数高位或余数(隐含) 间接寻址的 I/O 端口地址   SI 串操作的源变址寄存器(隐含)、间接寻址的变址寄存器   DI 串操作的目标变址寄存器(隐含)、间接寻址的变址寄存器   BP 对堆栈区间接寻址的基址指针   SP 堆栈操作的堆栈顶部指针    标志寄存器   6个状态标志位
  CF，进位标志。本次运算最高位有进位或借位发生，则CF=1。STC（CLC）指令使CF=1（=0），CMC指令使之取反。（用于无符号数）
  PF，奇偶校验标志：低 8 位有偶数个 1 则 PF = 1</description>
            <content type="html"><![CDATA[<h2 id="单核处理器80868088">单核处理器8086/8088</h2>
<h3 id="寄存器结构">寄存器结构</h3>

    <img src="/img/%e5%af%84%e5%ad%98%e5%99%a8%e7%bb%93%e6%9e%842.svg"  class="center"  style="border-radius: 8px;"  />


<h4 id="通用寄存器">通用寄存器</h4>
<table>
<thead>
<tr>
<th>Reg</th>
<th>特殊用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>AX,AL</td>
<td><strong>I/O 指令的数据寄存器</strong>；乘法指令存放<strong>被乘数或积</strong>(隐含)，除法指令存放被除数或商(隐含)</td>
</tr>
<tr>
<td>AH</td>
<td>LAHF指令的目标寄存器(隐含)</td>
</tr>
<tr>
<td>AL</td>
<td>数制转换或十进制运算指令和XLAT指令的累加器(隐含)</td>
</tr>
<tr>
<td>BX</td>
<td><strong>间接寻址的基址寄存器</strong> XLAT指令的基址寄存器(隐含)</td>
</tr>
<tr>
<td>CX</td>
<td>串操作和<strong>LOOP指令的计数器</strong>(隐含)</td>
</tr>
<tr>
<td>DX</td>
<td>字乘法/除法指令存放<strong>乘积高16位</strong>或<strong>被除数高位</strong>或<strong>余数</strong>(隐含) 间接寻址的 <strong>I/O 端口地址</strong></td>
</tr>
<tr>
<td>SI</td>
<td>串操作的源变址寄存器(隐含)、<strong>间接寻址的变址寄存器</strong></td>
</tr>
<tr>
<td>DI</td>
<td>串操作的目标变址寄存器(隐含)、<strong>间接寻址的变址寄存器</strong></td>
</tr>
<tr>
<td>BP</td>
<td>对<strong>堆栈区间接寻址的基址指针</strong></td>
</tr>
<tr>
<td>SP</td>
<td><strong>堆栈操作的堆栈顶部指针</strong></td>
</tr>
</tbody>
</table>
<h4 id="标志寄存器">标志寄存器</h4>
<ul>
<li>
<p>6个状态标志位</p>
<ul>
<li>
<p><strong>CF，进位标志</strong>。本次运算最高位<strong>有进位或借位发生，则CF=1</strong>。<strong>STC（CLC）指令使CF=1（=0），CMC指令使之取反。</strong>（用于无符号数）</p>
</li>
<li>
<p>PF，奇偶校验标志：低 8 位有偶数个 1 则 PF = 1</p>
</li>
<li>
<p><strong>AF：辅助进位标志</strong></p>
<p>低 4 位向高四位有进位或借位， AF = 1 （用于 BCD 计算）</p>
</li>
<li>
<p><strong>ZF：全零标志</strong></p>
<p>运算结果为 0 时，ZF = 1；</p>
</li>
<li>
<p><strong>SF：符号标志</strong></p>
<p>运算结果最高位为1，SF = 1 （表示负数）</p>
</li>
<li>
<p><strong>OF：溢出标志</strong></p>
<p>运算产生溢出 （两负数相加为正）（有符号数）时， OF =1</p>
</li>
</ul>
</li>
<li>
<p>3 个控制标志位</p>
<ul>
<li>TF：单步标志</li>
<li>IF：<strong>中断标志</strong>：IF = 1 允许，<strong>IF=0 禁止 CPU 响应可屏蔽中断</strong> （INTR）</li>
<li>DF：方向标志，串操作指令的地址变化方向</li>
</ul>
</li>
</ul>
<h3 id="主存结构">主存结构</h3>
<h4 id="双体结构">双体结构</h4>
<p>既能实现16位存储，也可以实现8位存储。

    <img src="https://s1.ax1x.com/2020/10/18/0XiVTf.png"  class="center"  style="border-radius: 8px;"  />

</p>
<h4 id="分段结构">分段结构</h4>
<pre><code> 68320H
+ 1280H
--------
 695A0H
</code></pre><h3 id="芯片引脚">芯片引脚</h3>
<h4 id="8086芯片引脚">8086芯片引脚</h4>

    <img src="https://s1.ax1x.com/2020/10/18/0XZYA1.jpg"  class="center"  style="border-radius: 8px;"  />



    <img src="https://s1.ax1x.com/2020/10/18/0XZ0je.jpg"  class="center"  style="border-radius: 8px;"  />


<h4 id="8088芯片引脚">8088芯片引脚</h4>

    <img src="https://s1.ax1x.com/2020/10/18/0XexRf.png"  class="center"  style="border-radius: 8px;"  />



    <img src="https://s1.ax1x.com/2020/10/18/0Xejit.png"  class="center"  style="border-radius: 8px;"  />



    <img src="https://s1.ax1x.com/2020/10/18/0XevJP.png"  class="center"  style="border-radius: 8px;"  />


<h4 id="8086vs8088">8086vs.8088</h4>
<ol>
<li>指令预取序列：4Bytes&lt;=&gt;6Bytes</li>
<li>AD7~AD0<br>
AD15~AD0 =&gt; 总线传递数据更快</li>
<li>8088：$ \overline{SSO} $, 8086: $ \overline{BHE} / S7 $</li>
<li>8088: $ IO/\overline M $, 8086: $ M/\overline{IO} $</li>
</ol>
<h3 id="工作时序">工作时序</h3>
<ol>
<li>时钟周期：CPU处理动作最小单位</li>
<li>总线周期：存储器读写、I/O读写、中断响应</li>
<li>指令周期：取指+执行</li>
</ol>
<p>主存读时序分析

    <img src="https://s1.ax1x.com/2020/10/18/0XnNhq.png"  class="center"  style="border-radius: 8px;"  />

</p>
<h3 id="习题">习题</h3>
<h4 id="22">2.2</h4>
<p>若8086CPU工作在最小模式下：</p>
<ol>
<li>当CPU访问储存器时，要利用哪些信号？</li>
</ol>
<blockquote>
<p>$AD0 \sim AD15、A16\sim A19、ALE、\overline{BHE}、DT/\overline{R}、\overline{DEN}、M/\overline{IO}、\overline{RD}、\overline{WR}$</p>
</blockquote>
<ol start="2">
<li>当CPU访问外设端口时，要利用哪些信号？</li>
</ol>
<blockquote>
<p>$AD0 \sim AD15、ALE、\overline{BHE}、DT/\overline{R}、\overline{DEN}、M/\overline{IO}、\overline{RD}、\overline{WR}$</p>
</blockquote>
<ol start="3">
<li>当HOLD有效并得到回应时，CPU的哪些信号置高阻？</li>
</ol>
<blockquote>
<p>CPU所有三态输出的地址、数据和相关控制信号。</p>
</blockquote>
<h4 id="22-1">2.2</h4>
<p>若8086CPU工作在最大模式下：</p>
<ol>
<li>S0、S1、S2可以表示哪些CPU的状态？</li>
</ol>
<blockquote>
<p>INTA周期、I/O读周期、I/O写周期、暂停、取值周期、存储器读周期、存储器写周期</p>
</blockquote>
<ol start="2">
<li>CPU的$ \overline{RQ}/\overline{GT} $信号的作用是什么？</li>
</ol>
<blockquote>
<p>$ \overline{RQ}/\overline{GT} $是裁决总线使用权的请求/允许信号</p>
</blockquote>
<h2 id="intel指令系统与程序设计">Intel指令系统与程序设计</h2>
<h3 id="程序框架">程序框架</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">STACK</span>  <span style="color:#66d9ef">SEGMENT</span> <span style="color:#66d9ef">STACK</span>
       <span style="color:#a6e22e">DB</span> <span style="color:#ae81ff">100</span> <span style="color:#66d9ef">DUP</span>(<span style="color:#ae81ff">0</span>)
<span style="color:#a6e22e">STACK</span>  <span style="color:#66d9ef">ENDS</span>

<span style="color:#a6e22e">DATA</span>   <span style="color:#66d9ef">SEGMENT</span>
<span style="color:#a6e22e">NUM8</span>   <span style="color:#66d9ef">DB</span> <span style="color:#ae81ff">16</span>,<span style="color:#ae81ff">25</span>
<span style="color:#a6e22e">NUM16</span>  <span style="color:#66d9ef">DW</span> <span style="color:#ae81ff">36</span>,<span style="color:#ae81ff">64</span>
<span style="color:#a6e22e">ARRAY8</span> <span style="color:#66d9ef">DB</span> <span style="color:#ae81ff">20</span> <span style="color:#66d9ef">DUP</span>(<span style="color:#ae81ff">0</span>)
<span style="color:#960050;background-color:#1e0010">………</span>  <span style="color:#960050;background-color:#1e0010">…………</span>

<span style="color:#a6e22e">DATA</span>   <span style="color:#66d9ef">ENDS</span>
<span style="color:#a6e22e">CODE</span>   <span style="color:#66d9ef">SEGMENT</span>
       <span style="color:#a6e22e">ASSUME</span> <span style="color:#66d9ef">CS</span>:<span style="color:#66d9ef">CODE</span>,<span style="color:#66d9ef">DS</span>:<span style="color:#66d9ef">DATA</span>,<span style="color:#66d9ef">SS</span>:<span style="color:#66d9ef">STACK</span>
START: <span style="color:#a6e22e">MOV</span> <span style="color:#66d9ef">AX</span>,<span style="color:#66d9ef">DATA</span>
       <span style="color:#a6e22e">MOV</span> <span style="color:#66d9ef">DS</span>,<span style="color:#66d9ef">AX</span>
        <span style="color:#960050;background-color:#1e0010">…………</span>
       <span style="color:#a6e22e">MOV</span> <span style="color:#66d9ef">AX</span>,<span style="color:#ae81ff">4</span><span style="color:#66d9ef">C00H</span>
       <span style="color:#a6e22e">INT</span> <span style="color:#ae81ff">21</span><span style="color:#66d9ef">H</span>
<span style="color:#a6e22e">CODE</span>   <span style="color:#66d9ef">ENDS</span>
       <span style="color:#a6e22e">END</span> <span style="color:#66d9ef">START</span>
</code></pre></div><p>子程序结构</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm">     <span style="color:#960050;background-color:#1e0010">……</span>
    <span style="color:#a6e22e">CALL</span> <span style="color:#66d9ef">SUB1</span>
    <span style="color:#960050;background-color:#1e0010">……</span>    

<span style="color:#a6e22e">SUB1</span> <span style="color:#66d9ef">PROC</span>
      <span style="color:#a6e22e">PUSH</span> <span style="color:#960050;background-color:#1e0010">…</span>
     <span style="color:#960050;background-color:#1e0010">……</span>
     <span style="color:#a6e22e">POP</span> <span style="color:#960050;background-color:#1e0010">…</span>
     <span style="color:#a6e22e">RET</span>

<span style="color:#a6e22e">SUB1</span> <span style="color:#66d9ef">ENDP</span>
</code></pre></div><h3 id="数据传送寻址算术运算指令">数据传送、寻址、算术运算指令</h3>
<h4 id="数据传送">数据传送</h4>
<ul>
<li>
<p><strong>MOV指令</strong></p>
<ul>
<li>MOV指令必须遵从的的规则：
<ol>
<li>两个操作数的尺寸必须一致</li>
<li>两个操作数不能同为操作数</li>
<li>目的操作数不能位CS, EIP和IP</li>
<li>立即数不能直接送至段寄存器</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">r</span><span style="color:#960050;background-color:#1e0010">/</span><span style="color:#66d9ef">m16</span>,<span style="color:#66d9ef">sreg</span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">sreg</span>,<span style="color:#66d9ef">r</span><span style="color:#960050;background-color:#1e0010">/</span><span style="color:#66d9ef">m16</span>
</code></pre></div></li>
<li>MOV指令格式
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">reg</span>, <span style="color:#66d9ef">reg</span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">mem</span>, <span style="color:#66d9ef">reg</span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">reg</span>, <span style="color:#66d9ef">mem</span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">mem</span>, <span style="color:#66d9ef">imm</span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">reg</span>, <span style="color:#66d9ef">emm</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p><strong>整数的零/符号扩展</strong></p>
<ol>
<li>MOVZX</li>
<li>MOVSZ</li>
</ol>
</li>
<li>
<p><strong>XCHG指令</strong></p>
<p>交换两个操作数的内容</p>
</li>
</ul>
<h4 id="加法和减法">加法和减法</h4>
<ul>
<li>
<p><strong>INC和DEC指令</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">inc</span> <span style="color:#66d9ef">reg</span><span style="color:#960050;background-color:#1e0010">/</span><span style="color:#66d9ef">mem</span>
<span style="color:#a6e22e">dec</span> <span style="color:#66d9ef">reg</span><span style="color:#960050;background-color:#1e0010">/</span><span style="color:#66d9ef">mem</span>
</code></pre></div><style type="text/css">.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative}</style>
<svg width="0" height="0" display="none" xmlns="http://www.w3.org/2000/svg"><symbol id="tip-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"/></symbol><symbol id="note-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="warning-notice" viewBox="0 0 576 512" preserveAspectRatio="xMidYMid meet"><path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="info-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/></symbol></svg><div class="notice tip" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"></use></svg></span>Tip</p><p>INC和DEC指令不影响进位标志</p></div>

</li>
<li>
<p><strong>ADD、SUB、NEG指令</strong></p>
<p>影响的标志位：CF, ZF, SF, OF, AF, PF</p>
</li>
</ul>
<h4 id="和数据相关的操作符和伪指令">和数据相关的操作符和伪指令</h4>
<ul>
<li>
<p><strong>OFFSET操作符</strong></p>
</li>
<li>
<p><strong>PTR操作符</strong></p>
<ul>
<li>用来重载操作数的默认尺寸</li>
<li>必须和标准数据类型联合使用</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">.data</span>
<span style="color:#a6e22e">myDouble</span> <span style="color:#66d9ef">DWORD</span> <span style="color:#ae81ff">12345678</span><span style="color:#66d9ef">h</span>
<span style="color:#a6e22e">.code</span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ax</span>, <span style="color:#66d9ef">myDouble</span>              <span style="color:#75715e">; 错误
</span><span style="color:#75715e"></span><span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">ax</span>, <span style="color:#66d9ef">WORD</span> <span style="color:#66d9ef">PTR</span> <span style="color:#66d9ef">myDouble</span>     <span style="color:#75715e">; ax = 5678h
</span><span style="color:#75715e"></span><span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">ax</span>, <span style="color:#66d9ef">WORD</span> <span style="color:#66d9ef">PTR</span> [<span style="color:#66d9ef">myDouble</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">2</span>] <span style="color:#75715e">; ax = 1234h
</span><span style="color:#75715e"></span><span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">bl</span>, <span style="color:#66d9ef">BYTE</span> <span style="color:#66d9ef">PTR</span> <span style="color:#66d9ef">myDouble</span>     <span style="color:#75715e">; bl = 78h
</span></code></pre></div></li>
<li>
<p><strong>TYPE操作符</strong>
返回按字节计算的变量的单个元素的大小</p>
</li>
<li>
<p><strong>LENGTHOF操作符</strong>
计算数组元素的个数</p>
</li>
<li>
<p><strong>SIZEOF操作符</strong>
SIZEOF返回值=LENGTHOF返回值*TYPE返回值</p>
</li>
</ul>
<h4 id="间接寻址">间接寻址</h4>
<ul>
<li>
<p><strong>间接操作数(寄存器间接寻址)</strong></p>
<p>PTR与间接操作数的联合使用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">inc</span> [<span style="color:#66d9ef">esi</span>]     <span style="color:#75715e">; error: operand must have size
</span><span style="color:#75715e"></span><span style="color:#66d9ef">inc</span> <span style="color:#66d9ef">BYTE</span> <span style="color:#66d9ef">PTR</span> [<span style="color:#66d9ef">esi</span>]
</code></pre></div></li>
<li>
<p><strong>数组</strong><br>
例：三个双字相加</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">.data</span>
<span style="color:#a6e22e">arrayD</span> <span style="color:#66d9ef">DWORD</span> <span style="color:#ae81ff">10000</span><span style="color:#66d9ef">h</span>,<span style="color:#ae81ff">20000</span><span style="color:#66d9ef">h</span>,<span style="color:#ae81ff">30000</span><span style="color:#66d9ef">h</span>
<span style="color:#a6e22e">.code</span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">esi</span>, <span style="color:#66d9ef">OFFSET</span> <span style="color:#66d9ef">arrayD</span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">eax</span>, [<span style="color:#66d9ef">esi</span>]
<span style="color:#a6e22e">add</span> <span style="color:#66d9ef">esi</span>, <span style="color:#ae81ff">4</span>
<span style="color:#a6e22e">add</span> <span style="color:#66d9ef">eax</span>, [<span style="color:#66d9ef">esi</span>]
<span style="color:#a6e22e">add</span> <span style="color:#66d9ef">esi</span>, <span style="color:#ae81ff">4</span>
<span style="color:#a6e22e">add</span> <span style="color:#66d9ef">eax</span>, [<span style="color:#66d9ef">esi</span>]
</code></pre></div></li>
<li>
<p><strong>变址操作数(寄存器相对寻址)</strong><br>
例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">.data</span>
<span style="color:#a6e22e">arrayB</span> <span style="color:#66d9ef">BYTE</span> <span style="color:#ae81ff">10</span><span style="color:#66d9ef">h</span>, <span style="color:#ae81ff">20</span><span style="color:#66d9ef">h</span>, <span style="color:#ae81ff">30</span><span style="color:#66d9ef">h</span>
<span style="color:#a6e22e">.code</span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">esi</span>, <span style="color:#ae81ff">0</span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">al</span>, [<span style="color:#66d9ef">arrayB</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#66d9ef">esi</span>]  <span style="color:#75715e">; AL = 10h
</span><span style="color:#75715e"></span><span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">al</span>, <span style="color:#66d9ef">arrayB</span>[<span style="color:#66d9ef">esi</span>]   <span style="color:#75715e">; 同上，另一种格式
</span><span style="color:#75715e"></span><span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">esi</span>, <span style="color:#66d9ef">OFFSET</span> <span style="color:#66d9ef">arrayB</span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">al</span>, [<span style="color:#66d9ef">esi</span>]         <span style="color:#75715e">; AL = 10h
</span><span style="color:#75715e"></span><span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">al</span>, [<span style="color:#66d9ef">esi</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">1</span>]       <span style="color:#75715e">; AL = 20h
</span><span style="color:#75715e"></span><span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">al</span>, [<span style="color:#66d9ef">esi</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">2</span>]       <span style="color:#75715e">; AL = 30h
</span></code></pre></div><div class="notice warning" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#warning-notice"></use></svg></span>Warning</p><p>实模式下只能使用SI，DI，BX，BP寄存器（尽量避免使用BP寄存器）</p></div>

</li>
</ul>
<h4 id="jmp和loop指令">JMP和LOOP指令</h4>
<ul>
<li><strong>JMP</strong>：无条件转移</li>
<li><strong>LOOP</strong>:条件转移
<ul>
<li>在实地址模式下，用做默认循环计数器的是CX而不是ECX</li>
<li>在任何模式下，LOOPD指令都使用ECX作为循环计数器，LOOPW都使用CX作为循环计数器</li>
<li>循环的目的地址与当前地址只能在相距-128到+127字节的范围之内。机器指令平均在3字节左右，因此一个循环平均最多只能包含大约42条指令</li>
<li>循环的嵌套
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">.data</span>
<span style="color:#a6e22e">count</span> <span style="color:#66d9ef">DWORD</span> <span style="color:#960050;background-color:#1e0010">?</span>
<span style="color:#a6e22e">.code</span>
    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ecx</span>, <span style="color:#ae81ff">100</span>
L1: <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">count</span>, <span style="color:#66d9ef">ecx</span>
    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ecx</span>, <span style="color:#ae81ff">20</span>
L2: <span style="color:#a6e22e">...</span>
    <span style="color:#a6e22e">...</span>
    <span style="color:#a6e22e">loop</span> <span style="color:#66d9ef">L2</span>
    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ecx</span>, <span style="color:#66d9ef">count</span>
    <span style="color:#a6e22e">loop</span> <span style="color:#66d9ef">L1</span>
</code></pre></div></li>
</ul>
</li>
</ul>
<h4 id="小结操作数类型寻址方式">小结：操作数类型（寻址方式）</h4>
<ul>
<li><strong>直接操作数（直接寻址）</strong>
变量的名字，代表变量的地址</li>
<li><strong>直接偏移操作数</strong>
在变量的名字上加一个偏移量</li>
<li><strong>间接操作数（寄存器间接寻址）</strong>
用方括号括起的包含数据地址的寄存器</li>
<li><strong>变址操作数（寄存器相对寻址）</strong>
把常量和间接操作数结合在一起</li>
</ul>
<h3 id="过程">过程</h3>
<h4 id="与外部库链接">与外部库链接</h4>
<ol>
<li>程序中要用PROTO伪指令声明要调用的程序:
WriteString PROTO</li>
<li>用一条CALL指令执行WriteString过程:
call WriteString</li>
<li>当程序被编译时，编译器为CALL指令的目标地址留出空白，该空白将有链接器填充</li>
<li>连接器在链接库中查找WriteString这个名字，从库中把合适的机器指令拷贝到程序的可执行文件中，并把WriteString的地址插入到CALL指令中</li>
</ol>
<h4 id="堆栈操作">堆栈操作</h4>
<ul>
<li><strong>堆栈</strong>
<ul>
<li>
<p>压栈操作：
32位的压栈（PUSH）操作将堆栈指针减4，并将进栈数据拷贝到堆栈指针所指向的位置</p>
</li>
<li>
<p>出栈操作：
出栈（POP）操作从堆栈顶端移走一个值并将其置于寄存器或变量中。在值从栈顶弹出后，堆栈指针相应增加。</p>

    <img src="https://s1.ax1x.com/2020/10/21/B92cgU.jpg"  class="center"  style="border-radius: 8px; width: 82%"  />


</li>
<li>
<p>堆栈的用途：</p>
<ul>
<li>临时保存区域</li>
<li>CALL指令用堆栈保存当前过程的⚠️返回地址</li>
<li>调用过程时,通过堆栈:⚠️传递参数</li>
<li>过程内的⚠️局部变量在堆栈上创建，过程结束时，这些变量被丢弃</li>
</ul>
</li>
</ul>
</li>
<li><strong>PUSH和POP指令</strong>
<ul>
<li>
<p>PUSH指令</p>
<ul>
<li>执行过程
<ul>
<li>减小ESP的值
<ul>
<li>16位操作数：ESP减2</li>
<li>32位操作数：ESP减4</li>
</ul>
</li>
<li>将一个16位或32位的源操作数拷贝至堆栈上</li>
</ul>
</li>
<li>指令格式
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">r</span><span style="color:#960050;background-color:#1e0010">/</span><span style="color:#66d9ef">m16</span>
<span style="color:#a6e22e">push</span> <span style="color:#66d9ef">r</span><span style="color:#960050;background-color:#1e0010">/</span><span style="color:#66d9ef">m32</span>
<span style="color:#a6e22e">push</span> <span style="color:#66d9ef">imm32</span>
</code></pre></div></li>
<li>保护模式下的立即数总是32位的；
在实地址模式下，如果未使用.386（或更高）处理器伪指令，默认的立即数是16位的</li>
</ul>
</li>
<li>
<p>POP指令</p>
<ul>
<li>执行过程
<ul>
<li>将ESP所指向的堆栈元素拷贝到16位或32位的目的操作数中</li>
<li>增加ESP的值
<ul>
<li>16位操作数：ESP加2</li>
<li>32位操作数：ESP加4</li>
</ul>
</li>
<li>指令格式
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">pop</span> <span style="color:#66d9ef">r</span><span style="color:#960050;background-color:#1e0010">/</span><span style="color:#66d9ef">m16</span>
<span style="color:#a6e22e">pop</span> <span style="color:#66d9ef">r</span><span style="color:#960050;background-color:#1e0010">/</span><span style="color:#66d9ef">m32</span>
</code></pre></div></li>
</ul>
</li>
</ul>
</li>
<li>
<p>PUSHFD和POPFD指令</p>
<ul>
<li>32位：
<ul>
<li>PUSHFD：在堆栈压入32位EFLAGS寄存器的值</li>
<li>POPFD：将堆栈顶部的值弹出并送至EFLAGS寄存器</li>
</ul>
</li>
<li>实地址模式：
<ul>
<li>PUSHF：在堆栈上压入16位FLAGS寄存器的值</li>
<li>POPF：将堆栈顶部的值弹出并送至FLAGS寄存器</li>
</ul>
</li>
</ul>
</li>
<li>
<p>PUSHAD,PUSHA,POPAD和POPA指令</p>
<ul>
<li>32位：
<ul>
<li>PUSHAD：将EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI按顺序压入堆栈</li>
<li>POPAD：按相反顺序弹出这些通用寄存器</li>
</ul>
</li>
<li>80286：
<ul>
<li>PUSHA：以用样的顺序压入AX、CX、DX、BX、SP、BP、SI、DI</li>
<li>POPA：以相反的顺序弹出</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="过程的定义和使用">过程的定义和使用</h4>
<ul>
<li>
<p><strong>PROC伪指令</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">Sumof</span> <span style="color:#66d9ef">PROC</span>
  <span style="color:#a6e22e">add</span> <span style="color:#66d9ef">eax</span>, <span style="color:#66d9ef">ebx</span>
  <span style="color:#a6e22e">add</span> <span style="color:#66d9ef">eax</span>, <span style="color:#66d9ef">ecx</span>
  <span style="color:#a6e22e">ret</span>
<span style="color:#a6e22e">Sumof</span> <span style="color:#66d9ef">ENDP</span>
</code></pre></div></li>
<li>
<p><strong>CALL和RET指令</strong></p>
<ul>
<li>
<p>调用和返回的例子

    <img src="https://s1.ax1x.com/2020/10/21/B97DL6.png"  class="center"  style="border-radius: 8px; width: 80%"  />

</p>
</li>
<li>
<p>可嵌套使用</p>
</li>
<li>
<p>局部标号和全局标号</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm">L1:<span style="color:#960050;background-color:#1e0010">:</span>      <span style="color:#75715e">; global label
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">...</span>
L2:       <span style="color:#75715e">; local babel
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">...</span>
</code></pre></div></li>
</ul>
</li>
</ul>
<h3 id="条件处理">条件处理</h3>
<h4 id="布尔和比较指令">布尔和比较指令</h4>
<ul>
<li><strong>AND指令</strong>：按位与
<ul>
<li>影响的标志位：
<ul>
<li>总是清除OF和CF；</li>
<li>根据结果修改SF，ZF，PF</li>
</ul>
</li>
<li>主要用途：对特定的位清0</li>
<li>大写字母和小写字母的ASCII码之间的关系：
<ul>
<li>&lsquo;a&rsquo;: 61h, 01100001b</li>
<li>&lsquo;A&rsquo;: 41h, 01000001b</li>
</ul>
</li>
</ul>
</li>
<li><strong>OR指令</strong>：按位或
<ul>
<li>主要用途：对特定的位置1</li>
</ul>
</li>
<li><strong>XOR指令</strong>：按位异或
<ul>
<li>用途：
<ul>
<li>对某些位取反</li>
<li>判断16位或32位值的奇偶性
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ax</span>, <span style="color:#ae81ff">64</span><span style="color:#66d9ef">C1h</span>     <span style="color:#75715e">; 0110 0100 1100 0001
</span><span style="color:#75715e"></span><span style="color:#66d9ef">xor</span> <span style="color:#66d9ef">ah</span>, <span style="color:#66d9ef">al</span>        <span style="color:#75715e">; PE, 奇偶位被设置
</span></code></pre></div></li>
<li>简单数据加密
将某个操作数与同样的操作数执行两次异或操作之后，其值保持不变
$$ (X\oplus Y) \oplus Y = X $$</li>
</ul>
</li>
</ul>
</li>
<li><strong>NOT指令</strong>：取反
<div class="notice warning" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#warning-notice"></use></svg></span>Warning</p><p><strong>NOT指令不影响任何状态标志</strong></p></div>
</li>
<li><strong>TEST指令</strong>：两操作数按位<strong>与</strong>，根据结果设置标志位，但<strong>不回送结果</strong>（不修改目的操作数）
<ul>
<li>用途：测试某一位是“0”还是“1”
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">test</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">00001001</span><span style="color:#66d9ef">b</span>   <span style="color:#75715e">; test bits 0 and 3
</span></code></pre></div><p>判断ZF是否等于1</p>
</li>
<li>影响的标志位：清除OF、CF；修改SF、ZF、PF</li>
</ul>
</li>
<li><strong>CMP指令</strong>
<ul>
<li>
<p>功能：与减法指令一样执行减法操作，但<strong>不回送</strong>结果，只<strong>影响标志位</strong></p>
</li>
<li>
<p>影响的标志位：根据相减结果修改OF、SF、ZF、CF、AF、PF</p>
</li>
<li>
<p>无符号操作数的比较</p>
<table>
<thead>
<tr>
<th>CMP的结果</th>
<th>ZF</th>
<th>CF</th>
</tr>
</thead>
<tbody>
<tr>
<td>目的 &lt; 源</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>目的 &gt; 源</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>目的 = 源</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>有符号操作数的比较

    <img src="/img/CMP2.svg"  class="center"  style="border-radius: 8px; width: 70%"  />

</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ax</span>, <span style="color:#ae81ff">5</span>
<span style="color:#a6e22e">cmp</span> <span style="color:#66d9ef">ax</span>, <span style="color:#ae81ff">10</span>  <span style="color:#75715e">; CF = 1
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">si</span>, <span style="color:#ae81ff">105</span>
<span style="color:#a6e22e">cmp</span> <span style="color:#66d9ef">si</span>, <span style="color:#ae81ff">0</span>   <span style="color:#75715e">; ZF = 0, CF = 0
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ax</span>, <span style="color:#ae81ff">1000</span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">cx</span>, <span style="color:#ae81ff">1000</span>
<span style="color:#a6e22e">cmp</span> <span style="color:#66d9ef">ax</span>, <span style="color:#66d9ef">cx</span>  <span style="color:#75715e">; ZF = 1
</span></code></pre></div></li>
<li>
<p>设置和清除单个CPU标志</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">test</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">0</span>   <span style="color:#75715e">; 设置零标志
</span><span style="color:#75715e"></span><span style="color:#66d9ef">and</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">0</span>    <span style="color:#75715e">; 设置零标志
</span><span style="color:#75715e"></span><span style="color:#66d9ef">or</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">0</span>     <span style="color:#75715e">; 设置零标志
</span><span style="color:#75715e"></span>    
<span style="color:#66d9ef">or</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">80</span><span style="color:#66d9ef">h</span>   <span style="color:#75715e">; 设置符号标志
</span><span style="color:#75715e"></span><span style="color:#66d9ef">and</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">7</span><span style="color:#66d9ef">Fh</span>  <span style="color:#75715e">; 清楚符号标志
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">stc</span>          <span style="color:#75715e">; 设置进位标志
</span><span style="color:#75715e"></span><span style="color:#66d9ef">clc</span>          <span style="color:#75715e">; 清除进位标志
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">7</span><span style="color:#66d9ef">Fh</span>  <span style="color:#75715e">; AL = +127
</span><span style="color:#75715e"></span><span style="color:#66d9ef">inc</span> <span style="color:#66d9ef">al</span>       <span style="color:#75715e">; AL = 80h
</span><span style="color:#75715e"></span><span style="color:#66d9ef">or</span> <span style="color:#66d9ef">eax</span>, <span style="color:#ae81ff">0</span>    <span style="color:#75715e">; 清除溢出标志
</span></code></pre></div></li>
</ul>
</li>
</ul>
<h4 id="条件跳转">条件跳转</h4>
<ul>
<li>
<p><strong>条件结构</strong></p>
<ul>
<li>
<p>使用CMP、TEST、AND之类的指令修改CPU标志</p>
</li>
<li>
<p>使用条件跳转指令测试标志值，已决定是否向新的分支转移</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm">    <span style="color:#a6e22e">cmp</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">0</span>
    <span style="color:#a6e22e">jz</span>  <span style="color:#66d9ef">L1</span>      <span style="color:#75715e">; jump if ZF = 1
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">...</span>

L1:
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm">    <span style="color:#a6e22e">and</span> <span style="color:#66d9ef">dl</span>, <span style="color:#ae81ff">10110000</span><span style="color:#66d9ef">b</span>
    <span style="color:#a6e22e">jnz</span> <span style="color:#66d9ef">L2</span>            <span style="color:#75715e">; jump if ZF = 0
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">...</span>
L2:    
</code></pre></div></li>
</ul>
</li>
<li>
<p><strong>Jcond指令</strong></p>
<ul>
<li>功能：
<ul>
<li>条件标志为真：分支转移到新的目标标号处</li>
<li>条件标志为假：执行紧跟在条件跳转指令之后的指令</li>
</ul>
</li>
<li>格式：
例：
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ax</span>, <span style="color:#ae81ff">5</span>     <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">ax</span>, <span style="color:#ae81ff">5</span>     <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">ax</span>, <span style="color:#ae81ff">5</span>
<span style="color:#a6e22e">cmp</span> <span style="color:#66d9ef">ax</span>, <span style="color:#ae81ff">5</span>     <span style="color:#66d9ef">cmp</span> <span style="color:#66d9ef">ax</span>, <span style="color:#ae81ff">6</span>     <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">ax</span>, <span style="color:#ae81ff">6</span>
<span style="color:#a6e22e">je</span> <span style="color:#66d9ef">L1</span>         <span style="color:#66d9ef">j1</span> <span style="color:#66d9ef">L1</span>         <span style="color:#66d9ef">jg</span> <span style="color:#66d9ef">L1</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>条件跳转指令的类型</p>
<ul>
<li>
<p>基于特定CPU<strong>标志值</strong></p>
<table>
<thead>
<tr>
<th>助记符</th>
<th>描述</th>
<th>标志值</th>
</tr>
</thead>
<tbody>
<tr>
<td>JZ</td>
<td>为零则跳转</td>
<td>ZF = 1</td>
</tr>
<tr>
<td>JNZ</td>
<td>不为零则跳转</td>
<td>ZF = 0</td>
</tr>
<tr>
<td>JC</td>
<td>如果设置进位标志则跳转</td>
<td>CF = 1</td>
</tr>
<tr>
<td>JNC</td>
<td>如果未设置进位标志则跳转</td>
<td>CF = 0</td>
</tr>
<tr>
<td>JO</td>
<td>如果设置溢出标志则跳转</td>
<td>OF = 1</td>
</tr>
<tr>
<td>JNO</td>
<td>如果未设置溢出标志则跳转</td>
<td>OF = 0</td>
</tr>
<tr>
<td>JS</td>
<td>如果设置符号标志则跳转</td>
<td>SF = 1</td>
</tr>
<tr>
<td>JNS</td>
<td>如果未设置符号标志则跳转</td>
<td>SF = 0</td>
</tr>
<tr>
<td>JP</td>
<td>如果设置了奇偶标志则跳转（偶）</td>
<td>PF = 1</td>
</tr>
<tr>
<td>JNP</td>
<td>如果未设置奇偶标志则跳转（奇）</td>
<td>PF = 0</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>依据<strong>相等</strong>比较的跳转指令</p>
<table>
<thead>
<tr>
<th>助记符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>JE</td>
<td>相等则跳转</td>
</tr>
<tr>
<td>JNE</td>
<td>不相等则不跳转</td>
</tr>
<tr>
<td>JCXZ</td>
<td>CX = 0 则跳转</td>
</tr>
<tr>
<td>JECXZ</td>
<td>ECX = 0 则跳转</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>基于<strong>无符号整数</strong>比较结果的跳转指令</p>
<blockquote>
<p>A:Above, B: Below, E:Equal</p>
</blockquote>
<table>
<thead>
<tr>
<th>助记府</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>JA</td>
<td>大于则跳转(leftOp &gt; rightOp)</td>
</tr>
<tr>
<td>JNBE</td>
<td>不（小于或等于）（同JA）</td>
</tr>
<tr>
<td>JAE</td>
<td>大于或等于则跳转 (leftOp &gt;= rightOp)</td>
</tr>
<tr>
<td>JNB</td>
<td>不小于则跳转 （同JAE）</td>
</tr>
<tr>
<td>JB</td>
<td>小于则跳转(leftOp &lt; rightOp)</td>
</tr>
<tr>
<td>JNAE</td>
<td>不（大于或等于）（同JB）</td>
</tr>
<tr>
<td>JBE</td>
<td>小于或等于则跳转(leftOp &lt;= rightOp)</td>
</tr>
<tr>
<td>JNA</td>
<td>不大于则跳转（同JBE）</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>基于<strong>有符号整数</strong>比较结果的跳转指令</p>
<blockquote>
<p>G: Grater, L: Less, E: Equal</p>
</blockquote>
<table>
<thead>
<tr>
<th>助记府</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>JG</td>
<td>大于则跳转(leftOp &gt; rightOp)</td>
</tr>
<tr>
<td>JNLE</td>
<td>不（小于或等于）（同JA）</td>
</tr>
<tr>
<td>JGE</td>
<td>大于或等于则跳转 (leftOp &gt;= rightOp)</td>
</tr>
<tr>
<td>JNL</td>
<td>不小于则跳转 （同JAE）</td>
</tr>
<tr>
<td>JL</td>
<td>小于则跳转(leftOp &lt; rightOp)</td>
</tr>
<tr>
<td>JNGE</td>
<td>不（大于或等于）（同JB）</td>
</tr>
<tr>
<td>JLE</td>
<td>小于或等于则跳转(leftOp &lt;= rightOp)</td>
</tr>
<tr>
<td>JNG</td>
<td>不大于则跳转（同JBE）</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">7</span><span style="color:#66d9ef">Fh</span>     <span style="color:#75715e">; (7Fh or +127)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">cmp</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">80</span><span style="color:#66d9ef">h</span>     <span style="color:#75715e">; (80h or -128)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">ja</span> <span style="color:#66d9ef">IsAbove</span>      <span style="color:#75715e">; no : 7F not &gt; 180h
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">7</span><span style="color:#66d9ef">Fh</span>     <span style="color:#75715e">; (7Fh or +127)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">cmp</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">80</span><span style="color:#66d9ef">h</span>     <span style="color:#75715e">; (80h or -128)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">jg</span> <span style="color:#66d9ef">IsAbove</span>      <span style="color:#75715e">; yes: +127 &gt; -128
</span></code></pre></div></li>
</ul>
</li>
</ul>
<h4 id="条件循环指令">条件循环指令</h4>
<ul>
<li>
<p><strong>LOOPZ和LOOPE指令</strong></p>
<ul>
<li>含义：Loop if zero，Loop if equal</li>
<li>二者等价</li>
<li>执行逻辑：
ECX = ECX - 1<br>
if ECX &gt; 0 and ZF = 1, jump to destination</li>
</ul>
</li>
<li>
<p><strong>LOOPNZ和LOOPNE指令</strong></p>
<ul>
<li>含义：Loop if not zero， Loop if not equal</li>
<li>二者等价</li>
<li>执行逻辑：
ECX = ECX - 1<br>
if ECX &gt; 0 and ZF = 0, jump to destination</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#75715e">; 扫描数组中的每个数值，直到发现正数为止
</span><span style="color:#75715e"></span><span style="color:#a6e22e">.data</span>
<span style="color:#a6e22e">array</span> <span style="color:#66d9ef">SWORD</span> -<span style="color:#ae81ff">3</span>,-<span style="color:#ae81ff">6</span>,-<span style="color:#ae81ff">1</span>,-<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">30</span>,<span style="color:#ae81ff">40</span>,<span style="color:#ae81ff">4</span>
<span style="color:#a6e22e">sentinel</span> <span style="color:#66d9ef">SWORD</span> <span style="color:#ae81ff">0</span>
<span style="color:#a6e22e">.code</span>
      <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">esi</span>, <span style="color:#66d9ef">OFFSET</span> <span style="color:#66d9ef">array</span>
      <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ecx</span>, <span style="color:#66d9ef">LENGTHOF</span> <span style="color:#66d9ef">array</span>
next: <span style="color:#a6e22e">test</span> <span style="color:#66d9ef">WORD</span> <span style="color:#66d9ef">PTR</span> [<span style="color:#66d9ef">esi</span>], <span style="color:#ae81ff">8000</span><span style="color:#66d9ef">h</span> <span style="color:#75715e">; test highest bit
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">pushfd</span>                     <span style="color:#75715e">; push flags on stack
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">add</span> <span style="color:#66d9ef">esi</span>, <span style="color:#66d9ef">TYPE</span> <span style="color:#66d9ef">array</span>        
      <span style="color:#66d9ef">popfd</span>                      <span style="color:#75715e">; pop flags from stack
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">loopnz</span> <span style="color:#66d9ef">next</span>                <span style="color:#75715e">; continue
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">jnz</span> <span style="color:#66d9ef">quit</span>                   <span style="color:#75715e">; none found
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">sub</span> <span style="color:#66d9ef">esi</span>, <span style="color:#66d9ef">TYPE</span> <span style="color:#66d9ef">array</span>        <span style="color:#75715e">; SI points to value
</span></code></pre></div></li>
</ul>
<h3 id="整数运算指令">整数运算指令</h3>
<h4 id="移位和循环移位指令">移位和循环移位指令</h4>
<div class="notice note" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#note-notice"></use></svg></span>Note</p><p><strong>S</strong>hift
<strong>L</strong>eft
<strong>R</strong>ight
<strong>A</strong>rithmetic
<strong>R</strong>otate
<strong>C</strong>arry</p></div>

<ul>
<li>
<p>移位指令</p>
<table>
<thead>
<tr>
<th>助记符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SHL</td>
<td>逻辑左移</td>
</tr>
<tr>
<td>SHR</td>
<td>逻辑右移</td>
</tr>
<tr>
<td>SAL</td>
<td>算数左移</td>
</tr>
<tr>
<td>SAR</td>
<td>算数右移</td>
</tr>
<tr>
<td>ROL</td>
<td>循环左移</td>
</tr>
<tr>
<td>ROR</td>
<td>循环右移</td>
</tr>
<tr>
<td>RCL</td>
<td>带进位的循环左移</td>
</tr>
<tr>
<td>RCR</td>
<td>带进位的循环右移</td>
</tr>
<tr>
<td>SHLD</td>
<td>双精度左移</td>
</tr>
<tr>
<td>SHRD</td>
<td>双精度右移</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>上述指令影响<strong>OF、CF</strong></p>
</li>
<li>
<p><strong>逻辑移位和算术移位</strong>

    <img src="https://s1.ax1x.com/2020/10/21/BPG8pt.png"  class="center"  style="border-radius: 8px; width: 55%"  />

</p>
</li>
<li>
<p><strong>循环左移ROL和循环右移ROR</strong>

    <img src="https://s1.ax1x.com/2020/10/21/BPG1fI.png"  class="center"  style="border-radius: 8px; width: 40%"  />



    <img src="https://s1.ax1x.com/2020/10/21/BPGQkd.png"  class="center"  style="border-radius: 8px; width: 40%"  />

</p>
</li>
<li>
<p><strong>带进位的循环左移RCL和右移RCR</strong>

    <img src="https://s1.ax1x.com/2020/10/21/BPGltA.png"  class="center"  style="border-radius: 8px; width: 65%"  />

</p>
</li>
<li>
<p><strong>SHLD/SHRD指令</strong></p>
<ul>
<li>格式：<strong>SHLD 目的操作数，源操作数，移位位数</strong></li>
<li>要求至少是Intel386处理器</li>
<li>SHLD：双精度左移，<strong>Sh</strong>ift <strong>L</strong>eft <strong>D</strong>ouble<br>
将目的操作数左移指定的位数，低位空出来的位用源操作数的高位填充</li>
<li>SHRD：双精度右移，<strong>Sh</strong>ift <strong>R</strong>ight <strong>D</strong>ouble<br>
将目的操作数右移指定的位数，空出来的位由源操作数的低位来填充。</li>
</ul>
</li>
<li>
<p>格式：<br>
<strong>助记符 目的操作数，移位位数</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">SHL</span> <span style="color:#66d9ef">reg</span>, <span style="color:#66d9ef">imm8</span>
<span style="color:#a6e22e">SAL</span> <span style="color:#66d9ef">mem</span>, <span style="color:#66d9ef">imm8</span>
<span style="color:#a6e22e">ROR</span> <span style="color:#66d9ef">reg</span>, <span style="color:#66d9ef">CL</span>
<span style="color:#a6e22e">RCL</span> <span style="color:#66d9ef">mem</span>, <span style="color:#66d9ef">CL</span>
</code></pre></div><ul>
<li>8088/8086要求imm8必须等于1；80286以上，imm8可以为“任意”整数</li>
<li>CL方式可用于任何Intel x86处理器</li>
</ul>
</li>
</ul>
<h4 id="乘法和除法指令">乘法和除法指令</h4>
<ul>
<li>
<p><strong>MUL指令</strong></p>
<ul>
<li>格式（操作数为乘数）：<br>
MUL r/m8<br>
MUL r/m16<br>
MUL r/m32</li>
<li>功能：无符号乘法。将8位、16位或32位的操作数与AL、AX或EAX相乘  
<table>
<thead>
<tr>
<th>被乘数</th>
<th>乘数</th>
<th>积</th>
<th>CF = 1的条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>AL</td>
<td>r/m8</td>
<td>AX</td>
<td>AH $\neq$ 0</td>
</tr>
<tr>
<td>AX</td>
<td>r/m16</td>
<td>DX:AX</td>
<td>DX $\neq$ 0</td>
</tr>
<tr>
<td>EAX</td>
<td>r/m32</td>
<td>EDX:EAX</td>
<td>EDX $\neq$ 0</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p><strong>IMUL指令</strong>：有符号乘法<br>
如果累积的高半部分<strong>不是低半部分的符号扩展（换而言之就是低半部分不足够表示累积）</strong>，则设置CF和OF<br>
例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">48</span>      <span style="color:#75715e">; 48D = 30H
</span><span style="color:#75715e"></span><span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">bl</span>, <span style="color:#ae81ff">4</span>
<span style="color:#a6e22e">imul</span> <span style="color:#66d9ef">bl</span>         <span style="color:#75715e">; AX = 00C0h, OF = 1
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">al</span>, -<span style="color:#ae81ff">4</span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">bl</span>, <span style="color:#ae81ff">4</span>
<span style="color:#a6e22e">imul</span> <span style="color:#66d9ef">bl</span>         <span style="color:#75715e">; AX = FFF0h, OF = 0
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ax</span>, <span style="color:#ae81ff">48</span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">bx</span>, <span style="color:#ae81ff">4</span>
<span style="color:#a6e22e">imul</span> <span style="color:#66d9ef">ax</span>         <span style="color:#75715e">; DX:AX = 000000C0h, OF = 1
</span></code></pre></div></li>
<li>
<p><strong>DIV指令</strong>：无符号除法</p>
<table>
<thead>
<tr>
<th>被除数</th>
<th>除数</th>
<th>商</th>
<th>余数</th>
</tr>
</thead>
<tbody>
<tr>
<td>AX</td>
<td>r/m8</td>
<td>AL</td>
<td>AH</td>
</tr>
<tr>
<td>DX:AX</td>
<td>r/m16</td>
<td>AX</td>
<td>DX</td>
</tr>
<tr>
<td>EDX:EAX</td>
<td>r/m32</td>
<td>EAX</td>
<td>EDX</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>有符号整数除法</strong></p>
<ul>
<li>CBW, CWD, CDQ指令
<ul>
<li>CBW(Convert Byte to Word): 将AL中的符号位扩展到AH</li>
<li>CWD(Convert Word to Doubleword): 将AX中的符号位扩展到DX</li>
<li>CDQ(Convert DoubleWord QuadWord): 将EAX中的符号位扩展到EDX</li>
</ul>
</li>
<li>IDIV指令：有符号数整数的除法运算<br>
例：
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">.data</span>
<span style="color:#a6e22e">byteVal</span> <span style="color:#66d9ef">SBYTE</span> -<span style="color:#ae81ff">48</span>
<span style="color:#a6e22e">.code</span>
  <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">al</span>, <span style="color:#66d9ef">byteVal</span>
  <span style="color:#a6e22e">cbw</span>               <span style="color:#75715e">; extend AL into AH
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">bl</span>, <span style="color:#ae81ff">5</span>
  <span style="color:#a6e22e">idiv</span> <span style="color:#66d9ef">bl</span>           <span style="color:#75715e">; AL = -9, AH = -3
</span><span style="color:#75715e"></span>    
<span style="color:#66d9ef">.data</span>
<span style="color:#a6e22e">wordVal</span> <span style="color:#66d9ef">SWORD</span> -<span style="color:#ae81ff">5000</span>
<span style="color:#a6e22e">.code</span>
  <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ax</span>, <span style="color:#66d9ef">wordVal</span>
  <span style="color:#a6e22e">cwd</span>               <span style="color:#75715e">; extend AX into DX
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">bx</span>, <span style="color:#ae81ff">256</span>
  <span style="color:#a6e22e">idiv</span> <span style="color:#66d9ef">bx</span>           <span style="color:#75715e">; AX = -19, DX = -136
</span></code></pre></div></li>
<li>除法溢出
<ul>
<li>当除法产生的商太大而无法容纳在目的操作数中的时候，将导致除法溢出，使CPU触发一个中断，当前程序被终止</li>
<li>试图除以0也会发生相同的情况</li>
<li>解决办法
<ul>
<li>使用32位的除数来减小除法溢出的可能性</li>
<li>测试除数，如果除数等于0则跳过除法指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="扩展加法和减法">扩展加法和减法</h4>
<ul>
<li><strong>ADC指令</strong>：扩展加法<br>
目的操作数 + 源操作数 + 进位标志-&gt;目的操作数</li>
<li><strong>SBB指令</strong>：扩展减法<br>
目的操作数 + 源操作数 - 进位标志-&gt;目的操作数</li>
</ul>
<h4 id="ascii和压缩十进制算数">ASCII和压缩十进制算数</h4>
<ul>
<li><strong>AAA</strong>：<strong>加</strong>法之后进行ASCII码调整
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ag</span>, <span style="color:#ae81ff">0</span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">al</span>, <span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#ae81ff">8</span><span style="color:#960050;background-color:#1e0010">&#39;</span>       <span style="color:#75715e">; AX = 0038h
</span><span style="color:#75715e"></span><span style="color:#66d9ef">add</span> <span style="color:#66d9ef">al</span>, <span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#ae81ff">2</span><span style="color:#960050;background-color:#1e0010">&#39;</span>       <span style="color:#75715e">; AX = 006Ah
</span><span style="color:#75715e"></span><span style="color:#66d9ef">aaa</span>               <span style="color:#75715e">; AX = 0100h
</span><span style="color:#75715e"></span><span style="color:#66d9ef">or</span> <span style="color:#66d9ef">ax</span>, <span style="color:#ae81ff">3030</span><span style="color:#66d9ef">h</span>      <span style="color:#75715e">; AX = 3130h = &#39;10&#39;
</span></code></pre></div></li>
<li><strong>AAS</strong>：<strong>减</strong>法之后进行ASCII码调整</li>
<li><strong>AAM</strong>：<strong>乘</strong>法之后进行ASCII码调整</li>
<li><strong>AAD</strong>：<strong>除</strong>法之后进行ASCII码调整</li>
<li>压缩的十进制整数
<ul>
<li><strong>DAA指令</strong>：将ADD或ADC指令执行后AL中的结果转换成压缩的十进制格式</li>
<li><strong>DAS指令</strong>：将SUB或SBB指令执行后AL中的结果转换成压缩的十进制格式</li>
<li>例：
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">35</span><span style="color:#66d9ef">h</span>     
<span style="color:#66d9ef">add</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">48</span><span style="color:#66d9ef">h</span>     <span style="color:#75715e">; AL = 7Dh
</span><span style="color:#75715e"></span><span style="color:#66d9ef">daa</span>             <span style="color:#75715e">; AL = 83h
</span><span style="color:#75715e"></span>    
<span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">bl</span>, <span style="color:#ae81ff">48</span><span style="color:#66d9ef">h</span>
<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">85</span><span style="color:#66d9ef">h</span>
<span style="color:#a6e22e">sub</span> <span style="color:#66d9ef">al</span>, <span style="color:#66d9ef">bl</span>      <span style="color:#75715e">; AL = 3Dh
</span><span style="color:#75715e"></span><span style="color:#66d9ef">das</span>             <span style="color:#75715e">; AL = 37h
</span></code></pre></div></li>
</ul>
</li>
</ul>
<h3 id="字符串与数组">字符串与数组</h3>
<h4 id="基本字符串操作指令">基本字符串操作指令</h4>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>MOVSB, MOVSW, MOVSD</td>
<td><strong>移动字符串数据</strong>：拷贝DS:(E)SI寻址的内存操作数至ES:(E)DI</td>
</tr>
<tr>
<td>CMPSB, SMPSW, CMPSD</td>
<td><strong>比较字符串</strong>：比较内存中由DS:(E)SI寻址和ES:(E)DI寻址的字符串。源-目的</td>
</tr>
<tr>
<td>SCASB, SCASW, SCASD</td>
<td><strong>扫描字符串</strong>：扫描ES:(E)DI指向的内存字符串查找与累加器匹配的值</td>
</tr>
<tr>
<td>STOSB, STOSW, STOSD</td>
<td><strong>存储字符串</strong>：将累加器内容存储到由ES:(E)DI寻址的内存中</td>
</tr>
<tr>
<td>LODSB, LODSW, LODSD</td>
<td><strong>将字符串数据装入累加器</strong>：将由DS:(E)SI寻址的内存单元装入累加器中</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><strong>使用重复前缀</strong></p>
<ul>
<li>字符串操作指令每次只能处理一个内存值。</li>
<li>通过增加一个重复前缀，字符串指令就会使用ECX作为计数器进行重复 —— 实现用一条指令处理整个数组。</li>
<li>可以使用的重复前缀
<table>
<thead>
<tr>
<th>REP</th>
<th>ECX &gt; 0时重复</th>
</tr>
</thead>
<tbody>
<tr>
<td>REPZ, REPE</td>
<td>当ZF＝1且ECX＞0时重复</td>
</tr>
<tr>
<td>REPNE, REPNZ</td>
<td>当ZF＝0且ECX＞0时重复</td>
</tr>
</tbody>
</table>
</li>
<li>方向标志：简单字符串指令使用方向标志来决定ESI和EDI是自动增加还是自动减少。
<ul>
<li>方向标志位 DF＝0：ESI、EDI 自动增加；</li>
<li>方向标志位 DF＝1：ESI、EDI 自动减少。</li>
</ul>
</li>
<li>方向标志可以通过CLD和STD指令改变：
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">CLD</span>	<span style="color:#75715e">; 清除方向标志
</span><span style="color:#75715e"></span><span style="color:#66d9ef">STD</span>	<span style="color:#75715e">; 设置方向标志
</span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>MOVSB、MOVSW 和 MOVSD 指令</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">.data</span>
<span style="color:#a6e22e">source</span> <span style="color:#66d9ef">DWORD</span> <span style="color:#ae81ff">20</span> <span style="color:#66d9ef">DUP</span>(<span style="color:#ae81ff">0</span><span style="color:#66d9ef">FFFFFFFFh</span>)
<span style="color:#a6e22e">target</span> <span style="color:#66d9ef">DWORD</span> <span style="color:#ae81ff">20</span> <span style="color:#66d9ef">DUP</span>(<span style="color:#960050;background-color:#1e0010">?</span>)
<span style="color:#a6e22e">.code</span>
<span style="color:#a6e22e">cld</span>					       <span style="color:#75715e">; direction = forward
</span><span style="color:#75715e"></span><span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">ecx</span>,<span style="color:#66d9ef">LENGTHOF</span> <span style="color:#66d9ef">source</span>	<span style="color:#75715e">; set REP counter
</span><span style="color:#75715e"></span><span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">esi</span>,<span style="color:#66d9ef">OFFSET</span> <span style="color:#66d9ef">source</span>		<span style="color:#75715e">; ESI points to source
</span><span style="color:#75715e"></span><span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">edi</span>,<span style="color:#66d9ef">OFFSET</span> <span style="color:#66d9ef">target</span>		<span style="color:#75715e">; EDI points to target
</span><span style="color:#75715e"></span><span style="color:#66d9ef">rep</span> <span style="color:#66d9ef">movsd</span>			      	<span style="color:#75715e">; copy doublewords
</span></code></pre></div></li>
<li>
<p><strong>CMPSB、CMPSW 和 CMPSD 指令</strong><br>
隐含执行：源-目的，这与 CMP 指令相反</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">mov</span>  <span style="color:#66d9ef">esi</span>,<span style="color:#66d9ef">OFFSET</span> <span style="color:#66d9ef">source</span>
<span style="color:#a6e22e">mov</span>  <span style="color:#66d9ef">edi</span>,<span style="color:#66d9ef">OFFSET</span> <span style="color:#66d9ef">target</span>
<span style="color:#a6e22e">cld</span>				    <span style="color:#75715e">; direction = up
</span><span style="color:#75715e"></span><span style="color:#66d9ef">mov</span>  <span style="color:#66d9ef">ecx</span>,<span style="color:#66d9ef">count</span>	<span style="color:#75715e">; repetition counter
</span><span style="color:#75715e"></span><span style="color:#66d9ef">repe</span> <span style="color:#66d9ef">cmpsd</span>		  	<span style="color:#75715e">; repeat while equal
</span></code></pre></div></li>
<li>
<p><strong>SCASB、SCASW 和 SCASD 指令</strong></p>
<ul>
<li>将AL/AX/EAX中的值同目标内存(由DI寻址)中的字节、字或双字相比较。</li>
<li>例:扫描一个匹配字符：在字符串变量alpha中查找字母“F”
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">.data</span>
<span style="color:#a6e22e">alpha</span> <span style="color:#66d9ef">BYTE</span> <span style="color:#960050;background-color:#1e0010">&#34;</span><span style="color:#66d9ef">ABCDEFGH</span><span style="color:#960050;background-color:#1e0010">&#34;</span>,<span style="color:#ae81ff">0</span>
<span style="color:#a6e22e">.code</span>
  <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">edi</span>,<span style="color:#66d9ef">OFFSET</span> <span style="color:#66d9ef">alpha</span>	 <span style="color:#75715e">; EDI points to the string
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">al</span>,<span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#66d9ef">F</span><span style="color:#960050;background-color:#1e0010">&#39;</span>		 <span style="color:#75715e">; search for the letter F
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">ecx</span>,<span style="color:#66d9ef">LENGTHOF</span> <span style="color:#66d9ef">alpha</span> <span style="color:#75715e">; set the search count
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">cld</span>				 <span style="color:#75715e">; direction = up
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">repne</span> <span style="color:#66d9ef">scasb</span>		 <span style="color:#75715e">; repeat while not equal
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">jnz</span> <span style="color:#66d9ef">quit</span>			 <span style="color:#75715e">; quit if letter not found
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">dec</span> <span style="color:#66d9ef">edi</span>			 <span style="color:#75715e">; found: back up EDI
</span><span style="color:#75715e"></span><span style="color:#66d9ef">quit</span>:
</code></pre></div></li>
</ul>
</li>
<li>
<p><strong>STOSB、STOSW 和 STOSD 指令</strong></p>
<ul>
<li>将AL/AX/EAX的内容存储在EDI指向的内存单元中，同时EDI的值根据方向标志增加或减少。可与REP前缀联合使用。</li>
<li>例：将string1的每个字节初始化为0FFh。
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">.data</span>
<span style="color:#a6e22e">count</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#ae81ff">100</span>
<span style="color:#a6e22e">string1</span> <span style="color:#66d9ef">BYTE</span> <span style="color:#66d9ef">count</span> <span style="color:#66d9ef">DUP</span>(<span style="color:#960050;background-color:#1e0010">?</span>)
<span style="color:#a6e22e">.code</span>
  <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">al</span>,<span style="color:#ae81ff">0</span><span style="color:#66d9ef">FFh</span>		  <span style="color:#75715e">; value to be stored
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">edi</span>,<span style="color:#66d9ef">OFFSET</span> <span style="color:#66d9ef">string1</span>  <span style="color:#75715e">; ES:DI points to target
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">ecx</span>,<span style="color:#66d9ef">count</span>		  <span style="color:#75715e">; character count
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">cld</span>				  <span style="color:#75715e">; direction = forward
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">rep</span> <span style="color:#66d9ef">stosb</span>			  <span style="color:#75715e">; fill with contents of AL
</span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>LODSB、LODSW 和 LODSD 指令</strong></p>
<ul>
<li>从ESI指向的内存位置向AL/AX/EAX中装入一个值，同时ESI的值根据方向标志增加或减少。</li>
<li>一般不与REP前缀联合使用。</li>
</ul>
</li>
</ul>
<h4 id="二维数组">二维数组</h4>
<ul>
<li><strong>基址变址操作数</strong>：将两个寄存器的值相加(称为基址寄存器、变址寄存器)来产生偏移地址
<ul>
<li>保护模式程序中，可使用任意两个32位通用寄存器</li>
<li>实地址模式下，16位寄存器允许的组合是：<strong>[bx+si], [bx+di], [bp+si], [bp+di]</strong><br>
⚠️应尽量避免使用BP寄存器，除非要访问堆栈操作数</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">.data</span>
<span style="color:#a6e22e">array</span> <span style="color:#66d9ef">WORD</span> <span style="color:#ae81ff">1000</span><span style="color:#66d9ef">h</span>,<span style="color:#ae81ff">2000</span><span style="color:#66d9ef">h</span>,<span style="color:#ae81ff">3000</span><span style="color:#66d9ef">h</span>
<span style="color:#a6e22e">.code</span>
  <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ebx</span>,<span style="color:#66d9ef">OFFSET</span> <span style="color:#66d9ef">array</span>
  <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">esi</span>,<span style="color:#ae81ff">2</span>
  <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ax</span>,[<span style="color:#66d9ef">ebx</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#66d9ef">esi</span>]	<span style="color:#75715e">; AX = 2000h
</span></code></pre></div><ul>
<li>表格的例子

    <img src="https://s1.ax1x.com/2020/10/26/BKU6nf.png"  class="center"  style="border-radius: 8px; width:78%;"  />

</li>
</ul>
</li>
<li><strong>相对基址变址操作数</strong>:有效地址偏移＝偏移＋基址寄存器＋变址寄存器
<ul>
<li>几种常见的格式：
<ul>
<li><strong>[base + index + displacement]</strong></li>
<li><strong>displacement[base + index]</strong></li>
<li><strong>displacement[base][index]</strong></li>
</ul>
</li>
<li>偏移(Displacement)：变量的名字；常量表达式</li>
<li>基址、变址：
<ul>
<li>保护模式：任意32位寄存器</li>
<li>实地址模式：BX、BP；SI、DI</li>
</ul>
</li>
<li>表格的例子：tableB[ebx + esi]</li>
</ul>
</li>
</ul>
<h3 id="习题-1">习题</h3>
<h4 id="38">3.8</h4>
<p>在DATA为首地址的内存区域中存放100个无符号数，试编写程序找出其中最大的数，并将其放在KVFF中。</p>
<pre><code class="language-masm" data-lang="masm">stack segment stack
    db 512 dup(?)
stack ends 

data segment
    nums db 170, 248, 69, 67, 81, 104, 76, 178, 226, 201
    db 234, 230, 194, 85, 206, 92, 63, 28, 211, 237, 195, 240, 225
    db 126, 117, 173, 162, 78, 179, 252, 9, 202, 23, 152, 125, 32, 16
    db 86, 165, 27, 190, 137, 37, 172, 13, 228, 112, 146, 75, 225, 65 
    db 92, 150, 38, 77, 43, 233, 94, 88, 118, 60, 127, 214, 69, 44, 25 
    db 134, 137, 154, 209, 167, 32, 174, 13, 178, 65, 74, 35, 234, 95 
    db 70, 179, 98, 140, 185, 159, 14, 114, 105, 239, 137, 147, 227, 238
    db 228, 198, 135, 220, 203, 255
    KVFF db ?
data ends

code segment
assume CS:code, DS:data, SS:stack
start:
    mov ax, data
    mov ds, ax
    mov dl, 0
    mov si, OFFSET nums
    mov cx, 100
comp:
    cmp dl, BYTE PTR [si]
    jb  exch
L:
    inc si
    loop comp
    mov KVFF, dl
    mov ah, 4ch
    int 21h
exch:
    mov dl, BYTE PTR [si]
    jmp L
code ends
end start
</code></pre><h4 id="313">3.13</h4>
<p>试编写程序，给从内存40000H到4BFFFH的每个单元均写入55H，并逐个单元读出比较。若写入的与读出的完全一致，则将AL置7EH，否则将AL置81H。</p>
<pre><code class="language-masm" data-lang="masm">stack segment stack
    db 512 dup(?)
stack ends

code segment
assume cs:code, ss:stack
start:
    mov ax, 4000h
    mov ds, ax
    mov si, 0000h
    mov cx, 0BFFFh

write:
    mov BYTE PTR [si], 55h
    inc si
    loop write
    mov si, 0000h
    mov cx, 0BFFFh
read:
    cmp BYTE PTR [si], 55h
    jnz  not_equal

equal:
    inc si
    loop read
    mov al, 7eh
    mov ax, 4c00h
    int 21h

not_equal:
    mov al, 81h
    mov ax, 4c00h
    int 21h

code ends
end start
</code></pre><h2 id="总线技术">总线技术</h2>
<h3 id="总线概述">总线概述</h3>
<h4 id="总线的分类">总线的分类</h4>
<ul>
<li>按连接的层次
<ul>
<li>片内总线</li>
<li>元件级总线</li>
<li>系统总线（内总线）</li>
<li>通信总线（外总线、I/O总线）

    <img src="https://s1.ax1x.com/2020/11/01/B00gX9.png"  class="center"  style="width:80%"  />

</li>
</ul>
</li>
<li>按数据传输位数
<ul>
<li>并行总线</li>
<li>串行总线</li>
</ul>
</li>
</ul>
<h3 id="标准化总线">标准化总线</h3>
<h4 id="内总线">内总线</h4>
<ul>
<li><strong>ISA总线</strong>(Industry Stanrard Architechure)
<ul>
<li>ISA特点
<ul>
<li>支持8位、16位操作</li>
<li>将将XT与AT总线的运行速度提升至8MHz</li>
<li>更强调I/O处理能力：64KB的I/O空间、11级硬件中断、7级DMA通道</li>
<li>地址、数据多路复用</li>
<li>是多主控设备总线、带处理器的智能卡都可以成为ISA的主控设备</li>
<li>曾广泛流行，支持的厂商众多</li>
</ul>
</li>
<li>信号定义
<ul>
<li>数据总线为16位（支持8位、16位操作）
<ul>
<li>提速：$ \overline{0WS} $，零等待状态，也叫$ \overline{NOWS} $（No Wait State）</li>
<li>升位：$ \overline{MEMCS16}、\overline{IOCS16} $</li>
<li>位数可选：$ \overline{SBHE} $</li>
</ul>
</li>
<li>寻址能力达到16MB，地址、数据线不复用</li>
<li>中断扩充为11个（PC/XT位6个）</li>
<li>DMA扩充为7个（PC/XT位4个）</li>
<li>ISA是一种多主控总线：$\overline{MASTER} $</li>
<li>速度：CLK(B20, Output)<br>
4.77MHz-&gt;8.33MHz-&gt;12MHz</li>
</ul>
</li>
</ul>
</li>
<li><strong>PCI总线</strong>(Peripheral Component Interconnect Local Bus)
<ul>
<li>PCI总线的特点
<ul>
<li>不依赖于处理器</li>
<li>扩充性好、多总线共存</li>
<li>具有自动配置能力，支持即插即用（PnP）</li>
<li>数据、地址奇偶校验功能</li>
<li>数据宽度32位，可扩展为64位；2.0版本支持33MHz时钟，2.1版本增加了对66MHz总线操作的支持</li>
<li>信号复用，支持无限读写突发操作</li>
<li>支持多主控设备</li>
<li>适应性广</li>
<li>并行总线操作</li>
</ul>
</li>
<li>信号定义
<ul>
<li>PCI总线定义的信号可分为九类
<ul>
<li>系统信号</li>
<li>数据和地址信号</li>
<li>接口控制信号</li>
<li>仲裁信号</li>
<li>错误报告信号</li>
<li>中断信号</li>
<li>高速缓存支持信号</li>
<li>64位扩展信号</li>
<li>JTAG信号</li>
</ul>
</li>
<li>PCI总线定义的信号也可分为必备和可选两大类
<ul>
<li>主控设备需要49个必备信号<br>
目标设备需要47必备信号</li>
<li>可选信号线共51个，主要用于
<ul>
<li>64位扩展</li>
<li>中断请求</li>
<li>高速缓存支持 等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>PCIE总线</strong>（PCI Express）</li>
</ul>
<h4 id="外总线通信总线">外总线（通信总线）</h4>
<ul>
<li><strong>RS-232C串行通信接口</strong>
<ul>
<li>特点
<ul>
<li><strong>串行异步</strong>总线</li>
<li>传输信号线少
<ul>
<li>定义了20多个信号线</li>
<li>实际应用中一般只用到3至7条</li>
</ul>
</li>
<li>传输距离较远。一般为<strong>15米</strong></li>
<li>采用不归零编码（NRZ）和负逻辑：逻辑1为-15V至-3V，逻辑0为+3V至+15V</li>
<li>采用非平衡传输方式，即<strong>单端通信</strong></li>
<li>传输速率较低</li>
</ul>
</li>
<li>电气特性、引脚功能：25针/9针 D型连接器
<ul>
<li>信号
<ul>
<li>传送信息信号<br>
TxD：发送数据线 (DTE-&gt;DCE)<br>
RxD：接收数据线 (DTE&lt;-DCE)</li>
<li>联络信号<br>
RTS：请求发送 (DTE-&gt;DCE)<br>
CTS：清楚发送 (DTE&lt;-DCE)<br>
DTR：DTE准备就绪 (DTE-&gt;DCE)<br>
DSR：SCE准备就绪 (DTE&lt;-DCE)<br>
DCD：数据载波检测 (DTE&lt;-DCE)<br>
RI：振铃指示 (DTE&lt;-DCE)</li>
</ul>
</li>
<li>电平
<table>
<thead>
<tr>
<th></th>
<th>数据信号</th>
<th>控制信号</th>
</tr>
</thead>
<tbody>
<tr>
<td>逻辑1</td>
<td>-3~-15V（传号）</td>
<td>+3~+15V（接通，ON状态）</td>
</tr>
<tr>
<td>逻辑0</td>
<td>+3~+15V（空号）</td>
<td>-3~-15V（断开，OFF状态）</td>
</tr>
<tr>
<td></td>
<td>（一般为12V）</td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>例：信息格式<br>
传送ASCII码“C”（43H）

    <img src="https://s1.ax1x.com/2020/11/02/Br1M4J.png"  class="center"  style="width: 80%; border-radius: 5px;"  />

</li>
</ul>
</li>
<li>RS-232的应用
<ul>
<li>使用Modem连接</li>
<li>软硬件系统调试：控制台、超级终端</li>
<li>直接连接：计算机（DTE）&lt;-&gt; 计算机（DTE）
<ul>
<li>交叉连接方式</li>
<li>三线经济方式</li>
</ul>
</li>
</ul>
</li>
<li>RS423、RS422、RS485：
<ul>
<li>RS423：单端输出、差分接收（非平衡传输）
<ul>
<li>1200米 1Kbps</li>
<li>90米 100Kbps</li>
</ul>
</li>
<li>RS422、RS485：差分输出、差分接收（平衡差分传输）
<ul>
<li>1200米 100Kbps</li>
<li>100米 1Mbps</li>
<li>12米 10Mbps</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>USB总线</strong>（Universal Serial Bus）
<ul>
<li>USB总线各版本参数比较

    <img src="https://s1.ax1x.com/2020/11/02/BrdoY6.png"  class="center"  style="width:80%; border-radius:8px"  />


<ul>
<li>翻转不归零（NRZ-I）编码
<ul>
<li>当数据为0时，电平翻转；数据为1时，电平不翻转</li>
<li>比特填充技术：当数据中出现连续6个'1&rsquo;时就必须插入1个'0'</li>
<li>发送数据：并行数据-&gt;串行数据，比特填充，NRZI编码</li>
<li>接收数据：NRZI解码，去除填充比特，转换成并行数据</li>
</ul>
</li>
<li>8b/10b编码
<ul>
<li>传送的信息以每8比特为一组被编码为一个10比特的数据；接收端将10比特数据解码还原为8比特数据</li>
<li>目的：使得整个比特流中尽量保持了0和1的平衡</li>
<li>SATA、PCI-Express也使用了8b/10b编码</li>
<li>USB3.2使用128b/132b编码</li>
</ul>
</li>
</ul>
</li>
<li>对USB的需求
<ul>
<li>当时PC机I/O模式的缺点
<ul>
<li>PC外设日益丰富，接口、扩展槽有限；种类日益繁多的接口电缆线</li>
<li>I/O资源分配(I/O空间、IRQ、DMA)-&gt;接口卡一多，上述资源可能耗尽</li>
<li>热插拔、PnP的需求</li>
</ul>
</li>
<li>USB2.0的特点/优点
<ul>
<li>单一接口类型</li>
<li>每个USB总线支持127个外设</li>
<li>整个USB系统只用一个端口、一个中断-&gt;节省系统资源</li>
<li>支持热插拔、动态加载驱动程序；带电拔出后自动回收资源；PnP，自动配置</li>
<li>三种速率，适应不同类型外设</li>
<li>设备供电</li>
<li>四种传输类型
<ul>
<li>控制传输</li>
<li>同步传输</li>
<li>中断传输</li>
<li>批量传输</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>USB3.0</li>
</ul>
</li>
<li><strong>ATA总线</strong>
<ul>
<li>PATA</li>
<li>SATA</li>
</ul>
</li>
</ul>
<h3 id="总线的驱动和控制">总线的驱动和控制</h3>
<h4 id="总线竞争与负载">总线竞争与负载</h4>
<ul>
<li><strong>总线竞争</strong>：同一总线上，同一时刻，有两个或两个以上的器件输出其状态
<ul>
<li>TTL：此时总线上会是一种不高不低的非TTL电平，严重时会烧坏器件

    <img src="https://s1.ax1x.com/2020/11/10/BbHwOf.png"  class="center"  style="width:40%; border-radius:8px"  />

</li>
<li>对集电极开路输出：线与逻辑（Open Collector）

    <img src="https://s1.ax1x.com/2020/11/10/BbHBm8.png"  class="center"  style="width:40%; border-radius:8px"  />

</li>
<li>用三态电路严格，控制逻辑

    <img src="https://s1.ax1x.com/2020/11/10/BbHd6P.png"  class="center"  style="width:50%; border-radius:8px"  />

</li>
</ul>
</li>
<li><strong>总线的负载</strong>
<ul>
<li>直流负载
<ul>
<li>输出高电平时，驱动门的$ I_{OH} \ge \sum_{i=1}^{N}{IH_i} $</li>
<li>输出高电平时，驱动门的$ I_{OL} \ge \sum_{i=1}^{N}{IL_i} $</li>
</ul>
</li>
<li>交流负载：$ C_P \ge (\sum_{i=1}^{N}{C_{Ii}+电路板布线引入的电容+传输线引入的电容}) $

    <img src="https://s1.ax1x.com/2020/11/10/BbOi9J.png"  class="center"  style="width:75%; border-radius:8px"  />

</li>
</ul>
</li>
</ul>
<h4 id="总线驱动设计">总线驱动设计</h4>
<ul>
<li>
<p>几种常用的芯片</p>
<ul>
<li>单向驱动器（三态输出）

    <img src="https://s1.ax1x.com/2020/11/10/BbXoWQ.png"  class="center"  style="width:80%; border-radius:8px"  />

</li>
<li>双向驱动器（三态输出）

    <img src="https://s1.ax1x.com/2020/11/10/BbXTzj.png"  class="center"  style="width:85%; border-radius:8px"  />

</li>
<li>锁存器（三态输出）

    <img src="https://s1.ax1x.com/2020/11/10/BbXIJg.png"  class="center"  style="width:85%; border-radius:8px"  />

</li>
</ul>
</li>
<li>
<p>系统总线的驱动与控制</p>
</li>
<li>
<p>扩展插件板（卡）的板内驱动</p>
</li>
<li>
<p><strong>例题</strong></p>
<ul>
<li>某内存板，板内地址为A0000H～FFFFFH，试画出板内双向数据总线驱动与控制电路。
<ul>
<li>防止总线竞争原则：只有当CPU读本电路板内的内存地址时，才允许双向驱动器指向系统总线的三态门是导通的。</li>
<li>对板内内存地址进行分析，找出地址特征。A0000H～FFFFFH

    <img src="https://s1.ax1x.com/2020/11/10/BbzM6J.jpg"  class="center"  style="width:75%; border-radius:8px"  />

</li>
<li>设计译码电路，用来控制双向数据总线驱动器，使之满足防止总线竞争原则。

    <img src="https://s1.ax1x.com/2020/11/10/Bqp3i6.jpg"  class="center"  style="width:75%; border-radius:8px"  />

</li>
</ul>
</li>
<li>某微型机电路板上有内存C0000H～EFFFFH和接口A000H～BFFFH，试画出该电路板板内双向数据总线驱动与控制电路。（P128，例4.3）
<ul>
<li>防止总线竞争原则：只有当CPU读板内内存或读板内接口时，才允许双向数据驱动器指向系统总线的三态门是导通的。</li>
<li>地址分析（内存地址、接口地址）

    <img src="https://s1.ax1x.com/2020/11/10/Bq9DB9.jpg"  class="center"  style="width:70%; border-radius:8px"  />

</li>
<li>画驱动与控制电路

    <img src="https://s1.ax1x.com/2020/11/10/BqCF3T.jpg"  class="center"  style="width:90%; border-radius:8px"  />


<ul>
<li>几种可供选择的译码方式
<ul>
<li>基本门电路</li>
<li>译码器，如74LS138</li>
<li>译码PROM</li>
<li>CPLD、FPGA</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>采用8086 CPU的微机系统，其主存地址范围为C0000H～C7FFFH，由4块大小为8k8b的芯片构成主存板，试画出板内双向数据总线驱动控制电路及单向信号驱动电路。
<ul>
<li>主存地址分析

    <img src="https://s1.ax1x.com/2020/11/10/BqEuUH.jpg"  class="center"  style="width:90%; border-radius:8px"  />

</li>
<li>双向数据总线驱动控制电路及单向信号驱动电路

    <img src="https://s1.ax1x.com/2020/11/10/BqkuLD.jpg"  class="center"  style="width:90%; border-radius:8px"  />

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总线设计中的工程问题">总线设计中的工程问题</h3>
<h4 id="总线交叉串扰">总线交叉串扰</h4>
<ul>
<li>减少总线长度</li>
<li>增加总线间的距离</li>
<li>降低总线上的负载</li>
<li>降低总线信号的工作频率</li>
<li>两条信号线之间加一条地线</li>
<li>减少总线的平行走向</li>
<li>圆滑脉冲信号的边缘</li>
<li>采用双绞线</li>
</ul>
<h4 id="总线的延时">总线的延时</h4>
<ul>
<li>尽量减少总线长度</li>
<li>采用延时小、输出输出电容小、驱动能力强的元器件</li>
<li>需要同步的信号线，布线时候应匹配长度</li>
</ul>
<h4 id="总线信号的反射">总线信号的反射</h4>
<ul>
<li>在满足系统功能的前提下，降低传输信号的频率</li>
<li>尽量使信号源内阻、总线特性阻抗、负载阻抗三者相匹配</li>
<li>限制总线长度</li>
</ul>
<h3 id="pc中的总线">PC中的总线</h3>
<h4 id="8086微处理器16位微机isa总线">8086微处理器16位微机：ISA总线</h4>
<ul>
<li>总线信号依据8086处理器信号定义</li>
<li>8086处理器与ISA总线可以实现直接对接</li>
<li>利用ISA总线可以直接读写主存或I/O接口</li>
</ul>
<h4 id="80386微处理器32位微机与cpu无关的pci总线">80386微处理器32位微机：与CPU无关的PCI总线</h4>
<ul>
<li>PCI总线具有较快的数据传输速率</li>
<li>PCI总线支持即插即用和热插拔</li>
<li>基于PCI总线的微机系统还支持多总线结构，进而使系统具有一定的并行操作能力</li>
</ul>
<h2 id="存储技术">存储技术</h2>
<h3 id="概述">概述</h3>
<h4 id="存储器的分类">存储器的分类</h4>

    <img src="https://s1.ax1x.com/2020/11/11/BvPyrV.jpg"  class="center"  style="width: 70% ;"  />


<h4 id="主要性能指标">主要性能指标</h4>
<ul>
<li>容量</li>
<li>速度：存取时间</li>
<li>成本：价格</li>
</ul>
<h3 id="常用存储器芯片及连接使用">常用存储器芯片及连接使用</h3>
<h4 id="静态随机读写存储器sram及接口设计">静态随机读/写存储器（SRAM）及接口设计</h4>
<ul>
<li>
<p>静态随机读写存储器（Static Random Access Memory</p>
</li>
<li>
<p>分类</p>
<ul>
<li>同步型</li>
<li>异步型</li>
</ul>
</li>
<li>
<p><strong>异步SRAM</strong></p>
<ul>
<li><strong>典型芯片</strong>：6264（8K $\times $ 8bit）
<ul>
<li>引线

    <img src="https://s1.ax1x.com/2020/11/11/BvAofe.jpg"  class="center"  style="width: 40% ;"  />

</li>
<li>工作过程、时序
<ul>
<li>写入时序

    <img src="https://s1.ax1x.com/2020/11/11/BvEWcj.jpg"  class="center"  style="width: 70% ;"  />

</li>
<li>读出时序

    <img src="https://s1.ax1x.com/2020/11/11/BvEfjs.jpg"  class="center"  style="width: 70% ;"  />

</li>
</ul>
</li>
</ul>
</li>
<li><strong>连接使用</strong>
<ul>
<li>全地址译码与部分地址译码
<ul>
<li>SRAM 6264全地址译码连接

    <img src="https://s3.ax1x.com/2020/11/11/BvV6q1.jpg"  class="center"  style="width: 70% ;"  />

</li>
<li>SRAM 6264部分地址译码连接

    <img src="https://s3.ax1x.com/2020/11/11/BvVyrR.jpg"  class="center"  style="width: 70% ;"  />

</li>
</ul>
</li>
<li>译码电路的选择
<ul>
<li>利用译码芯片

    <img src="https://s3.ax1x.com/2020/11/11/BveU9U.jpg"  class="center"  style="width: 100% ;"  />



    <img src="https://s3.ax1x.com/2020/11/11/Bvea3F.jpg"  class="center"  style="width: 100% ;"  />

</li>
<li>使用ROM作译码器<br>
现在要用4片6264构成一个存储容量为32KB的存储器，其地址空间为E0000H～E7FFFH。用一块512×4的PROM芯片63S241作为ROM译码器

    <img src="https://s3.ax1x.com/2020/11/11/BvljJI.gif"  class="center"  style="width: 100% ;"  />

</li>
<li>利用数字比较器作译码器

    <img src="https://s3.ax1x.com/2020/11/11/Bv10TH.jpg"  class="center"  style="width: 100% ;"  />

</li>
<li>利用PLD做译码器</li>
</ul>
</li>
</ul>
</li>
<li>存取时间
<ul>
<li>控制信号的连接：8088/8086 最小模式、最大模式$ M/\overline{IO}、\overline{RD}、\overline{WR} =&gt; \overline{MEMR}、\overline{MEMW} $</li>
<li>例：已知8088微处理器时钟为4.77MHz，地址延时时间$t_{da}＝110ns$，存储系统各种附加的延时时$t_D$＝200ns。问：用存取周期为250ns的存储芯片能否满足系统要求？<br>
$$
\begin{align}
t(R,W)+t_{da}+t_D &amp;{\le} 3T \cr
t(R,W) &amp;{\le} 3T－ t_{da}－ t_{D} \cr
3×210－200－110 &amp;＝ 320ns \cr
\end{align}
$$
为存储器提供的存取时间<br>
存储器要求的存取时间为250ns → 能满足系统要求</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="只读存储器rom及接口设计">只读存储器（ROM）及接口设计</h4>
<ul>
<li>
<p><strong>EPROM</strong>（紫外线可擦除只读存储器）：2764芯片（8K$\times 8bit）</p>
<ul>
<li>引线
<ul>
<li>A12~A0</li>
<li>D7~D0</li>
<li>$\overline{CE}$：片选</li>
<li>$\overline{OE}$：数据输出允许</li>
<li>$\overline{PGM}$：编程时：编程脉冲输入；读时：“1”</li>
</ul>
</li>
<li>连接：若利用全地址译码将EPROM 2764接在首地址为A0000H的内存区，试画连接图

    <img src="https://i.postimg.cc/434VS3rF/1.jpg"  class="center"  style="width: 60% ;"  />

</li>
<li>编程
<ul>
<li>擦除：紫外线 15～20min → 每单元内容均为FFH</li>
<li>EPROM编程

    <img src="https://s3.ax1x.com/2020/11/11/BvwFJS.jpg"  class="center"  style="width: 90% ;"  />



    <img src="https://s3.ax1x.com/2020/11/11/Bvwii8.jpg"  class="center"  style="width: 90% ;"  />



    <img src="https://s3.ax1x.com/2020/11/11/BvwCIf.jpg"  class="center"  style="width: 90% ;"  />

</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>EEPROM</strong></p>
<ul>
<li>典型EERROM芯片介绍：98C64A
<ul>
<li>优点：可单字节随机读写（不需擦除，直接读写）</li>
<li>缺点：存储密度高，单位成本高</li>
</ul>
</li>
<li>连接使用：将55H写满98C64A

    <img src="https://s3.ax1x.com/2020/11/16/Dkq6XR.jpg"  class="center"  style="width: 80% ;"  />



    <img src="https://s3.ax1x.com/2020/11/16/DkO9PO.jpg"  class="center"  style="width: 80% ;"  />

</li>
</ul>
</li>
<li>
<p><strong>闪存EEPROM：FLASH</strong></p>
<ul>
<li>NOR型
<ul>
<li>独立数据、地址总线，可以随机<strong>快速读取</strong></li>
<li><strong>读操作速度快，擦除、编程速度慢</strong></li>
</ul>
</li>
<li>NAND型
<ul>
<li>以<strong>页</strong>(256或512B)为单位读/编程</li>
<li>以<strong>块</strong>(4K、8K、16K)为单位擦除（最多4ms）</li>
<li>串行读取快、<strong>随机读取慢</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="其他存储器">其他存储器</h4>
<ul>
<li>双端口存储器</li>
<li>先进先出（FIFO）存储器</li>
<li>铁电存储器（FRAM）</li>
</ul>
<h3 id="intel-1632位微机系统的主存设计sram部分">Intel 16/32位微机系统的主存设计（SRAM部分）</h3>
<h4 id="80868088处理器的内存接口">8086、8088处理器的内存接口</h4>
<ul>
<li>
<p>存储器SRAM 6116（$ 2K\times 8bit）$ 与8088的8位总线连接</p>
</li>
<li>
<p>SRAM 6116与8086的16位总线连接</p>
<ul>
<li>$ \overline{A0}$选偶地址</li>
<li>$ \overline{BHE} $选奇地址</li>
</ul>
</li>
<li>
<p>存储器的字扩充

    <img src="https://s3.ax1x.com/2020/11/11/BvYiPH.jpg"  class="center"  style="width: 80% ;"  />

</p>
</li>
<li>
<p>存储器的位扩充

    <img src="https://s3.ax1x.com/2020/11/11/BvYnZ8.jpg"  class="center"  style="width: 80% ;"  />

</p>
<ul>
<li>6264与8086系统总线的连接

    <img src="https://s3.ax1x.com/2020/11/11/BvYfFe.jpg"  class="center"  style="width: 90% ;"  />

</li>
</ul>
</li>
</ul>
<h4 id="8038680486的内存接口">80386、80486的内存接口</h4>
<ul>
<li>与内存接口相关的信号
<ul>
<li>地址信号<strong>A2～A31</strong>共30个地址信号，其编码可寻址1G个32位的存储单元。这里没有A0和A1，这两个信号已在80386、80486内部译码，用于产生4个体选择信号。</li>
<li>体选择信号$ \overline{BE0}～\overline{BE3} $</li>
<li>32位的数据信号<strong>D0～D31</strong>分为4个字节，分别是D0～D7、D8～D15、D16～D23 和 D24～D31。</li>
<li>控制信号$ M/\overline{IO} $</li>
<li>$D/\overline{C}$（数据/控制）信号，低电平为<strong>处理器中止或正在响应中断</strong>，高电平表示正在<strong>传送数据</strong>；</li>
<li>$W/\overline{R}$（读/写）信号，低电平表示读内存或接口，高电平表示写内存或接口

    <img src="https://s3.ax1x.com/2020/11/11/BvNJET.jpg"  class="center"  style="width: 90% ;"  />

</li>
</ul>
</li>
</ul>
<h4 id="pentium处理器的内存组织">Pentium处理器的内存组织</h4>
<h3 id="动态随机读写存储器dram及接口设计">动态随机读/写存储器（DRAM）及接口设计</h3>
<h4 id="简单异步dram">简单异步DRAM</h4>
<ul>
<li>引线
<ul>
<li>地址线复用：先输入行地址，再输入列地址</li>
<li>$\overline{WE}$写允许</li>
<li>$D_{IN}、D_{OUT} $</li>
</ul>
</li>
<li>工作方式及时序
<ul>
<li>读操作

    <img src="https://s3.ax1x.com/2020/11/16/DATxuq.jpg"  class="center"  style="width: 75% ;"  />

</li>
<li>写操作
<ul>
<li>提前写

    <img src="https://s3.ax1x.com/2020/11/16/DA718H.jpg"  class="center"  style="width: 75% ;"  />

</li>
<li>读变写

    <img src="https://s3.ax1x.com/2020/11/16/DAX0iV.jpg"  class="center"  style="width: 75% ;"  />

</li>
</ul>
</li>
</ul>
</li>
<li>刷新：2-4ms刷新一次</li>
<li>连接使用/接口设计
<ul>
<li>行列信号的形成

    <img src="https://s3.ax1x.com/2020/11/16/DAjcp8.jpg"  class="center"  style="width: 75% ;"  />

</li>
<li>读写</li>
<li>刷新

    <img src="https://s3.ax1x.com/2020/11/16/DAvEBd.jpg"  class="center"  style="width: 75% ;"  />

</li>
</ul>
</li>
</ul>
<h4 id="同步动态存储器sdram">同步动态存储器SDRAM</h4>
<ul>
<li>
<p>概述</p>
<ul>
<li>SDR SDRAM（Single Data Rate Synchronous Dynamic RAM）：单倍速率同步动态随机存储器
<ul>
<li>只在时钟的上升沿传输命令、地址和数据</li>
</ul>
</li>
<li>DDR(Double Date Rate)
<ul>
<li>时钟上升沿、下降沿各传送一次数据</li>
<li>从DDR2开始，接口的频率开始高于存储单元的核心频率

    <img src="https://s3.ax1x.com/2020/11/20/DM4yZ9.jpg"  class="center"  style="width: 100% ;"  />

</li>
</ul>
</li>
<li>SDRAM和标准DRAM的主要不同
<ul>
<li>同步和异步</li>
<li>内部组织结构
<ul>
<li>SDRAM内部分体</li>
<li>标准的DRAM可以看成内部只有一个体的SDRAM</li>
</ul>
</li>
<li>读写方式不同
<ul>
<li>SDRAM具有突发读写能力
<ul>
<li>突发(Burst)是指在同一行中相邻的存储单元连续进行数据传输的方式。</li>
<li>连续传输所涉及到的存储单元(列)的数量就是突发长度(Burst Lengths，BL)</li>
</ul>
</li>
</ul>
</li>
<li>智能化
<ul>
<li>在SDRAM芯片内部设置有<strong>模式寄存器</strong></li>
<li>一般的标准DRAM只有一种工作模式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>典型的SDRAM芯片(三星K4S511632D(32M×16 bit SDRAM))</p>
<ul>
<li>引线
<ul>
<li>地址输入
<ul>
<li>行地址：RA0~RA12</li>
<li>列地址：CA0~CA9</li>
</ul>
</li>
<li>bank地址输入</li>
<li>数据输入/输出</li>
<li>输出允许</li>
</ul>
</li>
<li>常用指标
<ul>
<li>容量：存储单元×体×每单元存储位数</li>
<li>时钟周期</li>
<li>存取时间</li>
<li>CAS的延迟时间（Cas latency）</li>
<li>综合性能的评价：总延迟时间=系统时钟周期×CL模式数+存取时间</li>
</ul>
</li>
<li>时序

    <img src="https://s3.ax1x.com/2020/11/22/D87VQs.jpg"  class="center"  style="width: 100% ;"  />

</li>
</ul>
</li>
<li>
<p>SDRAM控制器</p>
<ul>
<li>实现方式
<ul>
<li>以<strong>南北桥芯片组</strong>为主要核心的PC机系统</li>
<li>某些为微处理器中<strong>集成</strong>了SDRAM控制器</li>
<li><strong>设计</strong>与CPU或系统总线连接的独立SDRAM控制器，SDRAM芯片连接在SDRAM控制器上</li>
</ul>
</li>
<li>SDRAM的基本操作
<ul>
<li>对SDRAM的访问的三种情况
<ul>
<li>当前访问的行所在的存储体中，<strong>行缓冲器</strong>是关闭的
<ul>
<li>发送<strong>激活</strong>命令</li>
<li>发送<strong>读写</strong>命令和<strong>列地址</strong></li>
<li>读写延迟中等</li>
</ul>
</li>
<li>当前访问的行的数据，刚好保存在相应存储体的<strong>行缓冲器</strong>中
<ul>
<li>直接发送<strong>读/写命令</strong>和<strong>列地址</strong></li>
<li>读写延迟最小</li>
</ul>
</li>
<li>当前访问的行所在的存储体中，<strong>行缓冲器打开</strong>，<strong>存的是另一个行的数据</strong>
<ul>
<li>先发送<strong>Percharge</strong>或<strong>Precharge All</strong>命令关闭行缓冲器</li>
<li>再发送<strong>激活</strong>命令激活该行</li>
<li>最后发送<strong>读/写</strong>和<strong>列地址</strong></li>
<li><strong>读/写</strong>延迟最大</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>SDRAM控制器的基本组成
<ul>
<li>连续内存地址映射

    <img src="https://s3.ax1x.com/2020/11/22/DGNatg.jpg"  class="center"  style="width: 90% ;"  />

</li>
<li>交错内存地址映射：将连续的逻辑地址映射到不同的存储体中

    <img src="https://s3.ax1x.com/2020/11/22/DGNWh4.jpg"  class="center"  style="width: 90% ;"  />

</li>
</ul>
</li>
<li>SDRAM的控制优化
<ul>
<li>行关闭优先策略（Close-Page Policy）：行激活、列读/写、预充电</li>
<li>行打开优先策略（Open-Page Policy）
<ul>
<li>访问请求<strong>空间局部性很好</strong>，大大<strong>减少读写延迟</strong></li>
<li>访问请求<strong>空间分布很分散</strong>，造成<strong>较大读写延迟</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="ddr-sdram">DDR SDRAM</h4>
<ul>
<li>DDR SDRAM与SDRAM的不同
<ul>
<li>初始化</li>
<li>时钟</li>
<li>数据选取脉冲</li>
<li>写入延时</li>
<li><strong>突发长度和写入掩码</strong>
<ul>
<li>DDR SDRAM，突发长度只有2、4、8，没有SDRAM的<strong>随机存取的操作</strong>和<strong>全页触发方式</strong>；同时，突发长度的定义不再指所连续寻址的存储单元数量，而是指<strong>连续的传输周期数</strong></li>
<li>对于突发写入，如果其中有不想存取的数据，仍可以使用<strong>DM信号进行屏蔽</strong></li>
</ul>
</li>
<li>延迟锁定回路</li>
</ul>
</li>
</ul>
<h3 id="习题-2">习题</h3>
<h4 id="55">5.5</h4>
<p>已有两片6116，现在欲将它们连接到8088系统中去，其地址范围为40000H~40FFFH，试画连接电路图，写入某数据并读出与之比较；如有错，则在DL中写入01H；若每个单元均对，则在DL中写入EEH，试编写此检测程序。</p>
<p>
    <img src="https://s3.ax1x.com/2020/11/18/DnMO7F.png"  class="center"  style="width: 80% ;"  />



    <img src="https://s3.ax1x.com/2020/11/18/DnQy4J.png"  class="center"  style="width: 80% ;"  />



    <img src="https://s3.ax1x.com/2020/11/18/DnMvtJ.png"  class="center"  style="width: 80% ;"  />



    <img src="https://s3.ax1x.com/2020/11/18/DnMxh9.png"  class="center"  style="width: 80% ;"  />

</p>
<h4 id="510">5.10</h4>
<p>将4片6264连接到8086系统总线上，要求内存地址范围为7000H~77FFFH，画出连接图。</p>
<p>
    <img src="https://s3.ax1x.com/2020/11/18/DnMjk4.png"  class="center"  style="width: 80% ;"  />



    <img src="https://s3.ax1x.com/2020/11/18/DnQSpR.png"  class="center"  style="width: 100% ;"  />

</p>
<h4 id="516">5.16</h4>
<p>现有容量为32K×4bit的SRAM芯片。<br>
在8086系统中，利用这样的芯片构成从88000H～97FFFH的内存，画出最大模式下包括总线驱动在内的此芯片与系统总线的连接图（译码器件自行选择）</p>
<p>
    <img src="https://s3.ax1x.com/2020/11/18/DnIgJK.png"  class="center"  style="width: 80% ;"  />



    <img src="https://s3.ax1x.com/2020/11/18/DnIyIx.png"  class="center"  style="width: 80% ;"  />



    <img src="https://s3.ax1x.com/2020/11/18/DnIci6.png"  class="center"  style="width: 80% ;"  />

</p>
<h2 id="输入输出技术">输入输出技术</h2>
<h3 id="io概述">I/O概述</h3>
<h4 id="基本输入输出方法">基本输入/输出方法</h4>
<ul>
<li><strong>程序控制</strong>I/O方式
<ul>
<li><strong>无条件</strong>传送方式：输入接口、输出接口</li>
<li><strong>查询</strong>方式：单外设、多外设</li>
<li><strong>中断</strong>防守</li>
</ul>
</li>
<li><strong>DMA</strong>（直接存储器）方式</li>
</ul>
<h4 id="io接口概述">I/O接口概述</h4>
<ul>
<li>I/O接口能做什么
<ul>
<li>提供信息通道</li>
<li>进行数据格式转换</li>
<li>CPU和外设速度匹配</li>
<li>负载匹配</li>
<li>时序匹配</li>
<li>总线隔离</li>
<li>提供中断、DMA能力</li>
</ul>
</li>
<li>外设接口与端口
<ul>
<li>统一编址的优点
<ul>
<li>CPUduiI/O端口的读写操作可是使用全部<strong>存储器</strong>的读/写数据操作指令</li>
<li>内存与外设地址的分配可以用统一的分配图</li>
<li>不需要专门的<strong>输入、输出</strong>操作<strong>指令</strong></li>
</ul>
</li>
<li>统一编址的缺点
<ul>
<li>使得系统中<strong>实际</strong>可以<strong>直接寻址的内存单元数减少</strong></li>
<li>给<strong>检修、维护</strong>增加了难度</li>
<li>一般系统中I/O端口数远小于内存单元数，所以统一编址使得<strong>指令代码较长</strong>，<strong>读/写执行时间也较长</strong></li>
<li>Motorola的M68系列采用<strong>统一编址</strong>，Intel的86x86系列CPU采用<strong>独立编址</strong>方式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="io端口地址译码">I/O端口地址译码</h4>

    <img src="https://s3.ax1x.com/2020/11/23/DYDNqJ.jpg"  class="center"  style="width: 80% ;"  />


<h4 id="基本的并行输入三态门输出锁存器接口">基本的并行输入（三态门）/输出（锁存器）接口</h4>
<ul>
<li>并行输入接口

    <img src="https://s3.ax1x.com/2020/11/23/DYrKyD.jpg"  class="center"  style="width: 80% ;"  />

</li>
<li>并行输出接口

    <img src="https://s3.ax1x.com/2020/11/23/DYsd9x.jpg"  class="center"  style="width: 90% ;"  />

</li>
</ul>
<h3 id="程序查询io方式">程序查询I/O方式</h3>
<h4 id="无条件传送方式">无条件传送方式</h4>
<h4 id="查询方式">查询方式</h4>

    <img src="https://s3.ax1x.com/2020/11/23/DYyBin.jpg"  class="center"  style="width: 40% ;"  />


<p>
    <img src="https://s3.ax1x.com/2020/11/23/DYfU1A.jpg"  class="center"  style="width: 70% ;"  />



    <img src="https://s3.ax1x.com/2020/11/23/DYfa6I.jpg"  class="center"  style="width: 100% ;"  />



    <img src="https://s3.ax1x.com/2020/11/23/DYfdXt.jpg"  class="center"  style="width: 90% ;"  />

</p>
<ul>
<li>多外设的查询控制

    <img src="https://s3.ax1x.com/2020/11/23/DYhZHf.jpg"  class="center"  style="width: 70% ;"  />



    <img src="https://s3.ax1x.com/2020/11/23/DYhVDP.jpg"  class="center"  style="width: 70% ;"  />

</li>
</ul>
<h3 id="中断方式">中断方式</h3>
<h4 id="80868088中断系统">8086/8088中断系统</h4>
<ul>
<li>中断源类型
<ul>
<li>与中断有关的控制线：$ NMI、INTR、\overline{INTA} $</li>
<li>8088系统中的中断源
<ul>
<li>内部中断
<ul>
<li><strong>除法溢出</strong>：类型号为<strong>0</strong></li>
<li><strong>单步中断</strong>：类型号为<strong>1</strong></li>
<li><strong>断点中断</strong>：类型号为<strong>3</strong></li>
<li><strong>溢出中断</strong>：类型号为<strong>4</strong></li>
<li><strong>软件中断</strong>：即INT n指令</li>
</ul>
</li>
<li>外部中断
<ul>
<li>非屏蔽中断<strong>NMI</strong>：类型号为<strong>2</strong>，不可用软件屏蔽，CPU必须响应它</li>
<li>可屏蔽中断<strong>INTR</strong>：类型号由<em>PIC</em>提供。IF=1时CPU才能响应它</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>中断向量表（IVT）
<ul>
<li>用于存放各类中断服务程序的入口地址（段和偏移）</li>
<li>表的地址位于内存的00000H~003FFH，大小为1KB，共256个入口</li>
<li>每个入口占4 Bytes</li>
<li>中断向量在IVT中的存放地址 = 4 * 中断类型号</li>
</ul>
</li>
</ul>
<h4 id="可编程中断控制器8259">可编程中断控制器8259</h4>
<ul>
<li>
<p>8259内部结构

    <img src="https://s3.ax1x.com/2020/11/25/DdpJoV.jpg"  class="center"  style="width: 100% ;"  />

</p>
<ul>
<li>中断请求寄存器IRR</li>
<li>中断服务寄存器ISR</li>
<li>中断屏蔽寄存器IMR</li>
<li>中断优先权判别电路</li>
</ul>
</li>
<li>
<p>引脚功能

    <img src="https://s3.ax1x.com/2020/11/25/DdCoPf.jpg"  class="center"  style="width: 80% ;"  />

</p>
</li>
<li>
<p>8259工作方式</p>
<ul>
<li>中断结束方式
<ul>
<li>非自动：在中断程序中提供EOI命令</li>
<li>自动：无需EOI命令、第2个$\overline{INTA}$后沿</li>
</ul>
</li>
<li>缓冲方式：缓冲、非缓冲</li>
<li>嵌套方式
<ul>
<li>一般嵌套：单片使用；级联方式从属</li>
<li>特殊嵌套：级联方式主控制器</li>
</ul>
</li>
<li>屏蔽方式：一般屏蔽、特殊屏蔽</li>
<li>优先级规定：固定优先级、循环优先级

    <img src="https://s3.ax1x.com/2020/11/25/DdFhZ9.jpg"  class="center"  style="width: 80% ;"  />

</li>
</ul>
</li>
<li>
<p>8259级联

    <img src="https://s3.ax1x.com/2020/11/25/DdEdqe.jpg"  class="center"  style="width: 90% ;"  />

</p>
</li>
<li>
<p>8259编程使用</p>
<ul>
<li>内部寄存器的寻址方法

    <img src="https://s3.ax1x.com/2020/11/25/DdVbtA.jpg"  class="center"  style="width: 90% ;"  />

</li>
<li>初始化命令字ICW
<ul>
<li>注意
<ul>
<li>写ICW1意味着重新初始化8259</li>
<li>写ICW1后，8259的状态如下
<ul>
<li>清除ISR和IMR（全0）</li>
<li>将中断<strong>优先级</strong>设置为初始状态</li>
<li>设置为<strong>一般屏蔽</strong>方式</li>
<li>采用<strong>非自动中断结束</strong>方式</li>
<li>状态读出逻辑预置为读IRR</li>
</ul>
</li>
</ul>
</li>
<li>ICW1：初始化字

    <img src="https://s3.ax1x.com/2020/11/25/DdeDIJ.jpg"  class="center"  style="width: 80% ;"  />

</li>
<li>ICW2：中断向量码

    <img src="https://s3.ax1x.com/2020/11/25/DdmVwF.jpg"  class="center"  style="width: 80% ;"  />

</li>
<li>ICW3：级联控制字

    <img src="https://s3.ax1x.com/2020/11/25/Ddmflq.jpg"  class="center"  style="width: 80% ;"  />

</li>
<li>ICW4：中断结束方式字

    <img src="https://s3.ax1x.com/2020/11/25/DduMqK.jpg"  class="center"  style="width: 80% ;"  />

</li>
</ul>
</li>
<li>操作命令字OCW
<ul>
<li>OCW1：中断屏蔽字

    <img src="https://s3.ax1x.com/2020/11/25/DdQ0Z6.jpg"  class="center"  style="width: 80% ;"  />

</li>
<li>OCW2：中断结束和优先级循环

    <img src="https://s3.ax1x.com/2020/11/25/DdlQld.jpg"  class="center"  style="width: 100% ;"  />

</li>
<li>OCW3：屏蔽方式和读出控制字

    <img src="https://s3.ax1x.com/2020/11/25/Dd1w4O.jpg"  class="center"  style="width: 100% ;"  />

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="中断方式及实现方法">中断方式及实现方法</h4>
<ul>
<li>连接8259

    <img src="https://s3.ax1x.com/2020/11/25/Dd1bbq.jpg"  class="center"  style="width: 100% ;"  />

</li>
<li>编写中断初始化程序
<ul>
<li>初始化8259

    <img src="https://s3.ax1x.com/2020/11/25/Dd8Vwq.jpg"  class="center"  style="width: 80% ;"  />



    <img src="https://s3.ax1x.com/2020/11/25/Dd8Emn.jpg"  class="center"  style="width: 80% ;"  />



    <img src="https://s3.ax1x.com/2020/11/25/Dd8kOs.jpg"  class="center"  style="width: 80% ;"  />

</li>
<li>设置中断向量表

    <img src="https://i.postimg.cc/MKC6z9jn/1.jpg"  class="center"  style="width: 80% ;"  />

</li>
<li>中断服务程序框架

    <img src="https://i.postimg.cc/MZhHG6CZ/1.jpg"  class="center"  style="width: 80% ;"  />

</li>
</ul>
</li>
</ul>
<h3 id="直接存取器dma方式">直接存取器（DMA）方式</h3>
<h4 id="dma工作过程">DMA工作过程</h4>
<ul>
<li>通过特殊硬件<strong>DMA控制器</strong>实现，传输速率高</li>
<li>外设<strong>直接</strong>与存储器进行数据交换，CPU不再作为中介者</li>
<li>总线由DMA控制器（DMAC）进行控制，CPU放弃总线控制权，内存/外设的<strong>地址</strong>和<strong>读写控制信号</strong>均由DMAC提供</li>
</ul>

    <img src="https://i.postimg.cc/dttHLFrX/1.jpg"  class="center"  style="width: 80% ;"  />


<h3 id="习题-3">习题</h3>
<h4 id="66">6.6</h4>
<p>叙述8086/88软件中断指令INT n的执行过程</p>
<ul>
<li>CPU<strong>取INT n指令</strong>，经指令译码获知这是一条中断指令，且该软件中断的中断向量码为n</li>
<li>将<strong>PSW、CS、IP</strong>压入<strong>堆栈</strong>保护起来，并<strong>关中断</strong></li>
<li>$ n \times 4 $ 得到中断向量表地址，从该地址开始的顺序两个字节的内容送IP，下两个字节的内容送CS，即$n \times 4\to IP,(n\times4+2)\to CS $</li>
<li>开始执行<strong>中断服务</strong>程序。（中断服务程序的入口地址早已填入中断向量表中）</li>
<li>中断服务程序的最后一条指令IRET，从堆栈恢复IP、CS、PSW，<strong>中断返回</strong></li>
</ul>
<h4 id="68">6.8</h4>
<p>输入接口地址为04E5H，输出接口地址为E504H。
编程序：
若输入接口的bit3、bit4和bit7同时为1，将以DATA为首地址的10个内存数据连续由输出接口输出，若不满足条件则等待</p>

    <img src="https://i.postimg.cc/xCzqpjjx/Fia-VVso5-Pa9-EP-Ano3fe0-AOcni-Xj.png"  class="center"  style="width: 60% ;"  />


<h4 id="69">6.9</h4>
<p>若：系统只有一片8259，8259地址为E010H和E011H，允许8个中断源边沿触发，不需要缓冲，以一般嵌套方式工作，中断向量为40H，非自动EOI方式</p>
<ol>
<li>编写初始化程序

    <img src="https://i.postimg.cc/pLqTWWWT/6-9-1.png"  class="center"  style="width: 60% ;"  />



    <img src="https://i.postimg.cc/zfvf3svk/6-9-2.png"  class="center"  style="width: 60% ;"  />

</li>
<li>若允许中断嵌套，编写中断服务程序框架，包括返回前发送EOI命令。中断服务程序名称为IPROC40

    <img src="https://i.postimg.cc/76TYnSgG/6-9-3.png"  class="center"  style="width: 60% ;"  />

</li>
<li>编程序，将上述中断处理程序的入口地址填入中断向量表

    <img src="https://i.postimg.cc/HLNkM671/6-9-4.png"  class="center"  style="width: 80% ;"  />

</li>
</ol>
<h2 id="常用接口器件">常用接口器件</h2>
<p>计算机和外设之间如何通过接口传送数据（非DMA）

    <img src="https://i.postimg.cc/ZqQ3YDm0/1.jpg"  class="center"  style="width: 60% ;"  />



    <img src="https://i.postimg.cc/QCGT19H3/2.jpg"  class="center"  style="width: 60% ;"  />



    <img src="https://i.postimg.cc/C5GfNhqf/3.jpg"  class="center"  style="width: 60% ;"  />

</p>
<h3 id="可编程并行接口8255">可编程并行接口8255</h3>
<h4 id="内部结构及外部总线">内部结构及外部总线</h4>

    <img src="https://i.postimg.cc/rFbLJ1qx/1.jpg"  class="center"  style="width: 90% ;"  />


<h4 id="8255的工作方式">8255的工作方式</h4>
<ul>
<li>工作方式0：基本输入输出方式
<ul>
<li>A口（PA0~PA7）：输入（无锁存能力）或输出（有锁存能力）</li>
<li>B口（PB0~PB7）：输入（无锁存能力）或输出（有锁存能力）</li>
<li>C口（PC4~PC7）：输入（无锁存能力）或输出（有锁存能力）</li>
<li>C口（PC0~PC3）：输入（无锁存能力）或输出（有锁存能力）</li>
</ul>
</li>
<li>工作方式1：选通输入输出方式

    <img src="https://i.postimg.cc/yNRQH94q/1.jpg"  class="left"  style="width: 60% ;"  />

</li>
<li>工作方式2：双向输入输出方式（仅A口）
<ul>
<li>PC3-PC7：A口方式2下的控制线</li>
<li>PC0-PC2：输入或输出或B口方式1下的控制线</li>
<li>B口：方式0或方式1</li>
</ul>
</li>
</ul>
<h4 id="8255的方式控制字及状态字">8255的方式控制字及状态字</h4>
<ul>
<li>控制字

    <img src="https://i.postimg.cc/SK7yKnC5/1.jpg"  class="center"  style="width: 100% ;"  />

</li>
<li>状态字

    <img src="https://i.postimg.cc/nz2BqcbS/1.jpg"  class="center"  style="width: 80% ;"  />

</li>
</ul>
<h4 id="8255的寻址及连接使用">8255的寻址及连接使用</h4>

    <img src="https://i.postimg.cc/QxJkp31T/1.jpg"  class="center"  style="width: 60% ;"  />


<h4 id="8255的初始化及应用举例">8255的初始化及应用举例</h4>
<ul>
<li>方式0——打印机接口

    <img src="https://i.postimg.cc/bwY0gB9F/2.jpg"  class="center"  style="width: 60% ;"  />



    <img src="https://i.postimg.cc/Qd6QyJ6N/3.jpg"  class="center"  style="width: 80% ;"  />



    <img src="https://i.postimg.cc/hGfLWQwL/4.jpg"  class="center"  style="width: 80% ;"  />

</li>
<li>方式1——打印机接口

    <img src="https://i.postimg.cc/ZqGVwLRB/1.jpg"  class="center"  style="width: 60% ;"  />



    <img src="https://i.postimg.cc/tTFDwVZr/2.jpg"  class="center"  style="width: 60% ;"  />


<ul>
<li>程序查询方式

    <img src="https://i.postimg.cc/T1GQ6YnT/3.jpg"  class="center"  style="width: 80% ;"  />

</li>
<li>中断方式

    <img src="https://i.postimg.cc/hGfLWQwL/4.jpg"  class="center"  style="width: 80% ;"  />

</li>
</ul>
</li>
</ul>
<h3 id="可编程定时器8253">可编程定时器8253</h3>
<h4 id="工作方式">工作方式</h4>
<ul>
<li>方式0：计数结束产生中断

    <img src="https://s3.ax1x.com/2020/12/07/DzF7lt.jpg"  class="center"  style="width: 80% ;"  />

</li>
<li>方式1：可编程单稳

    <img src="https://s3.ax1x.com/2020/12/07/DzFIfA.jpg"  class="center"  style="width: 80% ;"  />

</li>
<li>方式2：频率发生器

    <img src="https://s3.ax1x.com/2020/12/07/DzFTSI.jpg"  class="center"  style="width: 80% ;"  />

</li>
<li>方式3：方波发生器

    <img src="https://s3.ax1x.com/2020/12/07/DzF4FH.jpg"  class="center"  style="width: 80% ;"  />

</li>
<li>方式4：软件触发选通

    <img src="https://s3.ax1x.com/2020/12/07/DzF5Yd.jpg"  class="center"  style="width: 80% ;"  />

</li>
<li>方式5：硬件触发选通

    <img src="https://s3.ax1x.com/2020/12/07/DzFbOf.jpg"  class="center"  style="width: 80% ;"  />

</li>
</ul>
<h4 id="8253的控制字">8253的控制字</h4>

    <img src="https://s3.ax1x.com/2020/12/07/Dzkju6.jpg"  class="center"  style="width: 80% ;"  />


<h3 id="习题-4">习题</h3>
<h4 id="71">7.1</h4>
<p>若8253芯片可利用8088的外设接口地址为D0D0H～D0D3H，试画出电路连接图。设加到8253上的时钟信号为2MHz。
若利用计数器0、1和2产生周期为100μs的对称方波以及每1s、10s产生一个负脉冲，试说明8253如何连接，并编写初始化程序。

    <img src="https://s3.ax1x.com/2020/12/07/DzAZb8.jpg"  class="center"  style="width: 80% ;"  />



    <img src="https://s3.ax1x.com/2020/12/07/DzAmVS.jpg"  class="center"  style="width: 80% ;"  />

</p>
<h4 id="72">7.2</h4>
<ul>
<li>若8255芯片可占用的地址为FE00～FEFFH，试画出它与8086总线的连接图。</li>
<li>A/D变换器的引线及工作时序图如下，试将此A/D变换器与8255相连接，并编写包括初始化程序在内的、变换一次数据并将数据放在DATA中的程序</li>
</ul>
<p>
    <img src="https://s3.ax1x.com/2020/12/07/DzANaF.jpg"  class="center"  style="width: 100% ;"  />



    <img src="https://s3.ax1x.com/2020/12/07/DzAtVU.jpg"  class="center"  style="width: 80% ;"  />

</p>
<h4 id="73">7.3</h4>
<p>说明8253的6种工作方式。若如加到8235上的时钟频率为0.5MHz，则一个计数器的最长定时时间是多少？若要求美10min产生一次定时中断，试提出解决方案</p>
<ul>
<li>方式0：计数结束中断，输出一个正跳变</li>
<li>方式1：硬件可重复触发的单稳态触发器，输出一个宽度可调的负脉冲</li>
<li>方式2：比率发生器，输出序列负脉冲</li>
<li>方式3：方波发生器</li>
<li>方式4：软件触发延时选通脉冲发生器</li>
<li>方式5：硬件触发延时选通脉冲发生器</li>
</ul>
<p>加到8253上的时钟频率是0.5MHz，则一个计数器的最长定时时间是$\frac {65536} {0.5\times 10^6}=0.131072 s$（初值为0）</p>
<p>计数器0和计数器1都工作于方式3（循环计数，产生周期性方波），两个计数器串联，计数器0的输出作为计数器1的时钟，计数器1的输出作为cpu中断信号用于产生定时中断。设计数器0的计数值=30000，计数器1的计数值=10000，则每计数30000×10000=3×1e8次，也即每2μs×3×108=600s=10min 产生一次定时中断</p>
<h2 id="基于总线的io接口设计">基于总线的I/O接口设计</h2>
<h3 id="基于isa总线的io接口设计">基于ISA总线的I/O接口设计</h3>
<h4 id="led接口">LED接口</h4>
<ul>
<li>接口电路
<ul>
<li>用通用并行接口芯片作接口

    <img src="https://i.postimg.cc/zfmQgSpJ/1.jpg"  class="center"  style="width: 90% ;"  />



    <img src="https://i.postimg.cc/T2FNFv5k/1.jpg"  class="center"  style="width: 80% ;"  />

</li>
<li>用LED译码器作接口：DM9368

    <img src="https://i.postimg.cc/TYvqndDX/1.jpg"  class="center"  style="width: 80% ;"  />



    <img src="https://i.postimg.cc/PqJmdNB1/1.jpg"  class="center"  style="width: 100% ;"  />


利用上图电路中的4个数码管，实现将存储单元 BUF中的4位十六进制数加以显示，并每经过1秒，重新读取BUF单元数据，更新显示，则控制程序如下：

    <img src="https://i.postimg.cc/NFky6w3g/8.jpg"  class="center"  style="width: 80% ;"  />

</li>
</ul>
</li>
<li>动态显示的接口电路
<ul>
<li>用通用接口芯片

    <img src="https://i.postimg.cc/52Y41Vs6/1.jpg"  class="center"  style="width: 100% ;"  />

</li>
<li>用专用接口芯片：MM74C912/917

    <img src="https://i.postimg.cc/pTV3WQPq/1.jpg"  class="center"  style="width: 80% ;"  />



    <img src="https://i.postimg.cc/pLZgg1Hp/1.jpg"  class="center"  style="width: 100% ;"  />

</li>
</ul>
</li>
</ul>
<h4 id="键盘接口">键盘接口</h4>
<ul>
<li>非编码式键盘

    <img src="https://i.postimg.cc/rw0rH7W9/1.jpg"  class="center"  style="width: 100% ;"  />

</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>C&#43;&#43;(临时对象的分析)</title>
            <link>https://fffzlfk.gitlab.io/posts/c&#43;&#43;%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E6%9E%90/</link>
            <pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/posts/c&#43;&#43;%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E6%9E%90/</guid>
            <description>关闭编译器优化</description>
            <content type="html"><![CDATA[<h2 id="复制构造函数">复制构造函数</h2>
<p>💻笔者在学习OOP时，看到一个讲C++复制构造函数在什么情况下会执行的代码片段，如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Student(){};
    Student <span style="color:#a6e22e">returnS</span>(Student s) { <span style="color:#66d9ef">return</span> s; }
    Student(<span style="color:#66d9ef">const</span> Student <span style="color:#f92672">&amp;</span>e) { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Copy Constructure</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>; }
    <span style="color:#f92672">~</span>Student() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Destructure</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>; }
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Student stu1;
    stu1.returnS(stu1);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>于是乎，笔者在电脑上敲了一边，确实按照预期复制构造函数执行了两次，第一次在构造形参对象时执行，第二次在返回值复制到主函数产生临时对象时执行。</p>
<p>接着笔者将主函数修改为</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Student stu1;
    Student stu2 <span style="color:#f92672">=</span> stu1.returnS(stu1);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>心想：不出意外在构造stu2时，会再执行一次复制构造函数，然而当笔者看到运行结果后，发现并非如此，复制构造函数还是执行了两次，于是笔者陷入了大思考。<br>
想到可能是聪明的编译器是不是帮我优化掉了临时对象，直接复制构造了stu2。导致了上面的代码经过优化之后和这样写其实是一样的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Student stu1;
    Student <span style="color:#f92672">&amp;&amp;</span>stu2 <span style="color:#f92672">=</span> stu1.returnS(stu1);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><style type="text/css">.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative}</style>
<svg width="0" height="0" display="none" xmlns="http://www.w3.org/2000/svg"><symbol id="tip-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"/></symbol><symbol id="note-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="warning-notice" viewBox="0 0 576 512" preserveAspectRatio="xMidYMid meet"><path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="info-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/></symbol></svg><div class="notice tip" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"></use></svg></span>Tip</p><p><a href="https://zh.wikipedia.org/wiki/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><strong>右值引用</strong></a><br>
C++中，引用（reference）是指绑定到内存中的相应对象上。左值引用是绑定到左值对象上；右值引用是绑定到临时对象上。这里的左值对象是指可以通过取地址&amp;运算符得到该对象的内存地址；而临时对象是不能用取地址&amp;运算符获取到对象的内存地址。</p></div>

<p>于是经过几番搜索，找到了这个东西：<br>
<div class="notice tip" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"></use></svg></span>Tip</p><p><strong>-fno-elide-constructors</strong></p>
<p>The C++ standard allows an implementation to omit creating a temporary that is only used to initialize another object of the same type. Specifying this option disables that optimization, and forces G++ to call the copy constructor in all cases.</p></div>
</p>
<p>果然不出所料，当笔者加上这个参数之后</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">g++ test_ref.cpp -o test -fno-elide-constructors
</code></pre></div><p>一切都对劲了起来😄！</p>
<h2 id="移动构造函数">移动构造函数</h2>
<p>使用<a href="https://en.cppreference.com/w/cpp/language/move_constructor">移动构造函数</a>可以提高内存资源的利用效率，从而改进程序的执行性能。</p>
<p>示例程序</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>i;
    A(<span style="color:#66d9ef">int</span> _i) <span style="color:#f92672">:</span> i(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(_i)) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A(int) &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    }
    <span style="color:#f92672">~</span>A() {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;delete pointer: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
        <span style="color:#66d9ef">delete</span> i;
    }
    <span style="color:#75715e">// 复制构造函数
</span><span style="color:#75715e"></span>    A(<span style="color:#66d9ef">const</span> A <span style="color:#f92672">&amp;</span>a) <span style="color:#f92672">:</span> i(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#f92672">*</span>a.i)) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A(const A&amp;) &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    }
    <span style="color:#75715e">// 移动构造函数
</span><span style="color:#75715e"></span>    A(A <span style="color:#f92672">&amp;&amp;</span>a) <span style="color:#f92672">:</span> i(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#f92672">*</span>a.i)) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A(const A&amp;&amp;) &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
        a.i <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
    }
};

A <span style="color:#a6e22e">getA</span>(A para) {
    A tmp(<span style="color:#ae81ff">2</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> hex <span style="color:#f92672">&lt;&lt;</span> tmp.i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    <span style="color:#66d9ef">return</span> tmp;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    A a(<span style="color:#ae81ff">1</span>);
    A b <span style="color:#f92672">=</span> getA(a);
    cout <span style="color:#f92672">&lt;&lt;</span> a.i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>运行结果</p>
<pre><code>A(int) 0x8016eb0            构造a对象
A(const A&amp;) 0x80172e0       参数复制构造para
A(int) 0x8017300            构造tmp对象
0x8017300
A(const A&amp;&amp;) 0x8017320      调用移动构造函数(临时对象构造返回值)
delete pointer: 0           析构临时对象
A(const A&amp;&amp;) 0x8017340      调用移动构造函数(返回值移动到b对象)
delete pointer: 0           析构临时对象(指返回值)
delete pointer: 0x80172e0   析构函数para
0x8016eb0               
delete pointer: 0x8017340   析构b对象
delete pointer: 0x8016eb0   析构a对象
</code></pre>]]></content>
        </item>
        
        <item>
            <title>算法（第四版）</title>
            <link>https://fffzlfk.gitlab.io/posts/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%BD%9C%E4%B8%9A%E9%A2%98/</link>
            <pubDate>Fri, 09 Oct 2020 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/posts/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%BD%9C%E4%B8%9A%E9%A2%98/</guid>
            <description>The solution of algs4&amp;rsquo;s exercise</description>
            <content type="html"><![CDATA[<h2 id="union-find">Union-Find</h2>
<h3 id="quickfind">quickfind</h3>
<h4 id="java-implementation">Java implementation</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">QuickFindUF</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> id<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> count<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">QuickFindUF</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        id <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>n<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
            id<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
        count <span style="color:#f92672">=</span> n<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">count</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> count<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> id<span style="color:#f92672">[</span>p<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">connected</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> q<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> find<span style="color:#f92672">(</span>p<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> find<span style="color:#f92672">(</span>q<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">union</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> q<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> pid <span style="color:#f92672">=</span> find<span style="color:#f92672">(</span>p<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">int</span> qid <span style="color:#f92672">=</span> find<span style="color:#f92672">(</span>q<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>pid <span style="color:#f92672">!=</span> qid<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> id<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>id<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> pid<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    id<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> qid<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        count<span style="color:#f92672">--;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Scanner in <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner<span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">);</span>
        QuickFindUF uf <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> QuickFindUF<span style="color:#f92672">(</span>10<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>in<span style="color:#f92672">.</span><span style="color:#a6e22e">hasNext</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> in<span style="color:#f92672">.</span><span style="color:#a6e22e">nextInt</span><span style="color:#f92672">(),</span> q <span style="color:#f92672">=</span> in<span style="color:#f92672">.</span><span style="color:#a6e22e">nextInt</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>uf<span style="color:#f92672">.</span><span style="color:#a6e22e">connected</span><span style="color:#f92672">(</span>p<span style="color:#f92672">,</span> q<span style="color:#f92672">))</span> <span style="color:#66d9ef">continue</span><span style="color:#f92672">;</span>
            uf<span style="color:#f92672">.</span><span style="color:#a6e22e">union</span><span style="color:#f92672">(</span>p<span style="color:#f92672">,</span> q<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="analysis">analysis</h4>
<p>The find() operation is certainly quick, as it only accesses the id[] array once in order to complete the operation. But quick-find is typically not useful for large problems because union() needs to scan through the whole id[] array for each input pair.</p>
<h3 id="quick-union">quick-union</h3>
<h4 id="implementation">implementation</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">import</span> java.util.Scanner<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">QuickUnionUF</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> id<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> count<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">QuickUnionUF</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        id <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>n<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
            id<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
        count <span style="color:#f92672">=</span> n<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">count</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> count<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>p <span style="color:#f92672">!=</span> id<span style="color:#f92672">[</span>p<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
            p <span style="color:#f92672">=</span> id<span style="color:#f92672">[</span>p<span style="color:#f92672">];</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> p<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">connected</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> q<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> find<span style="color:#f92672">(</span>p<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> find<span style="color:#f92672">(</span>q<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">union</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> q<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> pRoot <span style="color:#f92672">=</span> find<span style="color:#f92672">(</span>p<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">int</span> qRoot <span style="color:#f92672">=</span> find<span style="color:#f92672">(</span>q<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>pRoot <span style="color:#f92672">!=</span> qRoot<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            id<span style="color:#f92672">[</span>pRoot<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> qRoot<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        count<span style="color:#f92672">--;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Scanner in <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner<span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">);</span>
        QuickUnionUF uf <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> QuickUnionUF<span style="color:#f92672">(</span>10<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>in<span style="color:#f92672">.</span><span style="color:#a6e22e">hasNext</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> in<span style="color:#f92672">.</span><span style="color:#a6e22e">nextInt</span><span style="color:#f92672">(),</span> q <span style="color:#f92672">=</span> in<span style="color:#f92672">.</span><span style="color:#a6e22e">nextInt</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>uf<span style="color:#f92672">.</span><span style="color:#a6e22e">connected</span><span style="color:#f92672">(</span>p<span style="color:#f92672">,</span> q<span style="color:#f92672">))</span> <span style="color:#66d9ef">continue</span><span style="color:#f92672">;</span>
            uf<span style="color:#f92672">.</span><span style="color:#a6e22e">union</span><span style="color:#f92672">(</span>p<span style="color:#f92672">,</span> q<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="quick-union-worst-case">quick-union worst case</h4>

    <img src="https://s1.ax1x.com/2020/11/01/B0Esk8.png"  class="center"  style="border-radius: 8px; width: 50%"  />


<h3 id="weighted-quick-union">Weighted quick-union</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">import</span> java.util.Scanner<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WeightedQuickUnionUF</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> id<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> sz<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> count<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">WeightedQuickUnionUF</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> N<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        count <span style="color:#f92672">=</span> N<span style="color:#f92672">;</span>
        id <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">];</span>
        sz <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            id<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
            sz<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>p <span style="color:#f92672">!=</span> id<span style="color:#f92672">[</span>p<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
            id<span style="color:#f92672">[</span>p<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> id<span style="color:#f92672">[</span>id<span style="color:#f92672">[</span>p<span style="color:#f92672">]];</span> <span style="color:#75715e">// path compression by halving
</span><span style="color:#75715e"></span>            p <span style="color:#f92672">=</span> id<span style="color:#f92672">[</span>p<span style="color:#f92672">];</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> p<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">connected</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> q<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> find<span style="color:#f92672">(</span>p<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> find<span style="color:#f92672">(</span>q<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">union</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> p<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> q<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> find<span style="color:#f92672">(</span>p<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> find<span style="color:#f92672">(</span>q<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">==</span> j<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>sz<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> sz<span style="color:#f92672">[</span>j<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
            id<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> j<span style="color:#f92672">;</span>
            sz<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">+=</span> sz<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            id<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
            sz<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">+=</span> sz<span style="color:#f92672">[</span>j<span style="color:#f92672">];</span>
        <span style="color:#f92672">}</span>
        count<span style="color:#f92672">--;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Scanner in <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner<span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">);</span>
        WeightedQuickUnionUF uf <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> WeightedQuickUnionUF<span style="color:#f92672">(</span>10<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>in<span style="color:#f92672">.</span><span style="color:#a6e22e">hasNext</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> in<span style="color:#f92672">.</span><span style="color:#a6e22e">nextInt</span><span style="color:#f92672">(),</span> q <span style="color:#f92672">=</span> in<span style="color:#f92672">.</span><span style="color:#a6e22e">nextInt</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>uf<span style="color:#f92672">.</span><span style="color:#a6e22e">connected</span><span style="color:#f92672">(</span>p<span style="color:#f92672">,</span> q<span style="color:#f92672">))</span> <span style="color:#66d9ef">continue</span><span style="color:#f92672">;</span>
            uf<span style="color:#f92672">.</span><span style="color:#a6e22e">union</span><span style="color:#f92672">(</span>p<span style="color:#f92672">,</span> q<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="performance-characteristics-of-union-find-algorithms">Performance characteristics of union-find algorithms</h3>
<table>
<thead>
<tr>
<th>algorithm</th>
<th>constructor</th>
<th>union</th>
<th>find</th>
</tr>
</thead>
<tbody>
<tr>
<td>quick-find</td>
<td>N</td>
<td>N</td>
<td>1</td>
</tr>
<tr>
<td>quick-union</td>
<td>N</td>
<td>tree height</td>
<td>tree height</td>
</tr>
<tr>
<td>weighted quick-union</td>
<td>N</td>
<td>lgN</td>
<td>lgN</td>
</tr>
<tr>
<td>weighted quick-union with path compression</td>
<td>N</td>
<td>very, very nearly, but not quite 1</td>
<td>same as union</td>
</tr>
<tr>
<td>impossible</td>
<td>N</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<h2 id="analysis-of-algorithms">Analysis of Algorithms</h2>
<h3 id="scientific-method">Scientific method</h3>
<p>The very same approach that scientists use to understand the natural world is effective for studying the running time of programs.</p>
<ul>
<li><em>Observe</em> some feature of the natural world, generally with precise measurement.</li>
<li><em>Hypothesize</em> a model that is consistent with observations.</li>
<li><em>Predict</em> events using the hypothesis.</li>
<li><em>Verify</em> the predictions by making further observations.</li>
<li><em>Valitate</em> by repeating until the hypothesis and observations agree.</li>
</ul>
<h3 id="mathematical-models">Mathematical models</h3>
<ul>
<li><em>Tilde approximations.</em> We use tilde approximations, where we throw away low-order terms that complicate formulas. We write <em>~f(N)</em> to represent any function that when divided by <em>f(N)</em> approaches 1 as <em>N</em> grows. We write <em>g(N)~f(N)</em> to indicate that <em>g(N)/f(N)</em> approaches 1 as <em>N</em> grows.</li>
<li><em>Order-of-growth classifications.</em> Most often, we work with tilde approximations of the form <em>g(N)~af(N)</em> where $ f(N) = N^b log_c N $ and refer to f(N) as the The order of growth of g(N). We use just a few structural primitives (statements, conditionals, loops, nesting, and method calls) to implement algorithms, so very often the order of growth of the cost is one of just a few functions of the problem size N.</li>
</ul>
<table>
<thead>
<tr>
<th>function</th>
<th>tilde approximation</th>
<th>order of growth</th>
</tr>
</thead>
<tbody>
<tr>
<td>$ \frac{N^3}{6}-\frac{N^2}{2}+\frac N 3 $</td>
<td>$~\frac{N^3}{6} $</td>
<td>$N^3$</td>
</tr>
<tr>
<td>$ \frac{N^3}{2}-\frac N 2$</td>
<td>$ ~\frac{N^2}{2} $</td>
<td>$N^2$</td>
</tr>
<tr>
<td>$lgN+1 $</td>
<td>$~lgN$</td>
<td>$lgN$</td>
</tr>
<tr>
<td>3</td>
<td>~3</td>
<td>1</td>
</tr>
</tbody>
</table>
<ul>
<li><em>Cost model.</em>  We focus attention on properties of algorithms by articulating a cost model that defines the basic operations. For example, an appropriate cost model for the 3-sum problem is the number of times we access an array entry, for read or write.</li>
</ul>
<h3 id="commonly-used-notations-in-the-theory-of-algorithms">Commonly-used Notations in the Theory of Algorithms</h3>
<table>
<thead>
<tr>
<th>notation</th>
<th>provides</th>
<th>example</th>
<th>shorthand for</th>
<th>used to</th>
</tr>
</thead>
<tbody>
<tr>
<td>Big Theta</td>
<td>asympatotic order of growth</td>
<td>$ \Theta (N^2) $</td>
<td>$\frac 1 2 N^2, 5N^2+22NlogN+3N$</td>
<td>classify algorithms</td>
</tr>
<tr>
<td>Big Oh</td>
<td>$\Theta (N^2)$and smaller</td>
<td>$O(N^2)$</td>
<td>$10N^2,\ 100N, 22NlogN+3N $</td>
<td>develop upper bounds</td>
</tr>
<tr>
<td>Big Omega</td>
<td>$\Theta (N^2)$and larger</td>
<td>$\Omega (N^2)$</td>
<td>$\frac 1 2 N^2, N^5, N^3+22NlogN+3N $</td>
<td>develop lower bounds</td>
</tr>
</tbody>
</table>
<h3 id="146">1.4.6</h3>
<style type="text/css">.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative}</style>
<svg width="0" height="0" display="none" xmlns="http://www.w3.org/2000/svg"><symbol id="tip-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"/></symbol><symbol id="note-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="warning-notice" viewBox="0 0 576 512" preserveAspectRatio="xMidYMid meet"><path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="info-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/></symbol></svg><div class="notice note" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#note-notice"></use></svg></span>Note</p><p>Give the order of growth (as a function of N ) of the running times of each of the following code fragments:</p></div>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> N<span style="color:#f92672">;</span> n <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">;</span> n <span style="color:#f92672">/=</span> 2<span style="color:#f92672">)</span>
  <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
      sum<span style="color:#f92672">++;</span>
</code></pre></div><p>$$ N+\frac N 2+\frac N 4+\frac N 8+&hellip;+1=2N-1\ \   \sim 2N $$
所以是线性</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1 i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i <span style="color:#f92672">*=</span> 2<span style="color:#f92672">)</span>
  <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> i<span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span>
    sum<span style="color:#f92672">++;</span>
</code></pre></div><p>$$ 1+2+4+8+&hellip;+2^{\lfloor lgN \rfloor}=2^{\lfloor lgN \rfloor + 1}-1\ \  \sim 2N$$
所以是线性</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1 i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i <span style="color:#f92672">*=</span> 2<span style="color:#f92672">)</span>
  <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span>
    sum<span style="color:#f92672">++;</span>
</code></pre></div><p>$$ NlgN $$ 线性对数</p>
<h3 id="1415">1.4.15</h3>
<div class="notice note" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#note-notice"></use></svg></span>Note</p><p>Faster 3-sum. As a warmup, develop an implementation TwoSumFaster that uses a linear algorithm to count the pairs that sum to zero after the array is sorted (in stead of the binary-search-based linearithmic algorithm). Then apply a similar idea to develop a quadratic algorithm for the 3-sum problem.</p></div>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">twoSumFaster</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> a<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> lo <span style="color:#f92672">=</span> 0<span style="color:#f92672">,</span> hi <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>lo <span style="color:#f92672">&lt;</span> hi<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>lo<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> a<span style="color:#f92672">[</span>hi<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            cnt<span style="color:#f92672">++;</span>
            lo<span style="color:#f92672">++;</span>
            hi<span style="color:#f92672">--;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>lo<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> a<span style="color:#f92672">[</span>hi<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span>
            hi<span style="color:#f92672">--;</span>
        <span style="color:#66d9ef">else</span>
            lo<span style="color:#f92672">++;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> cnt<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">threeSumFaster</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> a<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> lo <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> 1<span style="color:#f92672">,</span> hi <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>lo <span style="color:#f92672">&lt;</span> hi<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> a<span style="color:#f92672">[</span>lo<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> a<span style="color:#f92672">[</span>hi<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                cnt<span style="color:#f92672">++;</span>
                lo<span style="color:#f92672">++;</span>
                hi<span style="color:#f92672">--;</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> a<span style="color:#f92672">[</span>lo<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> a<span style="color:#f92672">[</span>hi<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span>
                hi<span style="color:#f92672">--;</span>
            <span style="color:#66d9ef">else</span>
                lo<span style="color:#f92672">++;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> cnt<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="megersort">MegerSort</h2>
<h3 id="implementation-1">Implementation</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Merge</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isSorted</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> hi<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> lo <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;=</span> hi<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>less<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span> a<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">]))</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">less</span><span style="color:#f92672">(</span>Comparable v<span style="color:#f92672">,</span> Comparable w<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> v<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>w<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> Comparable<span style="color:#f92672">[]</span> aux<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> mid<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> hi<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">assert</span> isSorted<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> mid<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">assert</span> isSorted<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> mid <span style="color:#f92672">+</span> 1<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>

        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> lo<span style="color:#f92672">;</span> k <span style="color:#f92672">&lt;=</span> hi<span style="color:#f92672">;</span> k<span style="color:#f92672">++)</span>
            aux<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>k<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> lo<span style="color:#f92672">,</span> j <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> lo<span style="color:#f92672">;</span> k <span style="color:#f92672">&lt;=</span> hi<span style="color:#f92672">;</span> k<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&gt;</span> mid<span style="color:#f92672">)</span> a<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> aux<span style="color:#f92672">[</span>j<span style="color:#f92672">++];</span>
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>j <span style="color:#f92672">&gt;</span> hi<span style="color:#f92672">)</span> a<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> aux<span style="color:#f92672">[</span>i<span style="color:#f92672">++];</span>
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>less<span style="color:#f92672">(</span>aux<span style="color:#f92672">[</span>j<span style="color:#f92672">],</span> aux<span style="color:#f92672">[</span>i<span style="color:#f92672">]))</span> a<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> aux<span style="color:#f92672">[</span>j<span style="color:#f92672">++];</span>
            <span style="color:#66d9ef">else</span> a<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> aux<span style="color:#f92672">[</span>i<span style="color:#f92672">++];</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">assert</span> isSorted<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> Comparable<span style="color:#f92672">[]</span> aux<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> hi<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>hi <span style="color:#f92672">&lt;=</span> lo<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> lo <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>hi <span style="color:#f92672">-</span> lo<span style="color:#f92672">)</span> <span style="color:#f92672">/</span> 2<span style="color:#f92672">;</span>
        sort<span style="color:#f92672">(</span>aux<span style="color:#f92672">,</span> a<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> mid<span style="color:#f92672">);</span>
        sort<span style="color:#f92672">(</span>aux<span style="color:#f92672">,</span> a<span style="color:#f92672">,</span> mid<span style="color:#f92672">+</span>1<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>
        merge<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> aux<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> mid<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Comparable<span style="color:#f92672">[]</span> aux <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Comparable<span style="color:#f92672">[</span>a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">];</span>
        sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> aux<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> StdIn<span style="color:#f92672">.</span><span style="color:#a6e22e">readInt</span><span style="color:#f92672">();</span>
        Comparable<span style="color:#f92672">[]</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Comparable<span style="color:#f92672">[</span>N<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
            a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> StdRandom<span style="color:#f92672">.</span><span style="color:#a6e22e">uniform</span><span style="color:#f92672">(-</span>10000<span style="color:#f92672">,</span>10000<span style="color:#f92672">);</span>
        Stopwatch stopwatch <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stopwatch<span style="color:#f92672">();</span>
        sort<span style="color:#f92672">(</span>a<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>var i <span style="color:#f92672">:</span> a<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">();</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>stopwatch<span style="color:#f92672">.</span><span style="color:#a6e22e">elapsedTime</span><span style="color:#f92672">());</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="empirical-analysis">Empirical analysis</h3>
<div class="notice note" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#note-notice"></use></svg></span>Note</p><p>The number of compares $C(N)$ and array accesses $A(N)$ to mergesort an array of size N satisfy the recurrences:<br>
$$ C(N) \le C(\lceil{\frac N 2}\rceil) + C(\lfloor{\frac N 2}\rfloor) + N\ \ for N &gt; 1,with \ C(1)=0. $$
$$
A(N) \le A(\lceil{\frac N 2}\rceil) + A(\lfloor{\frac N 2}\rfloor) + 6N\ \ for N &gt; 1,with \ A(1)=0.
$$
we solve the recurrence when $ N $ is a power of 2.
$$ D(N) = 2D(\frac N 2) + N, for N &gt; 1, with\ D(1) = 0. $$</p></div>

<h4 id="divide-and-conquer-recurrence">Divide-and-conquer recurrence:</h4>
<ol>
<li>
<p>proof by picture</p>

    <img src="/img/merge-pic.png"  class="center"  style="border-radius: 8px;"  />


</li>
<li>
<p>proof by expansion</p>
<p>$$
\begin{align}
D(N)&amp;=2D(N/2)+N \cr
{D(N)} /{N} &amp;= 2D(N / 2)/N + 1\cr
&amp;= D(N/2)/(N/2)+1 \cr
&amp;= D(N/4)/(N/4) + 1 + 1\cr
&amp;= D(N/8)/(N/8) + 1 + 1 + 1\cr
&hellip;\cr
&amp;= D(N/N)/(N/N)+1+1+&hellip;+1\cr
&amp;= lgN
\end{align}
$$</p>
</li>
<li>
<p>proof by induction</p>
<ul>
<li>Base case: $N = 1$</li>
<li>Induction hypothesis: $D(N)=Nlg(N)$.</li>
<li>Goal: showthat $ D(2N) = (2N)lg(2N).$</li>
</ul>
<p>$$
\begin{align}
D(2N) &amp;= 2D(N)+2N \cr
&amp;= 2NlgN+2N \cr
&amp;= 2N(lgN+1) \cr
&amp;= 2Nlg(2N)
\end{align}
$$</p>
</li>
</ol>
<h3 id="practical-improvements">practical improvements</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> Comparable<span style="color:#f92672">[]</span> aux<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> hi<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// Use insertion sort for samll subarrays.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CUTOFF <span style="color:#f92672">=</span> 7<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>hi <span style="color:#f92672">&lt;=</span> lo <span style="color:#f92672">+</span> CUTOFF <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Insertion<span style="color:#f92672">.</span><span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> lo <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>hi <span style="color:#f92672">-</span> lo<span style="color:#f92672">)</span> <span style="color:#f92672">/</span> 2<span style="color:#f92672">;</span>
    sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> aux<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> mid<span style="color:#f92672">);</span>
    sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> aux<span style="color:#f92672">,</span> mid <span style="color:#f92672">+</span> 1<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>
    
    <span style="color:#75715e">// Stop if already sorted.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>less<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>mid<span style="color:#f92672">+</span>1<span style="color:#f92672">],</span> a<span style="color:#f92672">[</span>mid<span style="color:#f92672">]))</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    
    merge<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> aux<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> mid<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>Eliminate the copy to the auxiliary array.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span>Comparable<span style="color:#f92672">[]</span> aux<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> mid<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> hi<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> lo<span style="color:#f92672">,</span> j <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> lo<span style="color:#f92672">;</span> k <span style="color:#f92672">&lt;=</span> hi<span style="color:#f92672">;</span> k<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&gt;</span> mid<span style="color:#f92672">)</span> aux<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>j<span style="color:#f92672">++];</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>j <span style="color:#f92672">&gt;</span> hi<span style="color:#f92672">)</span> aux<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">++];</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>less<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>j<span style="color:#f92672">],</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">]))</span> aux<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">=</span>a<span style="color:#f92672">[</span>j<span style="color:#f92672">++];</span>
        <span style="color:#66d9ef">else</span> aux<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">++];</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span>Comparable<span style="color:#f92672">[]</span> aux<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> hi<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>hi <span style="color:#f92672">&lt;=</span> lo<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> lo <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>hi <span style="color:#f92672">-</span> lo<span style="color:#f92672">)</span> <span style="color:#f92672">/</span> 2<span style="color:#f92672">;</span>
    <span style="color:#75715e">//switch soles of aux[] and a[]
</span><span style="color:#75715e"></span>    sort<span style="color:#f92672">(</span>aux<span style="color:#f92672">,</span> a<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> mid<span style="color:#f92672">);</span>
    sort<span style="color:#f92672">(</span>aux<span style="color:#f92672">,</span> a<span style="color:#f92672">,</span> mid<span style="color:#f92672">+</span>1<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>
    merge<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> aux<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> mid<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="bottom-up-mergesort">Bottom-up mergesort</h3>
<h4 id="implementation-2">Implementation</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> Comparable<span style="color:#f92672">[]</span> aux<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> mid<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> hi<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> lo<span style="color:#f92672">;</span> k <span style="color:#f92672">&lt;=</span> hi<span style="color:#f92672">;</span> k<span style="color:#f92672">++)</span>
        aux<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>k<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> lo<span style="color:#f92672">,</span> j <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> lo<span style="color:#f92672">;</span> k <span style="color:#f92672">&lt;=</span> hi<span style="color:#f92672">;</span> k<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&gt;</span> mid<span style="color:#f92672">)</span> a<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> aux<span style="color:#f92672">[</span>j<span style="color:#f92672">++];</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>j <span style="color:#f92672">&gt;</span> hi<span style="color:#f92672">)</span> a<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> aux<span style="color:#f92672">[</span>i<span style="color:#f92672">++];</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>less<span style="color:#f92672">(</span>aux<span style="color:#f92672">[</span>j<span style="color:#f92672">],</span> aux<span style="color:#f92672">[</span>i<span style="color:#f92672">]))</span> a<span style="color:#f92672">[</span>k<span style="color:#f92672">]=</span> aux<span style="color:#f92672">[</span>j<span style="color:#f92672">++];</span>
        <span style="color:#66d9ef">else</span> a<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> aux<span style="color:#f92672">[</span>i<span style="color:#f92672">++];</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    Comparable<span style="color:#f92672">[]</span> aux <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Comparable<span style="color:#f92672">[</span>N<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> sz <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> sz <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> sz <span style="color:#f92672">=</span> sz <span style="color:#f92672">+</span> sz<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> lo <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> lo <span style="color:#f92672">&lt;</span> N <span style="color:#f92672">-</span> sz<span style="color:#f92672">;</span> lo <span style="color:#f92672">+=</span>sz <span style="color:#f92672">+</span> sz<span style="color:#f92672">)</span>
            merge<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> aux<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> lo <span style="color:#f92672">+</span> sz <span style="color:#f92672">-</span>1<span style="color:#f92672">,</span>Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>lo<span style="color:#f92672">+</span>sz<span style="color:#f92672">+</span>sz<span style="color:#f92672">-</span>1<span style="color:#f92672">,</span> N<span style="color:#f92672">-</span>1<span style="color:#f92672">));</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> StdIn<span style="color:#f92672">.</span><span style="color:#a6e22e">readInt</span><span style="color:#f92672">();</span>
    Comparable<span style="color:#f92672">[]</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Comparable<span style="color:#f92672">[</span>N<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
        a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> StdRandom<span style="color:#f92672">.</span><span style="color:#a6e22e">uniform</span><span style="color:#f92672">(-</span>1000010000<span style="color:#f92672">);</span>
    Stopwatch stopwatch <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stopwatch<span style="color:#f92672">();</span>
    sort<span style="color:#f92672">(</span>a<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>var i <span style="color:#f92672">:</span> a<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">();</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>stopwatch<span style="color:#f92672">.</span><span style="color:#a6e22e">elapsedTim</span><span style="color:#f92672">());</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="sorting-complexity">Sorting Complexity</h3>
<ul>
<li>Model of computation: decision tree.</li>
<li>Cost model: # compares.</li>
<li>Upper bound: $\sim NlgN $from mergesort</li>
<li>Lower bound: ?</li>
<li>Optimal algorithm: ?</li>
</ul>
<h4 id="compare-based-lower-bound-for-sorting">Compare-based lower bound for sorting</h4>
<ul>
<li>
<p>Proposition. Any Compare-based sorting algorothm must use at least $lg(N!)\sim NlogN $(Stirling formula) compares in the worst-case.</p>
</li>
<li>
<p>Pf.</p>
<ul>
<li>Assume array consists of $N$ distinct values $a_1$ through $ a_n $.</li>
<li>Worst case dictated by height $h$ of decision tree.</li>
<li>Binary tree of height $h$ has at most $2^h$ leaves.</li>
<li>$N! $different orderings $\Rightarrow$ at least $ N!$ leaves.</li>
</ul>
<p>$$ 
\begin{align}
2^h \ge ＃leaves \ge N! \cr
\Rightarrow h \ge lg(N!)\sim NlgN 
\end{align}$$</p>
</li>
</ul>
<h3 id="stability">Stability</h3>
<ul>
<li>Insertion sort is <strong>stable</strong>: Equal items never move fast each other.
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insertionSort</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span> j <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">&amp;&amp;</span> less<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>j<span style="color:#f92672">],</span> a<span style="color:#f92672">[</span>j <span style="color:#f92672">-</span> 1<span style="color:#f92672">]);</span> j<span style="color:#f92672">--)</span>
            exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> j<span style="color:#f92672">,</span> j <span style="color:#f92672">-</span> 1<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>Selection sort is <strong>not</strong> stable: Long-distance exchange might move an item past some equal item.
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">selectionSort</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> min <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>less<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>j<span style="color:#f92672">],</span> a<span style="color:#f92672">[</span>min<span style="color:#f92672">]))</span>
                min <span style="color:#f92672">=</span> j<span style="color:#f92672">;</span>
        exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> min<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>Shellsort is <strong>not</strong> stable: Long-distence exchange.
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">shellSort</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&lt;</span> N <span style="color:#f92672">/</span> 3<span style="color:#f92672">)</span> h <span style="color:#f92672">=</span> 3 <span style="color:#f92672">*</span> h <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;=</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span> j <span style="color:#f92672">&gt;</span> h <span style="color:#f92672">&amp;&amp;</span> less<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>j<span style="color:#f92672">],</span> a<span style="color:#f92672">[</span>j <span style="color:#f92672">-</span> h<span style="color:#f92672">]);</span> j <span style="color:#f92672">-=</span> h<span style="color:#f92672">)</span>
                exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> j<span style="color:#f92672">,</span> j <span style="color:#f92672">-</span> h<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        h <span style="color:#f92672">/=</span> 3<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>Mergesort is <strong>stable</strong>.: Suffices to verify that merge operation is table.</li>
</ul>
<h3 id="222">2.2.2</h3>
<p>Give traces, in the style of the trace given with Algorithm 2.4, showing how the 
keys E A S Y Q U E S T I O N are sorted with top-down mergesort.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>a[]</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>lo</td>
<td>mid</td>
<td>hi</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>E</td>
<td>A</td>
<td>S</td>
<td>Y</td>
<td>Q</td>
<td>U</td>
<td>E</td>
<td>S</td>
<td>T</td>
<td>I</td>
<td>O</td>
<td>N</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td><strong>A</strong></td>
<td><strong>E</strong></td>
<td>S</td>
<td>Y</td>
<td>Q</td>
<td>U</td>
<td>E</td>
<td>S</td>
<td>T</td>
<td>I</td>
<td>O</td>
<td>N</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>2</td>
<td><strong>A</strong></td>
<td><strong>E</strong></td>
<td><strong>S</strong></td>
<td>Y</td>
<td>Q</td>
<td>U</td>
<td>E</td>
<td>S</td>
<td>T</td>
<td>I</td>
<td>O</td>
<td>N</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>4</td>
<td>A</td>
<td>E</td>
<td>S</td>
<td><strong>Q</strong></td>
<td><strong>Y</strong></td>
<td>U</td>
<td>E</td>
<td>S</td>
<td>T</td>
<td>I</td>
<td>O</td>
<td>N</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>5</td>
<td>A</td>
<td>E</td>
<td>S</td>
<td><strong>Q</strong></td>
<td><strong>U</strong></td>
<td><strong>Y</strong></td>
<td>E</td>
<td>S</td>
<td>T</td>
<td>I</td>
<td>O</td>
<td>N</td>
</tr>
<tr>
<td>0</td>
<td>2</td>
<td>5</td>
<td><strong>A</strong></td>
<td><strong>E</strong></td>
<td><strong>Q</strong></td>
<td><strong>S</strong></td>
<td><strong>U</strong></td>
<td><strong>Y</strong></td>
<td>E</td>
<td>S</td>
<td>T</td>
<td>I</td>
<td>O</td>
<td>N</td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td>7</td>
<td>A</td>
<td>E</td>
<td>Q</td>
<td>S</td>
<td>U</td>
<td>Y</td>
<td><strong>E</strong></td>
<td><strong>S</strong></td>
<td>T</td>
<td>I</td>
<td>O</td>
<td>N</td>
</tr>
<tr>
<td>6</td>
<td>7</td>
<td>8</td>
<td>A</td>
<td>E</td>
<td>Q</td>
<td>S</td>
<td>U</td>
<td>Y</td>
<td><strong>E</strong></td>
<td><strong>S</strong></td>
<td><strong>T</strong></td>
<td>I</td>
<td>O</td>
<td>N</td>
</tr>
<tr>
<td>9</td>
<td>9</td>
<td>10</td>
<td>A</td>
<td>E</td>
<td>Q</td>
<td>S</td>
<td>U</td>
<td>Y</td>
<td>E</td>
<td>S</td>
<td>T</td>
<td><strong>I</strong></td>
<td><strong>O</strong></td>
<td>N</td>
</tr>
<tr>
<td>9</td>
<td>10</td>
<td>11</td>
<td>A</td>
<td>E</td>
<td>Q</td>
<td>S</td>
<td>U</td>
<td>Y</td>
<td>E</td>
<td>S</td>
<td>T</td>
<td><strong>I</strong></td>
<td><strong>N</strong></td>
<td><strong>O</strong></td>
</tr>
<tr>
<td>6</td>
<td>8</td>
<td>11</td>
<td>A</td>
<td>E</td>
<td>Q</td>
<td>S</td>
<td>U</td>
<td>Y</td>
<td><strong>E</strong></td>
<td><strong>I</strong></td>
<td><strong>N</strong></td>
<td><strong>O</strong></td>
<td><strong>S</strong></td>
<td><strong>T</strong></td>
</tr>
<tr>
<td>0</td>
<td>5</td>
<td>11</td>
<td><strong>A</strong></td>
<td><strong>E</strong></td>
<td><strong>E</strong></td>
<td><strong>I</strong></td>
<td><strong>N</strong></td>
<td><strong>O</strong></td>
<td><strong>Q</strong></td>
<td><strong>S</strong></td>
<td><strong>S</strong></td>
<td><strong>T</strong></td>
<td><strong>U</strong></td>
<td><strong>Y</strong></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>A</td>
<td>E</td>
<td>E</td>
<td>I</td>
<td>N</td>
<td>O</td>
<td>Q</td>
<td>S</td>
<td>S</td>
<td>T</td>
<td>U</td>
<td>Y</td>
</tr>
</tbody>
</table>
<h3 id="223">2.2.3</h3>
<p>Answer Exercise 2.2.2 for bottom-up mergesort.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>a[]</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>lo</td>
<td>mid</td>
<td>hi</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>E</td>
<td>A</td>
<td>S</td>
<td>Y</td>
<td>Q</td>
<td>U</td>
<td>E</td>
<td>S</td>
<td>T</td>
<td>I</td>
<td>O</td>
<td>N</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td><strong>A</strong></td>
<td><strong>E</strong></td>
<td>S</td>
<td>Y</td>
<td>Q</td>
<td>U</td>
<td>E</td>
<td>S</td>
<td>T</td>
<td>I</td>
<td>O</td>
<td>N</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>3</td>
<td>A</td>
<td>E</td>
<td><strong>S</strong></td>
<td><strong>Y</strong></td>
<td>Q</td>
<td>U</td>
<td>E</td>
<td>S</td>
<td>T</td>
<td>I</td>
<td>O</td>
<td>N</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>5</td>
<td>A</td>
<td>E</td>
<td>S</td>
<td>Y</td>
<td><strong>Q</strong></td>
<td><strong>U</strong></td>
<td>E</td>
<td>S</td>
<td>T</td>
<td>I</td>
<td>O</td>
<td>N</td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td>7</td>
<td>A</td>
<td>E</td>
<td>S</td>
<td>Y</td>
<td>Q</td>
<td>U</td>
<td><strong>E</strong></td>
<td><strong>S</strong></td>
<td>T</td>
<td>I</td>
<td>O</td>
<td>N</td>
</tr>
<tr>
<td>8</td>
<td>8</td>
<td>9</td>
<td>A</td>
<td>E</td>
<td>S</td>
<td>Y</td>
<td>Q</td>
<td>U</td>
<td>E</td>
<td>S</td>
<td><strong>I</strong></td>
<td><strong>T</strong></td>
<td>O</td>
<td>N</td>
</tr>
<tr>
<td>10</td>
<td>10</td>
<td>11</td>
<td>A</td>
<td>E</td>
<td>S</td>
<td>Y</td>
<td>Q</td>
<td>U</td>
<td>E</td>
<td>S</td>
<td>I</td>
<td>T</td>
<td><strong>N</strong></td>
<td><strong>O</strong></td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>3</td>
<td><strong>A</strong></td>
<td><strong>E</strong></td>
<td><strong>S</strong></td>
<td><strong>Y</strong></td>
<td>Q</td>
<td>U</td>
<td>E</td>
<td>S</td>
<td>I</td>
<td>T</td>
<td>N</td>
<td>O</td>
</tr>
<tr>
<td>4</td>
<td>5</td>
<td>7</td>
<td>A</td>
<td>E</td>
<td>S</td>
<td>Y</td>
<td><strong>E</strong></td>
<td><strong>Q</strong></td>
<td><strong>S</strong></td>
<td><strong>U</strong></td>
<td>I</td>
<td>T</td>
<td>N</td>
<td>O</td>
</tr>
<tr>
<td>8</td>
<td>9</td>
<td>11</td>
<td>A</td>
<td>E</td>
<td>S</td>
<td>Y</td>
<td>E</td>
<td>Q</td>
<td>S</td>
<td>U</td>
<td><strong>I</strong></td>
<td><strong>N</strong></td>
<td><strong>O</strong></td>
<td><strong>T</strong></td>
</tr>
<tr>
<td>0</td>
<td>3</td>
<td>7</td>
<td><strong>A</strong></td>
<td><strong>E</strong></td>
<td><strong>E</strong></td>
<td><strong>Q</strong></td>
<td><strong>S</strong></td>
<td><strong>S</strong></td>
<td><strong>U</strong></td>
<td><strong>Y</strong></td>
<td><strong>I</strong></td>
<td>N</td>
<td>O</td>
<td>T</td>
</tr>
<tr>
<td>0</td>
<td>7</td>
<td>11</td>
<td><strong>A</strong></td>
<td><strong>E</strong></td>
<td><strong>E</strong></td>
<td><strong>I</strong></td>
<td><strong>N</strong></td>
<td><strong>O</strong></td>
<td><strong>Q</strong></td>
<td><strong>S</strong></td>
<td><strong>S</strong></td>
<td><strong>T</strong></td>
<td><strong>U</strong></td>
<td><strong>Y</strong></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>A</td>
<td>E</td>
<td>E</td>
<td>I</td>
<td>N</td>
<td>O</td>
<td>Q</td>
<td>S</td>
<td>S</td>
<td>T</td>
<td>U</td>
<td>Y</td>
</tr>
</tbody>
</table>
<h3 id="224">2.2.4</h3>
<p>Does the abstract in-place merge produce proper output if and only if the two input subarrays are in sorted order? Prove your answer, or provide a counterexample.(是否当且仅当两个输入的数组都有序时原地归并的抽象方法才能得到正确的结果？证明你的结论，或者给出一个反例。)</p>
<ul>
<li>是的，只有当两个输入数组都有序时采用原地归并才能得到正确的结果。</li>
<li>反例：数组1：[4, 2, 3],数组2：[1, 5, 8];<br>
按归并算法归并后得到[1,4,2,3,5,8]; 可以看到归并后元素的相对位置不变，故得到错误的结果。</li>
</ul>
<h3 id="225">2.2.5</h3>
<p>Give the sequence of subarray sizes in the merges performed by both the top-down and the bottom-up mergesort algorithms, for N = 39.
(当输入数组的大小N=39时，给出自顶向下和自底向上的归并排序中各归并子数组的大小及顺序。)</p>
<h4 id="自顶向下">自顶向下</h4>
<p>2, 3, 2, 5, 2, 3, 2, 5, 10, 2, 3, 2, 5, 2, 3, 2, 5, 10, 20, 2, 3, 2, 5, 2, 3, 2, 5, 10, 2, 3, 2, 5, 2, 2, 4, 9, 19, 39</p>
<h4 id="自底向上">自底向上</h4>
<p>2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 8, 8, 8, 8, 7, 16, 16, 32, 39</p>
<h2 id="quicksort">QuickSort</h2>
<h3 id="quicksort-1">quicksort</h3>
<p>Basic plan:</p>
<ul>
<li><strong>Shuffle</strong> the array</li>
<li><strong>Partition</strong> so that, for some j
<ul>
<li>entry a[j] in place</li>
<li>no larger entry to the left of j</li>
<li>no smaller entry to the right of j</li>
</ul>
</li>
<li><strong>Sort</strong> each piece recursively.</li>
</ul>
<h4 id="java-implementation-1">Java implementation</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Quick</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">less</span><span style="color:#f92672">(</span>Comparable v<span style="color:#f92672">,</span> Comparable w<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> v<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>w<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exch</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> j<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Comparable t <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>j<span style="color:#f92672">];</span>
        a<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">partition</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> hi<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> lo<span style="color:#f92672">,</span> j <span style="color:#f92672">=</span> hi <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>less<span style="color:#f92672">(</span>a<span style="color:#f92672">[++</span>i<span style="color:#f92672">],</span> a<span style="color:#f92672">[</span>lo<span style="color:#f92672">]))</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">==</span> hi<span style="color:#f92672">)</span> <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>less<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>lo<span style="color:#f92672">],</span> a<span style="color:#f92672">[--</span>j<span style="color:#f92672">]))</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>j <span style="color:#f92672">==</span> lo<span style="color:#f92672">)</span> <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&gt;=</span> j<span style="color:#f92672">)</span> <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> j<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> j<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> j<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        StdRandom<span style="color:#f92672">.</span><span style="color:#a6e22e">shuffle</span><span style="color:#f92672">(</span>a<span style="color:#f92672">);</span>
        sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> hi<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>lo <span style="color:#f92672">&gt;=</span> hi<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> partition<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>
        sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> j <span style="color:#f92672">-</span> 1<span style="color:#f92672">);</span>
        sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> j <span style="color:#f92672">+</span> 1<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="average-case-analysis">average-case analysis</h3>
<p>$C_N $ satisfies the recurrence $C_0 = C_1=0$ and for $ N\ge 2 $:<br>
$$ C_N = (N + 1) + (\frac{C_0+C_{N-1}}{N})+ (\frac{C_1+C_{N-2}}{N})+ &hellip; +(\frac{C_{N-1}+C_{0}}{N}) $$</p>
<ul>
<li>
<p>Multiply both sides by N and collect terms:
$$ NC_N = N(N+1)+2(C_0+C_1+&hellip;+C_{N-1}) $$</p>
</li>
<li>
<p>Substract this from the same equation for $N - 1$:
$$ NC_N-(N-1)C_{N-1}=2N+2C_{N-1} $$</p>
</li>
<li>
<p>Rearrage terms and devide by $N(N+1)$:
$$ \frac{C_N}{N+1} = \frac{C_{N-1}}{N} + \frac{2}{N+1} $$</p>
</li>
<li>
<p>Repeatedly apply above equation:
$$
\begin{align}
\frac{C_N}{N+1} &amp;= \frac{C_{N-1}}{N}+\frac{2}{N+1} \cr
&amp;= \frac{C_{N-2}}{N-1}+\frac{2}{N}+\frac{2}{N+1} \cr
&amp;= \frac{C_{N-3}}{N-2}+\frac{2}{N-1}+\frac{2}{N}+\frac{2}{N+1} \cr
&amp;= \frac 2 3 + \frac 2 4 + \frac 2 5 +&hellip;+\frac 2 {N+1}
\end{align}
$$</p>
</li>
<li>
<p>Approximate sum by an integral:
$$
\begin{align}
C_N &amp;= 2(N+1)(\frac 1 3 + \frac 1 4 + \frac 1 5 +&hellip;+ \frac{1}{N+1}) \cr
&amp; \sim 2(N+1) \int_{3}^{N+1}{\frac{1}{x}dx}
\end{align}
$$</p>
</li>
<li>
<p>Finally, the desired result:
$$ C_N \sim 2(N+1)lnN \sim 1.39NlgN $$</p>
</li>
</ul>
<h3 id="3-way-quicksort">3-way quicksort</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> threeWayQuickSort(T a[], <span style="color:#66d9ef">int</span> lo, <span style="color:#66d9ef">int</span> hi) {
    <span style="color:#66d9ef">if</span> (hi <span style="color:#f92672">&lt;=</span> lo) <span style="color:#66d9ef">return</span>;
    <span style="color:#66d9ef">int</span> lt <span style="color:#f92672">=</span> lo, gt <span style="color:#f92672">=</span> hi;
    T v <span style="color:#f92672">=</span> a[lo];
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> lo;
    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;=</span> gt) {
        <span style="color:#66d9ef">if</span> (a[i] <span style="color:#f92672">&lt;</span> v)
            swap(a[lt<span style="color:#f92672">++</span>], a[i<span style="color:#f92672">++</span>]);
        <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (a[i] <span style="color:#f92672">&gt;</span> v)
            swap(a[gt<span style="color:#f92672">--</span>], a[i]);
        <span style="color:#66d9ef">else</span>
            i<span style="color:#f92672">++</span>;
    }
    threeWayQuickSort(a, lo, lt <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
    threeWayQuickSort(a, gt <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, hi);
}
</code></pre></div><h3 id="231">2.3.1</h3>
<p>Show, in the style of the trace given with partition(), how that method patitions the array E A S Y Q U E S T I O N.</p>
<table>
<thead>
<tr>
<th>i</th>
<th>j</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>12</td>
<td>E</td>
<td>A</td>
<td>S</td>
<td>Y</td>
<td>Q</td>
<td>U</td>
<td>E</td>
<td>S</td>
<td>T</td>
<td>I</td>
<td>O</td>
<td>N</td>
</tr>
<tr>
<td>2</td>
<td>6</td>
<td>E</td>
<td>A</td>
<td>S</td>
<td>Y</td>
<td>Q</td>
<td>U</td>
<td>E</td>
<td>S</td>
<td>T</td>
<td>I</td>
<td>O</td>
<td>N</td>
</tr>
<tr>
<td>2</td>
<td>6</td>
<td>E</td>
<td>A</td>
<td><strong>E</strong></td>
<td>Y</td>
<td>Q</td>
<td>U</td>
<td><strong>S</strong></td>
<td>S</td>
<td>T</td>
<td>I</td>
<td>O</td>
<td>N</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>E</td>
<td>A</td>
<td>E</td>
<td>Y</td>
<td>Q</td>
<td>U</td>
<td>S</td>
<td>S</td>
<td>T</td>
<td>I</td>
<td>O</td>
<td>N</td>
</tr>
<tr>
<td></td>
<td>2</td>
<td><strong>E</strong></td>
<td>A</td>
<td><strong>E</strong></td>
<td>Y</td>
<td>Q</td>
<td>U</td>
<td>S</td>
<td>S</td>
<td>T</td>
<td>I</td>
<td>O</td>
<td>N</td>
</tr>
</tbody>
</table>
<h3 id="232">2.3.2</h3>
<p>Show, in the style of the quicksort trace given in this section, how quicksort sorts the array E A S Y Q U E S T I O N (for the purposes of this exercise, ignore the initial shuffle).</p>

    <img src="https://s1.ax1x.com/2020/10/27/BlExEV.png"  class="center"  style="border-radius: 8px;"  />


<h3 id="233">2.3.3</h3>
<p>What is the maximum number of times during the execution of Quick.sort() that the largest item can be exchanged, for an array of length N ?
(对于长度为N的数组，在Quick.sort()执行时，其最大的元素最多会被交换多少次？)</p>
<p>在Quick.sort()中，一个元素被交换可分为两种情况：</p>
<ol>
<li>该元素是枢轴，在partition最后一步和j交换</li>
<li>该元素在本次partition中不是枢轴，出现在了枢轴错的一侧，需要被交换到另一侧</li>
</ol>
<ul>
<li>如果该元素是枢轴，那么在交换后它的位置就固定下来了，之后不再涉及交换，因此要使交换次数最大，这个元素应该是在每次partition时都位于枢轴错误的一侧，因为是最大的元素，所以应该总是在枢轴的左侧。</li>
<li>为了使得partition的次数尽可能的多，需要使得每次移动的距离短，这里我们先考虑每次移动一位，如数组[5,9,1,6,7]：
<ul>
<li>枢轴为5，交换后变为[5,1,9,6,7]</li>
<li>枢轴交换，变为[1,5,9,6,7]</li>
<li>我们发现在下一次partition中最大元素9会成为枢轴，不再被交换</li>
</ul>
</li>
<li>所以考虑每次移动两位，如数组[2,10,4,1,6,3,8,5,7,9]
<ul>
<li>枢轴为2，交换后[2,1,4,10,6,3,8,5,7,9]</li>
<li>枢轴交换，变为[1,2,4,10,6,3,8,5,7,9]</li>
<li>枢轴为4，交换后[1,2,4,3,6,10,8,5,7,9]</li>
<li>枢轴交换，变为[1,2,3,4,6,10,8,5,7,9]</li>
<li>枢轴为6，交换后[1,2,3,4,6,5,8,10,7,9]</li>
<li>枢轴交换，变为[1,2,3,4,5,6,8,10,7,9]</li>
<li>枢轴为8，交换后[1,2,3,4,5,6,8,7,10,9]</li>
<li>枢轴交换，变为[1,2,3,4,5,6,7,8,10,9]</li>
<li>枢轴为10，交换后[1,2,3,4,5,6,7,8,9,10]</li>
</ul>
</li>
<li>在上面这个N=10的数组中，“10”这个最大的元素一共被交换了5次，所以我们可以认为对于N个元素的数组，在执行Quick.sort()时最大元素最多会被交换N/2次。</li>
</ul>
<h3 id="234">2.3.4</h3>
<p>Suppose that the initial random shuffle is omitted. Give six arrays of ten elements 
for which Quick.sort() uses the worst-case number of compares.</p>
<p>如果始终选第一个元素作为枢轴的话，要使比较次数达到最坏情况的话，输入数组应为升序。比较次数达到$ N + N-1 + N-2 + N-3 +&hellip;+1 = \frac{N(N+1)}{2} \sim N^2/2 $
例如：</p>
<ul>
<li>[1,2,3,4,5,6,7,8,9,10]</li>
<li>[2,4,6,8,10,12,14,16,18,20]</li>
<li>[-1,1,3,5,7,9,11,13,15,17]</li>
<li>[10,20,30,40,50,60,70,80,90,100]</li>
<li>[5,10,15,20,25,30,35,40,45,50]</li>
<li>[0,2,3,4,6,7,8,9,10,12]</li>
</ul>
<h3 id="235">2.3.5</h3>
<p>Give a code fragment that sorts an array that is known to consist of items having 
just two distinct keys.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> lo <span style="color:#f92672">=</span> 0<span style="color:#f92672">,</span> hi <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&lt;=</span> hi<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>lo<span style="color:#f92672">]);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tmp <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lo<span style="color:#f92672">++,</span> i<span style="color:#f92672">++);</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tmp <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> hi<span style="color:#f92672">--);</span>
        <span style="color:#66d9ef">else</span> i<span style="color:#f92672">++;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="priority-queues">Priority Queues</h2>
<h3 id="api">API</h3>

    <img src="https://s1.ax1x.com/2020/11/05/BWuxX9.png"  class="center"  style="width:75%; border-radius:8px"  />


<h3 id="binary-heap">binary-heap</h3>
<h4 id="java-implementation-2">Java implementation</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MaxPQ</span><span style="color:#f92672">&lt;</span>Key <span style="color:#66d9ef">extends</span> Comparable<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> Key<span style="color:#f92672">[]</span> pq<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">MaxPQ</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> maxN<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        pq <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Key<span style="color:#f92672">[])</span> <span style="color:#66d9ef">new</span> Comparable<span style="color:#f92672">[</span>maxN <span style="color:#f92672">+</span> 1<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> N <span style="color:#f92672">==</span> 0<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> N<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span>Key v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        pq<span style="color:#f92672">[++</span>N<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> v<span style="color:#f92672">;</span>
        swim<span style="color:#f92672">(</span>N<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> Key <span style="color:#a6e22e">delMax</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        Key max <span style="color:#f92672">=</span> pq<span style="color:#f92672">[</span>1<span style="color:#f92672">];</span>
        exch<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> N<span style="color:#f92672">--);</span>
        sink<span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
        pq<span style="color:#f92672">[</span>N<span style="color:#f92672">+</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span> max<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">less</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> j<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> pq<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>pq<span style="color:#f92672">[</span>j<span style="color:#f92672">])</span> <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exch</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> j<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Key tmp <span style="color:#f92672">=</span> pq<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        pq<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> pq<span style="color:#f92672">[</span>j<span style="color:#f92672">];</span>
        pq<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> tmp<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swim</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> k<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>k <span style="color:#f92672">&gt;</span> 1 <span style="color:#f92672">&amp;&amp;</span> less<span style="color:#f92672">(</span>k <span style="color:#f92672">/</span> 2<span style="color:#f92672">,</span> k<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            exch<span style="color:#f92672">(</span>k <span style="color:#f92672">/</span> 2<span style="color:#f92672">,</span> k<span style="color:#f92672">);</span>
            k <span style="color:#f92672">/=</span> 2<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sink</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> k<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>2 <span style="color:#f92672">*</span> k <span style="color:#f92672">&lt;=</span> N<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 2 <span style="color:#f92672">*</span> k<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>j <span style="color:#f92672">&lt;</span> N <span style="color:#f92672">&amp;&amp;</span> less<span style="color:#f92672">(</span>j<span style="color:#f92672">,</span> j <span style="color:#f92672">+</span> 1<span style="color:#f92672">))</span> j<span style="color:#f92672">++;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>less<span style="color:#f92672">(</span>k<span style="color:#f92672">,</span> j<span style="color:#f92672">))</span> <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            exch<span style="color:#f92672">(</span>k<span style="color:#f92672">,</span> j<span style="color:#f92672">);</span>
            k <span style="color:#f92672">=</span> j<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="heapsort">heapsort</h3>
<h4 id="basic-plan-for-in-place-sort">Basic plan for in-place sort</h4>
<ul>
<li>Create max-heap with all N keys.</li>
<li>Repatedly remove the maximum key.</li>
</ul>
<h4 id="java-implementation-3">Java implementation</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Heap</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> N <span style="color:#f92672">/</span> 2<span style="color:#f92672">;</span> k <span style="color:#f92672">&gt;=</span> 1<span style="color:#f92672">;</span> k<span style="color:#f92672">--)</span>
            sink<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> k<span style="color:#f92672">,</span> N<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>N <span style="color:#f92672">&gt;</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> 1<span style="color:#f92672">,</span> N<span style="color:#f92672">);</span>
            sink<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> 1<span style="color:#f92672">,</span> <span style="color:#f92672">--</span>N<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">less</span><span style="color:#f92672">(</span>Comparable a<span style="color:#f92672">[],</span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> j<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> a<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">].</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>j <span style="color:#f92672">-</span> 1<span style="color:#f92672">])</span> <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exch</span><span style="color:#f92672">(</span>Comparable a<span style="color:#f92672">[],</span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> j<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Comparable t <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">];</span>
        a<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>j <span style="color:#f92672">-</span> 1<span style="color:#f92672">];</span>
        a<span style="color:#f92672">[</span>j <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sink</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> k<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> N<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>2 <span style="color:#f92672">*</span> k <span style="color:#f92672">&lt;=</span> N<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 2 <span style="color:#f92672">*</span> k<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>j <span style="color:#f92672">&lt;</span> N <span style="color:#f92672">&amp;&amp;</span> less<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> j<span style="color:#f92672">,</span> j <span style="color:#f92672">+</span> 1<span style="color:#f92672">))</span> j<span style="color:#f92672">++;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>less<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> k<span style="color:#f92672">,</span> j<span style="color:#f92672">))</span> <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> k<span style="color:#f92672">,</span> j<span style="color:#f92672">);</span>
            k <span style="color:#f92672">=</span> j<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="mathematical-analysis">mathematical analysis</h4>
<ul>
<li>
<p>Proposition. Heap construction uses $ \le 2N $ compares and exchanges.</p>
</li>
<li>
<p>Proposition. Heapsort uses $ \le 2NlgN $ compares and exchanges.</p>
</li>
<li>
<p>Significance. In-place sorting algorithm with $ NlgN $ worst-case.</p>
<ul>
<li>Mergesort: no, linear extra space.</li>
<li>Quicksort: no, quadratic time in worst case.</li>
<li>Heapsort: yes!</li>
</ul>
</li>
<li>
<p>Bottom line. Heapsort is optimal for both time and space but:</p>
<ul>
<li>Inner loop longer than quicksort&rsquo;s.</li>
<li>Makes poor use of cache memory.</li>
<li>Not stable.</li>
</ul>
</li>
</ul>
<h4 id="sorting-algorithms-summary">sorting-algorithms: summary</h4>

    <img src="https://s1.ax1x.com/2020/11/06/BWX9N6.png"  class="center"  style="width:90%; border-radius: 8px"  />


<h3 id="242">2.4.2</h3>
<p>Criticize the following idea: To implement find the maximum in constant time, why not use a stack or a queue, but keep track of the maximum value inserted so far, then return that value for find the maximum?</p>
<p>如果用这种方法，当最大元素被删除之后，不能在常量时间内更新最大元素</p>
<h3 id="243">2.4.3</h3>
<p>Provide priority-queue implementations that support insert and remove the maximum, one for each of the following underlying data structures: unordered array, ordered array, unordered linked list, and linked list. Give a table of the worst-case bounds for each operation for each of your four implementations.</p>
<h4 id="数组实现">数组实现</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ArrayPQ</span><span style="color:#f92672">&lt;</span>Key <span style="color:#66d9ef">extends</span> Comparable<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">protected</span> Key<span style="color:#f92672">[]</span> pq<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ArrayPQ</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> capacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        pq <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Key<span style="color:#f92672">[])</span> <span style="color:#66d9ef">new</span> Comparable<span style="color:#f92672">[</span>capacity<span style="color:#f92672">];</span>
        n <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span><span style="color:#66d9ef">return</span> n <span style="color:#f92672">==</span> 0<span style="color:#f92672">;}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span><span style="color:#66d9ef">return</span> n<span style="color:#f92672">;}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span>Key x<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> Key <span style="color:#a6e22e">delMax</span><span style="color:#f92672">();</span>
    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">less</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> j<span style="color:#f92672">)</span> <span style="color:#f92672">{</span><span style="color:#66d9ef">return</span> pq<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>pq<span style="color:#f92672">[</span>j<span style="color:#f92672">])</span> <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">;</span> <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exch</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> j<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Key t <span style="color:#f92672">=</span> pq<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        pq<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> pq<span style="color:#f92672">[</span>j<span style="color:#f92672">];</span>
        pq<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        OrderedArrayMaxPQ pq <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> OrderedArrayMaxPQ<span style="color:#f92672">(</span>10<span style="color:#f92672">);</span>
        pq<span style="color:#f92672">.</span><span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;this&#34;</span><span style="color:#f92672">);</span>
        pq<span style="color:#f92672">.</span><span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;is&#34;</span><span style="color:#f92672">);</span>
        pq<span style="color:#f92672">.</span><span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">);</span>
        pq<span style="color:#f92672">.</span><span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;test&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>pq<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">())</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>pq<span style="color:#f92672">.</span><span style="color:#a6e22e">delMax</span><span style="color:#f92672">());</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UnorderedArrayMaxPQ</span><span style="color:#f92672">&lt;</span>Key <span style="color:#66d9ef">extends</span> Comparable<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;&gt;</span> <span style="color:#66d9ef">extends</span> ArrayPQ<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">UnorderedArrayMaxPQ</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> capacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>capacity<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span>Key x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        pq<span style="color:#f92672">[</span>n<span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> Key <span style="color:#a6e22e">delMax</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> max <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>less<span style="color:#f92672">(</span>max<span style="color:#f92672">,</span> i<span style="color:#f92672">))</span> max <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
            exch<span style="color:#f92672">(</span>max<span style="color:#f92672">,</span> n<span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> pq<span style="color:#f92672">[--</span>n<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OrderedArrayMaxPQ</span><span style="color:#f92672">&lt;</span>Key <span style="color:#66d9ef">extends</span> Comparable<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;&gt;</span> <span style="color:#66d9ef">extends</span> ArrayPQ<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">OrderedArrayMaxPQ</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> capacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>capacity<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span>Key x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&gt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>pq<span style="color:#f92672">[</span>i<span style="color:#f92672">])</span> <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            pq<span style="color:#f92672">[</span>i<span style="color:#f92672">+</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> pq<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
            i<span style="color:#f92672">--;</span>
        <span style="color:#f92672">}</span>
        pq<span style="color:#f92672">[</span>i<span style="color:#f92672">+</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span>
        n<span style="color:#f92672">++;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> Key <span style="color:#a6e22e">delMax</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> pq<span style="color:#f92672">[--</span>n<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="链表实现">链表实现</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LinkedListPQ</span><span style="color:#f92672">&lt;</span>Key <span style="color:#66d9ef">extends</span> Comparable<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">protected</span> LinkedList<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;</span> pq<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">LinkedListPQ</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        pq <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;();</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span>Key x<span style="color:#f92672">);</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> Key <span style="color:#a6e22e">delMax</span><span style="color:#f92672">();</span>

    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">less</span><span style="color:#f92672">(</span>Key a<span style="color:#f92672">,</span> Key b<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>b<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        UnorderedLinkedMaxPQ pq <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> UnorderedLinkedMaxPQ<span style="color:#f92672">();</span>
        pq<span style="color:#f92672">.</span><span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;this&#34;</span><span style="color:#f92672">);</span>
        pq<span style="color:#f92672">.</span><span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;is&#34;</span><span style="color:#f92672">);</span>
        pq<span style="color:#f92672">.</span><span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">);</span>
        pq<span style="color:#f92672">.</span><span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;test&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>pq<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">())</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>pq<span style="color:#f92672">.</span><span style="color:#a6e22e">delMax</span><span style="color:#f92672">());</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UnorderedLinkedMaxPQ</span><span style="color:#f92672">&lt;</span>Key <span style="color:#66d9ef">extends</span> Comparable<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;&gt;</span> <span style="color:#66d9ef">extends</span> LinkedListPQ<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span>Key x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        pq<span style="color:#f92672">.</span><span style="color:#a6e22e">addLast</span><span style="color:#f92672">(</span>x<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> Key <span style="color:#a6e22e">delMax</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        var max <span style="color:#f92672">=</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">getFirst</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>var e <span style="color:#f92672">:</span> pq<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>less<span style="color:#f92672">(</span>max<span style="color:#f92672">,</span> e<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                max <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
                idx <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            i<span style="color:#f92672">++;</span>
        <span style="color:#f92672">}</span>
        pq<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span>idx<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> max<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OrderedLinkedMaxPQ</span><span style="color:#f92672">&lt;</span>Key <span style="color:#66d9ef">extends</span> Comparable<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;&gt;</span> <span style="color:#66d9ef">extends</span> LinkedListPQ<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">OrderedLinkedMaxPQ</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">super</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span>Key x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        Iterator it <span style="color:#f92672">=</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">iterator</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>it<span style="color:#f92672">.</span><span style="color:#a6e22e">hasNext</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>less<span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> <span style="color:#f92672">(</span>Key<span style="color:#f92672">)</span> it<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">()))</span> <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            i<span style="color:#f92672">++;</span>
        <span style="color:#f92672">}</span>
        pq<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>i<span style="color:#f92672">,</span> x<span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;  eee &#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> Key <span style="color:#a6e22e">delMax</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">removeLast</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="the-worst-case-bounds">the worst-case bounds</h4>
<table>
<thead>
<tr>
<th></th>
<th>insert()</th>
<th>delMax()</th>
</tr>
</thead>
<tbody>
<tr>
<td>无序数组</td>
<td>1</td>
<td>N</td>
</tr>
<tr>
<td>有序数组</td>
<td>N</td>
<td>1</td>
</tr>
<tr>
<td>无序链表</td>
<td>1</td>
<td>N</td>
</tr>
<tr>
<td>有序链表</td>
<td>N</td>
<td>1</td>
</tr>
</tbody>
</table>
<h3 id="245">2.4.5</h3>
<p>Give the heap that results when the keys E A S Y Q U E S T I O N are inserted in that order into an initially empty max-oriented heap.</p>

    <img src="https://s1.ax1x.com/2020/11/06/BhYuEF.jpg"  class="center"  style="width:50%; border-radius:8px;"  />


<h3 id="247">2.4.7</h3>
<p>The largest item in a heap must appear in position 1, and the second largest must be in position 2 or position 3. Give the list of positions in a heap of size 31 where the kth largest (i) can appear, and (ii) cannot appear, for k=2, 3, 4 (assuming the values to be distinct).</p>
<ul>
<li>k = 2：可能出现在2，3；不可能出现在1, 4~31</li>
<li>k = 3：可能出现在2，3，4，5，6，7；不可能出现在1,8~31</li>
<li>k = 4：可能出现在2，3，4，5，6，7，8，9，10，11，12，13，14，15，不可能出现在1，16~31</li>
</ul>
<p>第k大元素只可能出现在深度不大于k的位置($ position \le 2^k-1 ,k \ge 2$)</p>
<h3 id="249">2.4.9</h3>
<p>Draw all of the different heaps that can be made from the five keys A B C D E, then draw all of the different heaps that can be made from the five keys A A A B B.</p>
<h4 id="a-b-c-d-e">A B C D E</h4>
<ul>
<li>最大堆

    <img src="https://s1.ax1x.com/2020/11/06/BhwOIK.jpg"  class="center"  style="width:70%; border-radius:8px"  />

</li>
<li>最小堆

    <img src="https://s1.ax1x.com/2020/11/06/BhwjPO.jpg"  class="center"  style="width:70%; border-radius:8px;"  />

</li>
</ul>
<h4 id="a-a-a-b-b">A A A B B</h4>

    <img src="https://s1.ax1x.com/2020/11/06/BhBAmR.jpg"  class="center"  style="width:70%; border-radius:8px;"  />


<h3 id="2411">2.4.11</h3>
<p>Suppose that your application will have a huge number of insert operations, but only a few remove the maximum operations. Which priority-queue implementation do you think would be most effective: heap, unordered array, or ordered array?</p>
<p>因为有大量的insert操作和很少的delMax操作，而heap, unordered array, ordered array实现的Priority Queue insert操作的花费时间的数量级分别为lgN, 1, N, 所以unordered array是最有效的。</p>
<h3 id="2412">2.4.12</h3>
<p>Suppose that your application will have a huge number of find the maximum operations, but a relatively small number of insert and remove the maximum operations. Which priority-queue implementation do you think would be most effective: heap, unordered array, or ordered array?</p>
<p>大量的查找最大元素，heap和ordered array查找最大元素都是常量时间，但heap插入和删除最大元素都是lgN，而ordered array插入和删除分别是N和常量时间，综合下来，heap是最有效的。</p>
<h2 id="undirected-graphs">UNDIRECTED GRAPHS</h2>
<h3 id="depth-first-search">depth-first-search</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DepthFirstPaths</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> marked<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> edgeTo<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">DepthFirstPaths</span><span style="color:#f92672">(</span>Graph G<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        marked <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        edgeTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">fill</span><span style="color:#f92672">(</span>marked<span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">s</span> <span style="color:#f92672">=</span> s<span style="color:#f92672">;</span>
        dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> s<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span><span style="color:#f92672">(</span>Graph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        marked<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> w <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> w<span style="color:#f92672">);</span>
                edgeTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> v<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">hasPathTo</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> marked<span style="color:#f92672">[</span>v<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> Iterable<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">pathTo</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>hasPathTo<span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> path <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> v<span style="color:#f92672">;</span> x <span style="color:#f92672">!=</span> s<span style="color:#f92672">;</span> x <span style="color:#f92672">=</span> edgeTo<span style="color:#f92672">[</span>x<span style="color:#f92672">])</span>
            path<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>x<span style="color:#f92672">);</span>
        path<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>s<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> path<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> V <span style="color:#f92672">=</span> StdIn<span style="color:#f92672">.</span><span style="color:#a6e22e">readInt</span><span style="color:#f92672">();</span>
        Graph g <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Graph<span style="color:#f92672">(</span>V<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">int</span> E <span style="color:#f92672">=</span> StdIn<span style="color:#f92672">.</span><span style="color:#a6e22e">readInt</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> E<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            g<span style="color:#f92672">.</span><span style="color:#a6e22e">addEdge</span><span style="color:#f92672">(</span>StdIn<span style="color:#f92672">.</span><span style="color:#a6e22e">readInt</span><span style="color:#f92672">(),</span> StdIn<span style="color:#f92672">.</span><span style="color:#a6e22e">readInt</span><span style="color:#f92672">());</span>
        <span style="color:#f92672">}</span>
        DepthFirstPaths dfp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DepthFirstPaths<span style="color:#f92672">(</span>g<span style="color:#f92672">,</span> 0<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>var i <span style="color:#f92672">:</span> dfp<span style="color:#f92672">.</span><span style="color:#a6e22e">pathTo</span><span style="color:#f92672">(</span>3<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="breadth-first-search">breadth-first-search</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BreadthFirstPaths</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> marked<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> edgeTo<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">BreadthFirstPaths</span><span style="color:#f92672">(</span>Graph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        marked <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        edgeTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">s</span> <span style="color:#f92672">=</span> s<span style="color:#f92672">;</span>
        bfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> s<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bfs</span><span style="color:#f92672">(</span>Graph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Queue<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> Q <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Queue<span style="color:#f92672">&lt;&gt;();</span>
        Q<span style="color:#f92672">.</span><span style="color:#a6e22e">enqueue</span><span style="color:#f92672">(</span>s<span style="color:#f92672">);</span>
        marked<span style="color:#f92672">[</span>s<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>Q<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> Q<span style="color:#f92672">.</span><span style="color:#a6e22e">dequeue</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> w <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                    Q<span style="color:#f92672">.</span><span style="color:#a6e22e">enqueue</span><span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
                    marked<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                    edgeTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> v<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">hasPathTo</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> marked<span style="color:#f92672">[</span>v<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> Iterable<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">pathTo</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>hasPathTo<span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> path <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> v<span style="color:#f92672">;</span> i <span style="color:#f92672">!=</span> s<span style="color:#f92672">;</span> i <span style="color:#f92672">=</span> edgeTo<span style="color:#f92672">[</span>i<span style="color:#f92672">])</span>
            path<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
        path<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>s<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> path<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> V <span style="color:#f92672">=</span> StdIn<span style="color:#f92672">.</span><span style="color:#a6e22e">readInt</span><span style="color:#f92672">();</span>
        Graph g <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Graph<span style="color:#f92672">(</span>V<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">int</span> E <span style="color:#f92672">=</span> StdIn<span style="color:#f92672">.</span><span style="color:#a6e22e">readInt</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> E<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            g<span style="color:#f92672">.</span><span style="color:#a6e22e">addEdge</span><span style="color:#f92672">(</span>StdIn<span style="color:#f92672">.</span><span style="color:#a6e22e">readInt</span><span style="color:#f92672">(),</span> StdIn<span style="color:#f92672">.</span><span style="color:#a6e22e">readInt</span><span style="color:#f92672">());</span>
        <span style="color:#f92672">}</span>
        BreadthFirstPaths bfp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BreadthFirstPaths<span style="color:#f92672">(</span>g<span style="color:#f92672">,</span> 0<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>var i <span style="color:#f92672">:</span> bfp<span style="color:#f92672">.</span><span style="color:#a6e22e">pathTo</span><span style="color:#f92672">(</span>3<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="connected-components">connected components</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CC</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> marked<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> id<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> count<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">CC</span><span style="color:#f92672">(</span>Graph G<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        marked <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        id <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>v<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> v<span style="color:#f92672">);</span>
                count<span style="color:#f92672">++;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">count</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> <span style="color:#66d9ef">return</span> count<span style="color:#f92672">;</span> <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">id</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#66d9ef">return</span> id<span style="color:#f92672">[</span>v<span style="color:#f92672">];</span> <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span><span style="color:#f92672">(</span>Graph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        marked<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        id<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> count<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> w <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span>
                dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> w<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Graph G <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Graph<span style="color:#f92672">(</span>StdIn<span style="color:#f92672">.</span><span style="color:#a6e22e">readInt</span><span style="color:#f92672">());</span>
        <span style="color:#66d9ef">int</span> E <span style="color:#f92672">=</span> StdIn<span style="color:#f92672">.</span><span style="color:#a6e22e">readInt</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> E<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
            G<span style="color:#f92672">.</span><span style="color:#a6e22e">addEdge</span><span style="color:#f92672">(</span>StdIn<span style="color:#f92672">.</span><span style="color:#a6e22e">readInt</span><span style="color:#f92672">(),</span> StdIn<span style="color:#f92672">.</span><span style="color:#a6e22e">readInt</span><span style="color:#f92672">());</span>
        CC cc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CC<span style="color:#f92672">(</span>G<span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>cc<span style="color:#f92672">.</span><span style="color:#a6e22e">count</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="minimum-spanning-trees">Minimum Spanning Trees</h2>
<h3 id="greedy-algorithm">Greedy algorithm</h3>
<h4 id="cut-property">Cut property</h4>
<ul>
<li>
<p>Def: A <strong>cut</strong> in a graph is a partition of its vertices into two(nonempty) sets.</p>
</li>
<li>
<p>Def: A <strong>Crossing edge</strong> connects a vertex in one set with a vertex in the other.</p>
</li>
<li>
<p><strong>Cut property</strong>. Give any cut, the crossing edge of min weight is in the MST</p>
<ul>
<li>Pf. Suppose the min-weight crossing edge <em>e</em> is not in the MST
<ul>
<li>Adding <em>e</em> to the MST creates a cycle</li>
<li>Some other edge <em>f</em> in cycle must be a crossing edge</li>
<li>Removing <em>f</em>  and adding <em>e</em> is also a spanning tree</li>
<li>Since weight of <em>e</em> is less than the weight of <em>f</em>,that spanning tree is lower weight</li>
<li>Contradiction</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="kruskals-algorithm">Kruskal&rsquo;s algorithm</h3>
<p>Consider edges in ascending order of weight.</p>
<ul>
<li>Add next edge to tree <em>T</em> unless so doing would create a cycle.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">KruskalMST</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> Queue<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;</span> mst <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Queue<span style="color:#f92672">&lt;&gt;();</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">double</span> weight<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">KruskalMST</span><span style="color:#f92672">(</span>EdgeWeightedGraph G<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        weight <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        MinPQ<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;</span> pq <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MinPQ<span style="color:#f92672">&lt;&gt;();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>var e <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">edges</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            pq<span style="color:#f92672">.</span><span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        UF uf <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> UF<span style="color:#f92672">(</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">());</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>pq<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">&amp;&amp;</span> mst<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            Edge e <span style="color:#f92672">=</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">delMin</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">either</span><span style="color:#f92672">(),</span> w <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">other</span><span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>uf<span style="color:#f92672">.</span><span style="color:#a6e22e">connected</span><span style="color:#f92672">(</span>v<span style="color:#f92672">,</span> w<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                uf<span style="color:#f92672">.</span><span style="color:#a6e22e">union</span><span style="color:#f92672">(</span>v<span style="color:#f92672">,</span> w<span style="color:#f92672">);</span>
                mst<span style="color:#f92672">.</span><span style="color:#a6e22e">enqueue</span><span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
                weight <span style="color:#f92672">+=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> Iterable<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">edges</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> mst<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">weight</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> weight<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="prims-algorithm">Prim&rsquo;s algorithm</h3>
<ul>
<li>Start with vertex 0 and greedy grow tree <em>T</em></li>
<li>Add to <em>T</em> the min weight with exactly one endpoint in <em>T</em></li>
<li>Repeat until <em>V</em>-1 edges</li>
</ul>
<h4 id="lazyprim-implementation">LazyPrim Implementation</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LazyPrimMST</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> marked<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> Queue<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;</span> mst<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> MinPQ<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;</span> pq<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">LazyPrimMST</span><span style="color:#f92672">(</span>EdgeWeightedGraph G<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        pq <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MinPQ<span style="color:#f92672">&lt;&gt;();</span>
        mst <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Queue<span style="color:#f92672">&lt;&gt;();</span>
        marked <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        visit<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> 0<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>pq<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">&amp;&amp;</span> mst<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            Edge e <span style="color:#f92672">=</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">delMin</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">either</span><span style="color:#f92672">(),</span> w <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">other</span><span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>marked<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> marked<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span> <span style="color:#66d9ef">continue</span><span style="color:#f92672">;</span>
            mst<span style="color:#f92672">.</span><span style="color:#a6e22e">enqueue</span><span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>v<span style="color:#f92672">])</span> visit<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> v<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span> visit<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> w<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">visit</span><span style="color:#f92672">(</span>EdgeWeightedGraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        marked<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Edge e <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">other</span><span style="color:#f92672">(</span>v<span style="color:#f92672">)])</span> <span style="color:#f92672">{</span>
                pq<span style="color:#f92672">.</span><span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> Iterable<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">mst</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> mst<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="indexed-priority-queue-implementation">Indexed priority queue implementation</h4>
<ul>
<li>Start as same code as MinPQ</li>
<li>Maintain parallel arrays keys[], pq[], and qp[] so that:
<ul>
<li>keys[i] is the priority of i</li>
<li>pq[i] is the index of the key in heap position i</li>
<li>qp[i] is the heap position of the key with index i</li>
</ul>
</li>
<li>Use swim(qp[i]) implement decreaseKey(i, key).

    <img src="https://s3.ax1x.com/2020/11/26/DBAWWR.png"  class="center"  style="width: 60% ;border-radius: 5px; box-shadow: inset 2px 2px 5px black, 2px 2px 5px black;"  />

</li>
</ul>
<h4 id="eagerprim-implementation">EagerPrim Implementation</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">import</span> edu.princeton.cs.algs4.*<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PrimMST</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> Edge<span style="color:#f92672">[]</span> edgeTo<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">[]</span> distTo<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> marked<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> IndexMinPQ<span style="color:#f92672">&lt;</span>Double<span style="color:#f92672">&gt;</span> pq<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">PrimMST</span><span style="color:#f92672">(</span>EdgeWeightedGraph G<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        edgeTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Edge<span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        distTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        marked <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span>
            distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Double<span style="color:#f92672">.</span><span style="color:#a6e22e">POSITIVE_INFINITY</span><span style="color:#f92672">;</span>
        pq <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> IndexMinPQ<span style="color:#f92672">&lt;&gt;(</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">());</span>
        distTo<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">0</span><span style="color:#f92672">;</span>
        pq<span style="color:#f92672">.</span><span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">0</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>pq<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">())</span>
            visit<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">delMin</span><span style="color:#f92672">());</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">visit</span><span style="color:#f92672">(</span>EdgeWeightedGraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        marked<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Edge e <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">other</span><span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>marked<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span> <span style="color:#66d9ef">continue</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">()</span> <span style="color:#f92672">&lt;</span> distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                edgeTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
                distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">();</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>pq<span style="color:#f92672">.</span><span style="color:#a6e22e">contains</span><span style="color:#f92672">(</span>w<span style="color:#f92672">))</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">change</span><span style="color:#f92672">(</span>w<span style="color:#f92672">,</span> distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]);</span>
                <span style="color:#66d9ef">else</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span>w<span style="color:#f92672">,</span> distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> Iterable<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">edges</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        Queue<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;</span> mst  <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Queue<span style="color:#f92672">&lt;&gt;();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> edgeTo<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> v<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            Edge e <span style="color:#f92672">=</span> edgeTo<span style="color:#f92672">[</span>v<span style="color:#f92672">];</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                mst<span style="color:#f92672">.</span><span style="color:#a6e22e">enqueue</span><span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> mst<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">weight</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">double</span> weight <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">0</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Edge e <span style="color:#f92672">:</span> edges<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            weight <span style="color:#f92672">+=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> weight<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="432">4.3.2</h3>
<p>Draw all of the MSTs of graph depicted at right (all edge weights are equal).</p>

    <img src="https://s3.ax1x.com/2020/11/24/DtaE4K.png"  class="right"  style="width: 30% "  />



    <img src="https://i.postimg.cc/jSSvhPHK/4-3-2.jpg"  class="center"  style="width: 80% ;"  />


<h3 id="433">4.3.3</h3>
<p>Show that if a graph’s edges all have distinct weights, the MST is unique</p>
<ul>
<li>假设无向图G有两棵不同的最小生成树T1和T2</li>
<li>e是在T1或T2中（但不是同时在两棵树中）最小权值的边，不妨假设e在T1中</li>
<li>将e添加到T2中会创建一个环C</li>
<li>在C中至少存在一条边f（但不在T1中，否则会产生环）</li>
<li>因为e是在T1或T2中（但不是同时在两棵树中）最小权值的边，并且每条边权值都不同</li>
<li>所以有e.weight &lt; f.weight</li>
<li>用e代替f，将会产生比原来T2权值更小的生成树，产生了矛盾</li>
</ul>
<h3 id="4313">4.3.13</h3>
<p>Give a counterexample that shows why the following strategy does not necessarily
find the MST: ‘Start with any vertex as a single-vertex MST, then add V-1 edges
to it, always taking next a min-weight edge incident to the vertex most recently added to the MST.’</p>

    <img src="https://i.postimg.cc/cL2PZRSL/4-3-13.png"  class="center"  style="width: 80% ;"  />


<h2 id="shortest-paths">Shortest Paths</h2>
<h3 id="shortest-paths-properties">shortest-paths properties</h3>
<h4 id="data-structures-for-single-source-shortest-paths">Data structures for single-source shortest paths</h4>
<ul>
<li><strong>Goal.</strong> Find the shortest-paths from <em>s</em> to every other vertex.</li>
<li><strong>Observation.</strong> A shortest-paths tree (SPT) solution exists. Why?</li>
<li><strong>Consequence.</strong> Can represent the SPT with two vertex-indexed arrays:
<ul>
<li>distTo[v] is length of shortest path from <em>s</em> to <em>v</em></li>
<li>edgeTo[v] is last edge on shortest path from <em>s</em> to <em>v</em></li>
</ul>
</li>
</ul>
<h4 id="edge-relaxation">Edge relaxation</h4>
<ul>
<li>Relax edge <em>e = v-&gt;w</em>
<ul>
<li>distTo[v] is length of shortest known path from s to v</li>
<li>distTo[w] is length of shortest known path from s to w</li>
<li>edgeTo[w] is last edge on shortest known path from s to w</li>
<li>if e = v-&gt;w gives shorter path to w through v, update both distTo[w] and edgeTo[w]

    <img src="https://i.postimg.cc/fTbTm0tQ/1.jpg"  class="center"  style="width: 80% ;border-radius: 5px; box-shadow: inset 2px 2px 5px black, 2px 2px 5px black;"  />

</li>
</ul>
</li>
</ul>
<h4 id="shortest-paths-optimality-conditions">Shortest-paths optimality conditions</h4>
<ul>
<li><strong>Proposition.</strong> Let <em>G</em> be an edge-weighted digraph. Then distTo[] are the shortest path distances from s iff:
<ul>
<li>distTo[s] = 0</li>
<li>For each vertex v, distTo[v] is the length of some path from s to v</li>
<li>For each edge e = v-&gt;w, distTo[w] &lt;= distTo[v] + e.weight().</li>
</ul>
</li>
<li><strong>Pf.</strong>
<ul>
<li>suppose that distTo[w] &gt; distTo[v] + e.weight() for some edge e = v-&gt;w.</li>
<li>Then, e gives a path from s to w (through v) of length less than distTo[w].
<ul>
<li>distTo[v1] &lt;= distTo[v0] + e1.weight()</li>
<li>distTo[v2] &lt;= distTo[v1] + e2.weight()</li>
<li>&hellip;</li>
<li>distTo[vk] &lt;= distTo[v(k-1)] + ek.weight()</li>
</ul>
</li>
<li>Add inequalities; simplify; and substitude distTo[v0] = distTo[s] = 0: distTo[w] = distTo[vk] &lt;= e1.weight() + e2.weight() + &hellip; + ek.weight()</li>
<li>Thus, distTo[w] is the weight of shortest path to w</li>
</ul>
</li>
</ul>
<h4 id="genertic-shortest-paths-algorithm">Genertic shortest-paths algorithm</h4>
<ul>
<li><strong>Proposition.</strong> Genertic algorithm computes SPT(if it exists) from s.</li>
<li><strong>Pf sketch</strong>
<ul>
<li>Throughout algorithm, distTo[v] is the length of a simple path from s to <em>v</em> (and edgeTo[v] is last edge on path)</li>
<li>Each successful relaxation decreases distTo[v] from some v</li>
<li>The entry distTo[v] can decrease at most a finite number of times</li>
</ul>
</li>
<li><strong>Efficient implementataions</strong> How to choose which edge to relax?
<ul>
<li>Ex 1. Dijkstra&rsquo;s algorithm (nonnegative weights)</li>
<li>Ex 2. Topological sort algorithm (no directed cycles)</li>
<li>Ex 3. Bellman-Ford algorithm (no negative cycles)</li>
</ul>
</li>
</ul>
<h3 id="dijkstras-algorithm">Dijkstra&rsquo;s algorithm</h3>
<h4 id="dijkstras-algorithm-demo">Dijkstra&rsquo;s algorithm Demo</h4>

    <img src="https://i.postimg.cc/mD7ZT0Xb/pic.gif"  class="center"  style="width: 100% ;border-radius: 5px; box-shadow: inset 2px 2px 5px black, 2px 2px 5px black;"  />


<h4 id="correctness-proof">correctness proof</h4>
<ul>
<li>
<p><strong>Proposition.</strong> Dijkstra&rsquo;s algorithm computes a SPT in any edge-weighted diagraph with nonnegative weights.</p>
</li>
<li>
<p><strong>Pf.</strong></p>
<ul>
<li>Each edge e = v-&gt;w is relaxed exactly once (when v is relaxed), leaving distTo[w] &lt;= distTo[v] + e.weight()</li>
<li>Inequality hold until algorithm terminates because:
<ul>
<li>distTo[w] cannot increase &lt;- distTo[] values are monotone decreasing</li>
<li>distTo[v] will not change &lt;- we choose lowest distTo[] value at each step (and edge weights are nonnegative)</li>
</ul>
</li>
<li>Thus, opun termination, shortest-paths optimality conditions hold</li>
</ul>
</li>
</ul>
<h4 id="java-implementation-4">Java implementation</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DijkstraSP</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> DirectedEdge<span style="color:#f92672">[]</span> edgeTo<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">[]</span> distTo<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> IndexMinPQ<span style="color:#f92672">&lt;</span>Double<span style="color:#f92672">&gt;</span> pq<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">DijkstraSP</span><span style="color:#f92672">(</span>EdgeWeightedDigraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        edgeTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DirectedEdge<span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        distTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        pq <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> IndexMinPQ<span style="color:#f92672">&lt;</span>Double<span style="color:#f92672">&gt;(</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">());</span>

        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span>
            distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Double<span style="color:#f92672">.</span><span style="color:#a6e22e">POSITIVE_INFINITY</span><span style="color:#f92672">;</span>
        distTo<span style="color:#f92672">[</span>s<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">0</span><span style="color:#f92672">;</span>
        pq<span style="color:#f92672">.</span><span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span>s<span style="color:#f92672">,</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">0</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>pq<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">delMin</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>DirectedEdge e <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span>
                relax<span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">relax</span><span style="color:#f92672">(</span>DirectedEdge e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">from</span><span style="color:#f92672">(),</span> w <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">to</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">();</span>
            edgeTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>pq<span style="color:#f92672">.</span><span style="color:#a6e22e">contains</span><span style="color:#f92672">(</span>w<span style="color:#f92672">))</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">decreaseKey</span><span style="color:#f92672">(</span>w<span style="color:#f92672">,</span> distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]);</span>
            <span style="color:#66d9ef">else</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span>w<span style="color:#f92672">,</span> distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">distTo</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#66d9ef">return</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">];</span> <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> Iterable<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">pathTo</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Stack<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;</span> path <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>DirectedEdge e <span style="color:#f92672">=</span> edgeTo<span style="color:#f92672">[</span>v<span style="color:#f92672">];</span> e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> e <span style="color:#f92672">=</span> edgeTo<span style="color:#f92672">[</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">from</span><span style="color:#f92672">()])</span>
            path<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> path<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="edge-weighted-dags">edge-weighted DAGs</h3>
<h4 id="acyclic-shortest-paths-demo">Acyclic shortest paths demo</h4>

    <img src="https://i.postimg.cc/j5bbc9gh/ezgif-4-83690900591b.gif"  class="center"  style="width: 90% ;border-radius: 5px; box-shadow: inset 2px 2px 5px black, 2px 2px 5px black;"  />


<h4 id="shortest-paths-in-edge-weighted-dags">Shortest paths in edge-weighted DAGs</h4>
<ul>
<li><strong>Proposition.</strong> Topological sort algorithm computes SPT in any (edge weights can be negative!) edge-weighted DAG in time proportional to <em>E + V</em></li>
<li><strong>Pf.</strong>
<ul>
<li>Each edge e = v-&gt;w is relaxed exactly once (when v is relaxed), leaving distTo[w] &lt;= distTo[v] + e.weight()</li>
<li>Inequality holds until algorithm terminates because:
<ul>
<li>distTo[w] cannot increase &lt;- distTo[] values are monotone decreasing</li>
<li>distTo[v] will not change &lt;- because of topological order, no edge pointing to v will be relaxed after v is relaxed</li>
</ul>
</li>
<li>Thus, upon termination, shortest-paths optimality conditions hold</li>
</ul>
</li>
</ul>
<h4 id="java-implementation-5">Java Implementation</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AcyclicSP</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> DirectedEdge<span style="color:#f92672">[]</span> edgeTo<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">[]</span> distTo<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">AcyclicSP</span><span style="color:#f92672">(</span>EdgeWeightedDigraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        edgeTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DirectedEdge<span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        distTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span>
            distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Double<span style="color:#f92672">.</span><span style="color:#a6e22e">POSITIVE_INFINITY</span><span style="color:#f92672">;</span>
        distTo<span style="color:#f92672">[</span>s<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">0</span><span style="color:#f92672">;</span>
        Topological topological <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Topological<span style="color:#f92672">(</span>G<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">:</span> topological<span style="color:#f92672">.</span><span style="color:#a6e22e">order</span><span style="color:#f92672">())</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>DirectedEdge e <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span>
                relax<span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">relax</span><span style="color:#f92672">(</span>DirectedEdge e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">from</span><span style="color:#f92672">(),</span> w <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">to</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">();</span>
            edgeTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> Iterable<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">pathTo</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Stack<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;</span> path <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>DirectedEdge e <span style="color:#f92672">=</span> edgeTo<span style="color:#f92672">[</span>v<span style="color:#f92672">];</span> e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> e <span style="color:#f92672">=</span> edgeTo<span style="color:#f92672">[</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">from</span><span style="color:#f92672">()])</span>
            path<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> path<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="negative-weights">negative weights</h3>
<ul>
<li><strong>Def.</strong> A negative cycle is a directed cycle whose sum of edge weights is negative.</li>
<li><strong>Proposition.</strong> A SPT exists iff no negative cycles.</li>
</ul>
<h4 id="bellman-ford-algorithm-analysis">Bellman-Ford algorithm: analysis</h4>
<ul>
<li>
<p>Initialize distTo[s] = 0 and distTo[v] = $ \infty $ for all other vertices.</p>
</li>
<li>
<p>Repeat V times:</p>
<ul>
<li>Relax each edge.</li>
</ul>
</li>
<li>
<p><strong>Proposition.</strong> Dynamic programming algorithm computes SPT in any edge-weighted digraph with no negative cycles in time proportional to $E\times V$</p>
</li>
<li>
<p><strong>Pf idea.</strong> After pass i, found shortest path containing at most i edges.</p>
</li>
</ul>
<h4 id="bellman-ford-algorithm-practical-improvement">Bellman-Ford algorithm: practical improvement</h4>
<ul>
<li>
<p><strong>Observation.</strong> If distTo[v] does not change during pass i, no need to relax any edge pointing from v in pass i+1.</p>
</li>
<li>
<p><strong>FIFO implementation.</strong> Maintain queue of vertices whose distTo[] changed.</p>
</li>
<li>
<p><strong>Overall effect.</strong></p>
<ul>
<li>The running time is still proportional to $E \times V $ in worst case.</li>
<li>But much faster than that in practice.</li>
</ul>
</li>
</ul>
<h4 id="bellman-ford-java-implementation">Bellman-Ford Java implementation</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BellmanFordSP</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">[]</span> distTo<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> DirectedEdge<span style="color:#f92672">[]</span> edgeTo<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> Queue<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> queue<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> onQueue<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">BellmanFordSP</span><span style="color:#f92672">(</span>EdgeWeightedDigraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        distTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        onQueue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        edgeTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DirectedEdge<span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span>
            distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Double<span style="color:#f92672">.</span><span style="color:#a6e22e">POSITIVE_INFINITY</span><span style="color:#f92672">;</span>
        distTo<span style="color:#f92672">[</span>s<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">0</span><span style="color:#f92672">;</span>
        queue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Queue<span style="color:#f92672">&lt;&gt;();</span>
        queue<span style="color:#f92672">.</span><span style="color:#a6e22e">enqueue</span><span style="color:#f92672">(</span>s<span style="color:#f92672">);</span>
        onQueue<span style="color:#f92672">[</span>s<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>queue<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">dequeue</span><span style="color:#f92672">();</span>
            onQueue<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            relax<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> v<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">relax</span><span style="color:#f92672">(</span>EdgeWeightedDigraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>DirectedEdge e <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">to</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
                distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">();</span>
                edgeTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>onQueue<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                    queue<span style="color:#f92672">.</span><span style="color:#a6e22e">enqueue</span><span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
                    onQueue<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> Iterable<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">pathTo</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Stack<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;</span> path <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>DirectedEdge e <span style="color:#f92672">=</span> edgeTo<span style="color:#f92672">[</span>v<span style="color:#f92672">];</span> e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> e <span style="color:#f92672">=</span> edgeTo<span style="color:#f92672">[</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">from</span><span style="color:#f92672">()])</span>
            path<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> path<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="single-source-shortest-path-implementation-cost-summary">Single source shortest-path implementation: cost summary</h4>
<table>
<thead>
<tr>
<th>algorithm</th>
<th>restriction</th>
<th>typical case</th>
<th>worst case</th>
<th>extra case</th>
</tr>
</thead>
<tbody>
<tr>
<td>topological sort</td>
<td>no directed cycles</td>
<td>E + V</td>
<td>E + V</td>
<td>V</td>
</tr>
<tr>
<td>Dijkstra (binary heap)</td>
<td>no negative weights</td>
<td>ElogV</td>
<td>ElogV</td>
<td>V</td>
</tr>
<tr>
<td>Bellman-Ford</td>
<td>no negative cycles</td>
<td>EV</td>
<td>EV</td>
<td>V</td>
</tr>
<tr>
<td>Bellman-Ford(queue-based)</td>
<td>no negative cycles</td>
<td>E + V</td>
<td>EV</td>
<td>V</td>
</tr>
</tbody>
</table>
<h3 id="441">4.4.1</h3>
<p>True or false. Adding a constant to every edge weight does not change the solution to the single-source shortest-paths problem.</p>
<p>False. 假设一条最短路径的长度是15, 且一共有五条边，而另外一条简单路径的长度为20，由两条边组成，当每条边的权值都增加5之后，原来长度15的路径长度变为40，原来长度为20的路径长度变为30，可以看到最短路径改变了。</p>
<h3 id="445">4.4.5</h3>
<p>Change the direction of edge 0-&gt;2 in tinyEWD.txt (see page 644). Draw two different
SPTs that are rooted at 2 for this modified edge-weighted digraph.

    <img src="https://i.postimg.cc/fL7gcsnN/graph.png"  class="left"  style="width: 40% ;"  />

</p>
<h3 id="459">4.5.9</h3>
<p>The table below, from an old published road map, purports to give the length of the shortest routes connecting the cities. It contains an error. Correct the table. Also, add a table that shows how to achieve the shortest routes.</p>

    <img src="https://i.postimg.cc/bv8TXN6S/Snipaste-2020-12-04-21-48-19.jpg"  class="center"  style="width: 80% ;"  />


<table>
<thead>
<tr>
<th></th>
<th>Providence</th>
<th>Westerly</th>
<th>New London</th>
<th>Norwich</th>
</tr>
</thead>
<tbody>
<tr>
<td>Providence</td>
<td></td>
<td>53</td>
<td>54</td>
<td>48</td>
</tr>
<tr>
<td>Westerly</td>
<td>53</td>
<td></td>
<td>18</td>
<td>30</td>
</tr>
<tr>
<td>New London</td>
<td>54</td>
<td>18</td>
<td></td>
<td>12</td>
</tr>
<tr>
<td>Norwich</td>
<td>48</td>
<td>30</td>
<td>12</td>
<td></td>
</tr>
</tbody>
</table>
<p>给Providence、Westerly、New London、Norwich 分别编号为0、1、2、3</p>
<p>最短路径：</p>
<table>
<thead>
<tr>
<th></th>
<th>Providence</th>
<th>Westerly</th>
<th>New London</th>
<th>Norwich</th>
</tr>
</thead>
<tbody>
<tr>
<td>Providence</td>
<td></td>
<td>0-1</td>
<td>0-2</td>
<td>0-3</td>
</tr>
<tr>
<td>Westerly</td>
<td>1-0</td>
<td></td>
<td>1-2</td>
<td>1-2、2-3</td>
</tr>
<tr>
<td>New London</td>
<td>2-0</td>
<td>2-1</td>
<td></td>
<td>2-3</td>
</tr>
<tr>
<td>Norwich</td>
<td>3-0</td>
<td>3-2、2-1</td>
<td>3-2</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="string-sorts">String sorts</h2>
<h3 id="key-indexed-counting">key-indexed counting</h3>
<ul>
<li>
<p><strong>Proposition.</strong> Key-indexed counting uses $ ~ 11N+4R $ array accesses to sort a <em>N</em> items whose keys are integers between <em>0</em> and <em>R-1</em>.</p>
</li>
<li>
<p><strong>Proposition.</strong> Key-indexed counting uses extra space proportional to <em>N + R</em></p>
</li>
<li>
<p><strong>Stable.</strong></p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CountingSort</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> R<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> count <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>R<span style="color:#f92672">+</span>1<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> aux <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>N<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
            count<span style="color:#f92672">[</span>a<span style="color:#f92672">[</span>i<span style="color:#f92672">]+</span>1<span style="color:#f92672">]++;</span> <span style="color:#75715e">// count[a[i]+1] = count[a[i+1]] + 1
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> r <span style="color:#f92672">&lt;</span> R<span style="color:#f92672">;</span> r<span style="color:#f92672">++)</span>
            count<span style="color:#f92672">[</span>r<span style="color:#f92672">+</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">+=</span> count<span style="color:#f92672">[</span>r<span style="color:#f92672">];</span> <span style="color:#75715e">// 第一个位置
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
            aux<span style="color:#f92672">[</span>count<span style="color:#f92672">[</span>a<span style="color:#f92672">[</span>i<span style="color:#f92672">]]++]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span> <span style="color:#75715e">// aux[count[a[i]] = count[a[i]]+1] = a[i]
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
            a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> aux<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        String s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;dacffbdbfbea&#34;</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">()];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
            a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">)-</span><span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">;</span>
        sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> 26<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>var e <span style="color:#f92672">:</span> a<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">printf</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;%c &#34;</span><span style="color:#f92672">,</span> e<span style="color:#f92672">+</span><span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="lsd-radix-sort">LSD radix sort</h3>
<h4 id="least-significant-digit-first-string-sort">Least-significant-digit-first string sort</h4>
<ul>
<li>Consider characters from right to left.</li>
<li>Stably sort using dth character as the key (using key-indexed counting).</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LSD</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> W<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> R <span style="color:#f92672">=</span> 256<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
        String<span style="color:#f92672">[]</span> aux <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">[</span>N<span style="color:#f92672">];</span>

        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> d <span style="color:#f92672">=</span> W<span style="color:#f92672">-</span>1<span style="color:#f92672">;</span> d <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">;</span> d<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> count <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>R<span style="color:#f92672">+</span>1<span style="color:#f92672">];</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
                count<span style="color:#f92672">[</span>a<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>d<span style="color:#f92672">)+</span>1<span style="color:#f92672">]++;</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> r <span style="color:#f92672">&lt;</span> R<span style="color:#f92672">;</span> r<span style="color:#f92672">++)</span>
                count<span style="color:#f92672">[</span>r<span style="color:#f92672">+</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">+=</span> count<span style="color:#f92672">[</span>r<span style="color:#f92672">];</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
                aux<span style="color:#f92672">[</span>count<span style="color:#f92672">[</span>a<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>d<span style="color:#f92672">)]++]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
                a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> aux<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        In in <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> In<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;D:\\Java_test\\test1\\src\\StringSort\\strings.txt&#34;</span><span style="color:#f92672">);</span>
        String<span style="color:#f92672">[]</span> a <span style="color:#f92672">=</span> in<span style="color:#f92672">.</span><span style="color:#a6e22e">readAllStrings</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>0<span style="color:#f92672">].</span><span style="color:#a6e22e">length</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
            <span style="color:#66d9ef">assert</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">length</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> w <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;String must have fixed length&#34;</span><span style="color:#f92672">;</span>
        sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> w<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>var e <span style="color:#f92672">:</span> a<span style="color:#f92672">)</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="summary-of-the-performence-of-sorting-algorithms">Summary of the performence of sorting algorithms</h4>

    <img src="https://i.postimg.cc/mkM2KqMV/Snipaste-2020-12-04-21-48-19.jpg"  class="center"  style="zoom: 80% ;"  />


<h3 id="msd-radix-sort">MSD radix sort</h3>
<h4 id="most-significant-digit-first-srting-sort">Most-significant-digit-first srting sort</h4>
<ul>
<li>Partition array into <em>R</em> pieces according to first character (using key-indexed counting).</li>
<li>Recursively sort all strings that start with each character (key-indexed counts delineate subarrays to sort).</li>
</ul>
<h4 id="implementation-3">Implementation</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MSD</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> R <span style="color:#f92672">=</span> 256<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> a<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        String<span style="color:#f92672">[]</span> aux <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">[</span>a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">];</span>
        sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> aux<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">-</span>1<span style="color:#f92672">,</span> 0<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> String<span style="color:#f92672">[]</span> aux<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> hi<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> d<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>hi <span style="color:#f92672">&lt;=</span> lo<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> count <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>R<span style="color:#f92672">+</span>2<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> lo<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;=</span> hi<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
            count<span style="color:#f92672">[</span>charAt<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span> d<span style="color:#f92672">)+</span>2<span style="color:#f92672">]++;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> r <span style="color:#f92672">&lt;</span> R <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span> r<span style="color:#f92672">++)</span>
            count<span style="color:#f92672">[</span>r<span style="color:#f92672">+</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">+=</span> count<span style="color:#f92672">[</span>r<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> lo<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;=</span> hi<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
            aux<span style="color:#f92672">[</span>count<span style="color:#f92672">[</span>charAt<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span> d<span style="color:#f92672">)+</span>1<span style="color:#f92672">]++]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> lo<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;=</span> hi<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
            a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> aux<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> lo<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> r <span style="color:#f92672">&lt;</span> R<span style="color:#f92672">;</span> r<span style="color:#f92672">++)</span>
            sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> aux<span style="color:#f92672">,</span> lo<span style="color:#f92672">+</span>count<span style="color:#f92672">[</span>r<span style="color:#f92672">],</span> lo<span style="color:#f92672">+</span>count<span style="color:#f92672">[</span>r<span style="color:#f92672">+</span>1<span style="color:#f92672">]-</span>1<span style="color:#f92672">,</span> d<span style="color:#f92672">+</span>1<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>String s<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> d<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">()</span> <span style="color:#f92672">&gt;</span> d<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>d<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        In in <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> In<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;D:\\Java_test\\test1\\src\\StringSort\\strings.txt&#34;</span><span style="color:#f92672">);</span>
        String<span style="color:#f92672">[]</span> a <span style="color:#f92672">=</span> in<span style="color:#f92672">.</span><span style="color:#a6e22e">readAllStrings</span><span style="color:#f92672">();</span>
        sort<span style="color:#f92672">(</span>a<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>var e <span style="color:#f92672">:</span> a<span style="color:#f92672">)</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="suffix-arrays">suffix arrays</h3>
<h4 id="longest-repeated-substring-java-implementation">Longest repeated substring: Java implementation</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LRS</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> String <span style="color:#a6e22e">lrs</span><span style="color:#f92672">(</span>String s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">();</span>
        String<span style="color:#f92672">[]</span> suffixes <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">[</span>N<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
            suffixes<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">substring</span><span style="color:#f92672">(</span>i<span style="color:#f92672">,</span> N<span style="color:#f92672">);</span>
        Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>suffixes<span style="color:#f92672">);</span>
        String lrs <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> lcp<span style="color:#f92672">(</span>suffixes<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span> suffixes<span style="color:#f92672">[</span>i<span style="color:#f92672">+</span>1<span style="color:#f92672">]);</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>len <span style="color:#f92672">&gt;</span> lrs<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">())</span>
                lrs <span style="color:#f92672">=</span> suffixes<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">substring</span><span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> len<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> lrs<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lcp</span><span style="color:#f92672">(</span>String s<span style="color:#f92672">,</span> String t<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">(),</span> t<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">());</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> t<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">))</span> <span style="color:#66d9ef">return</span> i<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span> n<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        String s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;aacaagtttacaagc&#34;</span><span style="color:#f92672">;</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>lrs<span style="color:#f92672">(</span>s<span style="color:#f92672">));</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="实验">实验</h2>
<h3 id="percolation">Percolation</h3>
<script type="text/javascript" src="/js/pdf-js/build/pdf.js"></script>
<style>
#the-canvas {
  border: 1px solid black;
  direction: ltr;
  width: 100%;
  height: auto;
}
#paginator{
    text-align: center;
    margin-bottom: 10px;
}
</style>

<div id="paginator">
    <button id="prev">Previous</button>
    <button id="next">Next</button>
    &nbsp; &nbsp;
    <span>Page: <span id="page_num"></span> / <span id="page_count"></span></span>
</div>
<div id="embed-pdf-container">
    <canvas id="the-canvas"></canvas>
</div>

<script type="text/javascript">
window.onload = function() {



var url = "\\pdf\\algs\\exp1.pdf";


var pdfjsLib = window['pdfjs-dist/build/pdf'];


pdfjsLib.GlobalWorkerOptions.workerSrc = '/js/pdf-js/build/pdf.worker.js';


var pdfDoc = null,
    pageNum = 1,
    pageRendering = false,
    pageNumPending = null,
    scale = 3,
    canvas = document.getElementById('the-canvas'),
    ctx = canvas.getContext('2d');



function renderPage(num) {
  pageRendering = true;
  
  pdfDoc.getPage(num).then(function(page) {
    var viewport = page.getViewport({scale: scale});
    canvas.height = viewport.height;
    canvas.width = viewport.width;

    
    var renderContext = {
      canvasContext: ctx,
      viewport: viewport
    };
    var renderTask = page.render(renderContext);

    
    renderTask.promise.then(function() {
      pageRendering = false;
      if (pageNumPending !== null) {
        
        renderPage(pageNumPending);
        pageNumPending = null;
      }
    });
  });

  
  document.getElementById('page_num').textContent = num;
}



function queueRenderPage(num) {
  if (pageRendering) {
    pageNumPending = num;
  } else {
    renderPage(num);
  }
}



function onPrevPage() {
  if (pageNum <= 1) {
    return;
  }
  pageNum--;
  queueRenderPage(pageNum);
}
document.getElementById('prev').addEventListener('click', onPrevPage);



function onNextPage() {
  if (pageNum >= pdfDoc.numPages) {
    return;
  }
  pageNum++;
  queueRenderPage(pageNum);
}
document.getElementById('next').addEventListener('click', onNextPage);



pdfjsLib.getDocument(url).promise.then(function(pdfDoc_) {
  pdfDoc = pdfDoc_;
  document.getElementById('page_count').textContent = pdfDoc.numPages;

  
  renderPage(pageNum);
});
}

</script>
<h3 id="几种排序算法的实验性能比较">几种排序算法的实验性能比较</h3>
<script type="text/javascript" src="/js/pdf-js/build/pdf.js"></script>
<style>
#the-canvas {
  border: 1px solid black;
  direction: ltr;
  width: 100%;
  height: auto;
}
#paginator{
    text-align: center;
    margin-bottom: 10px;
}
</style>

<div id="paginator">
    <button id="prev">Previous</button>
    <button id="next">Next</button>
    &nbsp; &nbsp;
    <span>Page: <span id="page_num"></span> / <span id="page_count"></span></span>
</div>
<div id="embed-pdf-container">
    <canvas id="the-canvas"></canvas>
</div>

<script type="text/javascript">
window.onload = function() {



var url = "\\pdf\\algs\\exp2.pdf";


var pdfjsLib = window['pdfjs-dist/build/pdf'];


pdfjsLib.GlobalWorkerOptions.workerSrc = '/js/pdf-js/build/pdf.worker.js';


var pdfDoc = null,
    pageNum = 1,
    pageRendering = false,
    pageNumPending = null,
    scale = 3,
    canvas = document.getElementById('the-canvas'),
    ctx = canvas.getContext('2d');



function renderPage(num) {
  pageRendering = true;
  
  pdfDoc.getPage(num).then(function(page) {
    var viewport = page.getViewport({scale: scale});
    canvas.height = viewport.height;
    canvas.width = viewport.width;

    
    var renderContext = {
      canvasContext: ctx,
      viewport: viewport
    };
    var renderTask = page.render(renderContext);

    
    renderTask.promise.then(function() {
      pageRendering = false;
      if (pageNumPending !== null) {
        
        renderPage(pageNumPending);
        pageNumPending = null;
      }
    });
  });

  
  document.getElementById('page_num').textContent = num;
}



function queueRenderPage(num) {
  if (pageRendering) {
    pageNumPending = num;
  } else {
    renderPage(num);
  }
}



function onPrevPage() {
  if (pageNum <= 1) {
    return;
  }
  pageNum--;
  queueRenderPage(pageNum);
}
document.getElementById('prev').addEventListener('click', onPrevPage);



function onNextPage() {
  if (pageNum >= pdfDoc.numPages) {
    return;
  }
  pageNum++;
  queueRenderPage(pageNum);
}
document.getElementById('next').addEventListener('click', onNextPage);



pdfjsLib.getDocument(url).promise.then(function(pdfDoc_) {
  pdfDoc = pdfDoc_;
  document.getElementById('page_count').textContent = pdfDoc.numPages;

  
  renderPage(pageNum);
});
}

</script>
<h3 id="map-routing">Map Routing</h3>
<script type="text/javascript" src="/js/pdf-js/build/pdf.js"></script>
<style>
#the-canvas {
  border: 1px solid black;
  direction: ltr;
  width: 100%;
  height: auto;
}
#paginator{
    text-align: center;
    margin-bottom: 10px;
}
</style>

<div id="paginator">
    <button id="prev">Previous</button>
    <button id="next">Next</button>
    &nbsp; &nbsp;
    <span>Page: <span id="page_num"></span> / <span id="page_count"></span></span>
</div>
<div id="embed-pdf-container">
    <canvas id="the-canvas"></canvas>
</div>

<script type="text/javascript">
window.onload = function() {



var url = "\\pdf\\algs\\exp3.pdf";


var pdfjsLib = window['pdfjs-dist/build/pdf'];


pdfjsLib.GlobalWorkerOptions.workerSrc = '/js/pdf-js/build/pdf.worker.js';


var pdfDoc = null,
    pageNum = 1,
    pageRendering = false,
    pageNumPending = null,
    scale = 3,
    canvas = document.getElementById('the-canvas'),
    ctx = canvas.getContext('2d');



function renderPage(num) {
  pageRendering = true;
  
  pdfDoc.getPage(num).then(function(page) {
    var viewport = page.getViewport({scale: scale});
    canvas.height = viewport.height;
    canvas.width = viewport.width;

    
    var renderContext = {
      canvasContext: ctx,
      viewport: viewport
    };
    var renderTask = page.render(renderContext);

    
    renderTask.promise.then(function() {
      pageRendering = false;
      if (pageNumPending !== null) {
        
        renderPage(pageNumPending);
        pageNumPending = null;
      }
    });
  });

  
  document.getElementById('page_num').textContent = num;
}



function queueRenderPage(num) {
  if (pageRendering) {
    pageNumPending = num;
  } else {
    renderPage(num);
  }
}



function onPrevPage() {
  if (pageNum <= 1) {
    return;
  }
  pageNum--;
  queueRenderPage(pageNum);
}
document.getElementById('prev').addEventListener('click', onPrevPage);



function onNextPage() {
  if (pageNum >= pdfDoc.numPages) {
    return;
  }
  pageNum++;
  queueRenderPage(pageNum);
}
document.getElementById('next').addEventListener('click', onNextPage);



pdfjsLib.getDocument(url).promise.then(function(pdfDoc_) {
  pdfDoc = pdfDoc_;
  document.getElementById('page_count').textContent = pdfDoc.numPages;

  
  renderPage(pageNum);
});
}

</script>
<h3 id="text-indexing">Text Indexing</h3>
<script type="text/javascript" src="/js/pdf-js/build/pdf.js"></script>
<style>
#the-canvas {
  border: 1px solid black;
  direction: ltr;
  width: 100%;
  height: auto;
}
#paginator{
    text-align: center;
    margin-bottom: 10px;
}
</style>

<div id="paginator">
    <button id="prev">Previous</button>
    <button id="next">Next</button>
    &nbsp; &nbsp;
    <span>Page: <span id="page_num"></span> / <span id="page_count"></span></span>
</div>
<div id="embed-pdf-container">
    <canvas id="the-canvas"></canvas>
</div>

<script type="text/javascript">
window.onload = function() {



var url = "\\pdf\\algs\\exp4.pdf";


var pdfjsLib = window['pdfjs-dist/build/pdf'];


pdfjsLib.GlobalWorkerOptions.workerSrc = '/js/pdf-js/build/pdf.worker.js';


var pdfDoc = null,
    pageNum = 1,
    pageRendering = false,
    pageNumPending = null,
    scale = 3,
    canvas = document.getElementById('the-canvas'),
    ctx = canvas.getContext('2d');



function renderPage(num) {
  pageRendering = true;
  
  pdfDoc.getPage(num).then(function(page) {
    var viewport = page.getViewport({scale: scale});
    canvas.height = viewport.height;
    canvas.width = viewport.width;

    
    var renderContext = {
      canvasContext: ctx,
      viewport: viewport
    };
    var renderTask = page.render(renderContext);

    
    renderTask.promise.then(function() {
      pageRendering = false;
      if (pageNumPending !== null) {
        
        renderPage(pageNumPending);
        pageNumPending = null;
      }
    });
  });

  
  document.getElementById('page_num').textContent = num;
}



function queueRenderPage(num) {
  if (pageRendering) {
    pageNumPending = num;
  } else {
    renderPage(num);
  }
}



function onPrevPage() {
  if (pageNum <= 1) {
    return;
  }
  pageNum--;
  queueRenderPage(pageNum);
}
document.getElementById('prev').addEventListener('click', onPrevPage);



function onNextPage() {
  if (pageNum >= pdfDoc.numPages) {
    return;
  }
  pageNum++;
  queueRenderPage(pageNum);
}
document.getElementById('next').addEventListener('click', onNextPage);



pdfjsLib.getDocument(url).promise.then(function(pdfDoc_) {
  pdfDoc = pdfDoc_;
  document.getElementById('page_count').textContent = pdfDoc.numPages;

  
  renderPage(pageNum);
});
}

</script>
]]></content>
        </item>
        
        <item>
            <title>OOP(C&#43;&#43;)</title>
            <link>https://fffzlfk.gitlab.io/posts/oopc&#43;&#43;/</link>
            <pubDate>Tue, 06 Oct 2020 12:25:11 +0800</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/posts/oopc&#43;&#43;/</guid>
            <description>Object-Oriented Programming</description>
            <content type="html"><![CDATA[<h2 id="c基础">C++基础</h2>
<h3 id="c对c的扩充">C++对C的扩充</h3>
<h4 id="名字空间">名字空间</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">namespace</span> ns1{
    <span style="color:#66d9ef">int</span> inflag;
}
<span style="color:#66d9ef">namespace</span> ns2{
    <span style="color:#66d9ef">int</span> inflag;
}

ns1<span style="color:#f92672">::</span>inflag<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;
ns2<span style="color:#f92672">::</span>inflag<span style="color:#f92672">=-</span><span style="color:#ae81ff">3</span>;
<span style="color:#75715e">// using ns1::inflag; inflag=2;
</span><span style="color:#75715e">// ns2::inflag=-3;
</span></code></pre></div><h4 id="用const定义常量">用const定义常量</h4>
<ul>
<li>用const定义标识符常量时，<strong>一定要对其初始化</strong>，这是唯一方法。</li>
</ul>
<h4 id="引用">引用</h4>
<ul>
<li>
<p>对变量起另外一个名字，这个名字称为该变量的引用。</p>
</li>
<li>
<p>其中原变量名必须是一个已定义过的变量。</p>
</li>
<li>
<p>引用并没有重新在内存中开辟存储单元，只是引用原变量的单元。</p>
</li>
<li>
<p>对引用的初始化，可以用一个变量名，也可以用另一个引用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span>   a<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>;
<span style="color:#66d9ef">int</span>  <span style="color:#f92672">&amp;</span>b<span style="color:#f92672">=</span>a;
<span style="color:#66d9ef">int</span>  <span style="color:#f92672">&amp;</span>c<span style="color:#f92672">=</span>b;
</code></pre></div></li>
<li>
<p>引用同变量一样有地址，可以对其地址进行操作，即将其地址赋给一指针。</p>
</li>
<li>
<p>对const常量的引用使用如下方式：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">  <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>ri <span style="color:#f92672">=</span> i;
  <span style="color:#75715e">// ri = 10;  错误
</span><span style="color:#75715e"></span>  i <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;    <span style="color:#75715e">//正确
</span><span style="color:#75715e"></span>  cout <span style="color:#f92672">&lt;&lt;</span> ri;
</code></pre></div></li>
<li>
<p>以下的声明是非法的</p>
<ul>
<li>企图建立void类型的引用 void &amp;a</li>
<li>企图建立引用的数组 int &amp;a[6]</li>
<li>企图建立指向引用的指针 int &amp;*p</li>
</ul>
</li>
<li>
<p>指针和引用的区别：</p>
<ul>
<li>指针是通过地址<strong>间接</strong>访问某个变量，而引用是通过别名<strong>直接</strong>访问某个变量。</li>
<li>引用必须初始化，而<strong>一旦初始化后不再作为其他变量的别名</strong>。指针若不进行初始化，编译器不会报错。</li>
</ul>
</li>
</ul>
<h4 id="引用与函数">引用与函数</h4>
<ul>
<li>函数的返回值为引用类型

    <img src="https://i.postimg.cc/P5PdH4VS/1.jpg"  class="center"  style="zoom: 45% ;"  />

</li>
</ul>
<h4 id="内联函数">内联函数</h4>
<ul>
<li>调用内联函数时，编译器首先检查调用是否正确（类型安全检查或者自动进行类型转换）。如果正确，则<strong>将内联函数的代码直接替换函数调用，并用实参换型参</strong>，于是省去了函数调用的开销。因此，内联机制增加了空间开销而节约了时间开销。</li>
</ul>
<h3 id="第一次上级题目">第一次上级题目</h3>
<ol>
<li>求2个或3个正整数中的最大数，用带有默认参数的函数实现。</li>
<li>输入三个整数，将它们按由小到大的顺序输出，要求使用变量的引用。</li>
<li>编写一个程序，用同一个函数名对几个数据进行从小到大排序，数据类型可以是整型、浮点型。用重载函数实现。</li>
<li>对第3题改用函数模板实现，并与第3题程序进行对比分析。</li>
<li>设计一个日期Date类，它能实现年月日的输入和输出，要求分别将成员函数定义在类体内和类体外。</li>
<li>声明一个Circle类，有数据成员Radius（半径）、成员函数GetArea（）计算圆的面积，构造一个Circle的对象进行测试。</li>
<li>编写一个基于对象的程序，求出3个长方柱的体积。数据成员包括length(长)、width(宽)、height(高)。要求用成员函数实现以下功能：<br>
(1) 由键盘分别输入3个长方柱的长、宽、高；<br>
(2) 计算长方柱的体积；<br>
(3) 输出3个长方柱的体积。</li>
</ol>
<h4 id="源码下载">源码下载</h4>
<p><a href="/0x01/test1.cpp">1</a><br>
<a href="/0x01/test2.cpp">2</a><br>
<a href="/0x01/test3.cpp">3</a><br>
<a href="/0x01/test4.cpp">4</a><br>
<a href="/0x01/test5.cpp">5</a><br>
<a href="/0x01/test6.cpp">6</a><br>
<a href="/0x01/test7.cpp">7</a></p>
<h2 id="类和对象">类和对象</h2>
<h3 id="复制构造函数调用时机">复制构造函数调用时机</h3>
<ol>
<li>程序中需要新建立一个对象，并用另一个同类的对象对它初始化</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Box <span style="color:#a6e22e">box1</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>);
Box box2 <span style="color:#f92672">=</span> box1; <span style="color:#75715e">// Box box2(box1);
</span></code></pre></div><ol start="2">
<li>当函数的参数为类对象时，在调用函数时需要将实参对象完整的传递给形参</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>(Box b) {
  <span style="color:#75715e">// do something...
</span><span style="color:#75715e"></span>}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  Box box1(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>);
  fun(box1);
}
</code></pre></div><ol start="3">
<li>当函数的返回值是类的对象，在函数调用完毕将返回值带回函数调用处时</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Box <span style="color:#a6e22e">f1</span>() {
  Box box1(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>);
  <span style="color:#66d9ef">return</span> box1;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  Box box2;
  box2 <span style="color:#f92672">=</span> f();
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="指向非静态成员函数的指针">指向非静态成员函数的指针</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/* Author: fffzlfk */</span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Node(<span style="color:#66d9ef">int</span> xx, <span style="color:#66d9ef">int</span> yy) <span style="color:#f92672">:</span> x(xx), y(yy){}
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get_x</span>() { <span style="color:#66d9ef">return</span> x; }
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get_y</span>() { <span style="color:#66d9ef">return</span> y; }
   <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> x, y;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Node node(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);
    <span style="color:#66d9ef">int</span> (Node<span style="color:#f92672">::*</span>p_x)() <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>Node<span style="color:#f92672">::</span>get_x; <span style="color:#75715e">// 需要加类名和作用域运算符
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> (Node<span style="color:#f92672">::*</span>p_y)() <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>Node<span style="color:#f92672">::</span>get_y;
	cout <span style="color:#f92672">&lt;&lt;</span> (node.<span style="color:#f92672">*</span>p_x)() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
	cout <span style="color:#f92672">&lt;&lt;</span> (node.<span style="color:#f92672">*</span>p_y)() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="指向静态成员函数的指针">指向静态成员函数的指针</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/* Author: fffzlfk */</span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> get() { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">666</span>; }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>p)() <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>A<span style="color:#f92672">::</span>get;
    cout <span style="color:#f92672">&lt;&lt;</span> p() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#f92672">*</span>p)(); <span style="color:#75715e">// 加不加*都可
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="对象引用的作用">对象引用的作用</h3>
<style type="text/css">.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative}</style>
<svg width="0" height="0" display="none" xmlns="http://www.w3.org/2000/svg"><symbol id="tip-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"/></symbol><symbol id="note-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="warning-notice" viewBox="0 0 576 512" preserveAspectRatio="xMidYMid meet"><path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="info-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/></symbol></svg><div class="notice tip" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"></use></svg></span>Tip</p><ol>
<li>避免通过值来传递对象，而是通过引用来传递</li>
<li>参数传递的是引用，没有构造函数或析构函数被调用，节约了系统资源，提高了运行效率</li>
</ol></div>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/* Author: fffzlfk */</span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Student();
	Student <span style="color:#a6e22e">returnS</span>(Student s) { <span style="color:#66d9ef">return</span> s; }
    Student(<span style="color:#66d9ef">const</span> Student <span style="color:#f92672">&amp;</span>e) { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Copy Constructor</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>; }
    <span style="color:#f92672">~</span>Student() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Destructor</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>; }
};
Student<span style="color:#f92672">::</span>Student() {}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Student stu1;
    stu1.returnS(stu1);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出为：<br>
Copy Constructor<br>
Copy Constructor<br>
Destructor<br>
Destructor<br>
Destructor<br>
修改为</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Student<span style="color:#f92672">&amp;</span> returnS(Student <span style="color:#f92672">&amp;</span>s) { <span style="color:#66d9ef">return</span> s; }
</code></pre></div><p>之后，输出：<br>
Destructor</p>
<h3 id="关于数据成员初始化">关于数据成员初始化</h3>
<table>
<thead>
<tr>
<th>数据成员</th>
<th>成员初始化列表</th>
<th>构造函数体内</th>
<th>类外</th>
</tr>
</thead>
<tbody>
<tr>
<td>普通数据成员</td>
<td>$\checkmark $</td>
<td>$\checkmark $</td>
<td></td>
</tr>
<tr>
<td>常数据成员</td>
<td>$\checkmark $</td>
<td></td>
<td></td>
</tr>
<tr>
<td>静态数据成员</td>
<td></td>
<td></td>
<td>$\checkmark $</td>
</tr>
<tr>
<td>静态常数据成员</td>
<td></td>
<td></td>
<td>$\checkmark $</td>
</tr>
</tbody>
</table>
<h3 id="常对象">常对象</h3>
<div class="notice tip" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"></use></svg></span>Tip</p><ol>
<li>
<p>常对象的所有数据成员都是常量，不能改变。因此，常对象必须初始化。</p>
</li>
<li>
<p>不能通过常对象调用普通的成员函数，可以调用常成员函数。</p>
</li>
<li>
<p>如果要修改常对象中某个数据成员的值，可以将数据成员声明为mutable，这样就可以用声明为const的成员函数来修改它的值。</p>
</li>
</ol></div>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/* Author: fffzlfk */</span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">mutable</span> <span style="color:#66d9ef">int</span> i; <span style="color:#75715e">// 可以用常成员函数来修改
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	A() {} <span style="color:#75715e">//常对象必须初始化
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f_const</span>() <span style="color:#66d9ef">const</span> {
		i<span style="color:#f92672">++</span>;
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;f_const()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
	}
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;f()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
	}
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">const</span> A a; <span style="color:#75715e">//常对象必须初始化
</span><span style="color:#75715e"></span>	a.f_const(); <span style="color:#75715e">//常对象只能调用常成员函数
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="常成员">常成员</h4>
<ul>
<li>
<p>常数据成员</p>
<div class="notice tip" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"></use></svg></span>Tip</p><ol>
<li>
<p>在任何函数中都不能对常数据成员赋值</p>
</li>
<li>
<p>只能通过构造函数的参数初始化表对常数据成员进行初始化</p>
</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> Hour;
Time<span style="color:#f92672">::</span>Time(<span style="color:#66d9ef">int</span> h) <span style="color:#f92672">:</span> Hour(h) {}
</code></pre></div><ol start="3">
<li>类的所有对象中的常数据成员的值均不能改变，但不同对象中的该数据成员可以不同（在定义对象时给出）</li>
</ol></div>

<ul>
<li>示例程序：</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/* Author: fffzlfk */</span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  A(<span style="color:#66d9ef">int</span> i) <span style="color:#f92672">:</span> a(i) {} <span style="color:#75715e">// 非静态常数据成员只能通过初始化表来获得初值
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>() {
    cout <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> b <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
  }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> a;
  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> b;
};
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> A<span style="color:#f92672">::</span>b <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">// 静态常数据成员只能在类外初始化
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  A a1(<span style="color:#ae81ff">100</span>), a2(<span style="color:#ae81ff">0</span>);
  a1.print();
  a2.print();
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div></li>
<li>
<p>常成员函数</p>
<div class="notice tip" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"></use></svg></span>Tip</p><ol>
<li>通过常成员函数来引用本类中的数据成员，但不能修改他们</li>
<li>const 是函数类型的一部分，在声明函数时都要有const，在调用时不必加const</li>
<li>常成员函数不能更新对象的数据成员，也不能调用该类中的非const成员函数</li>
<li>通过常对象只能调用它的常成员函数，而不能调用其他成员函数</li>
<li>常对象中的成员函数不是常成员函数，除非成员函数有const修饰</li>
<li>const关键字可以用于对重载函数的区分</li>
</ol></div>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/* Author: fffzlfk */</span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">R</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  R(<span style="color:#66d9ef">int</span> r1, <span style="color:#66d9ef">int</span> r2) {
    R1 <span style="color:#f92672">=</span> r1;
    R2 <span style="color:#f92672">=</span> r2;
  }
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>() {
    cout <span style="color:#f92672">&lt;&lt;</span> R1 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;-&#39;</span> <span style="color:#f92672">&lt;&lt;</span> R2 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
  }
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>() <span style="color:#66d9ef">const</span> {
    cout <span style="color:#f92672">&lt;&lt;</span> R1 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;+&#34;</span> <span style="color:#f92672">&lt;&lt;</span> R2 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
  }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">int</span> R1, R2;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  R a(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>);
  a.print(); <span style="color:#75715e">// 普通对象a调用普通成员函数
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> R b(<span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">5</span>);
  b.print(); <span style="color:#75715e">// 常对象b调用常成员函数
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div></li>
<li>
<p>const成员和非const成员之间的调用关系</p>
<table>
<thead>
<tr>
<th>数据成员</th>
<th>非const成员函数</th>
<th>const成员函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>非const数据成员</td>
<td>可以引用，也可以改变值</td>
<td><!-- raw HTML omitted -->可以引用，但不可以改变值<!-- raw HTML omitted --></td>
</tr>
<tr>
<td>const数据成员</td>
<td>可以引用，但不能改变值</td>
<td>可以引用，但不可以改变值</td>
</tr>
<tr>
<td>const对象的数据成员</td>
<td><!-- raw HTML omitted -->不允许引用和改变值<!-- raw HTML omitted --></td>
<td>可以引用，不可以改变值</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="const与指针">const与指针</h4>
<ul>
<li>
<p>指向对象的<!-- raw HTML omitted -->常指针<!-- raw HTML omitted -->指针本身的值不能改变，即其指向不能改变。</p>
<p><strong><!-- raw HTML omitted -->类名 *const 指针变量名 = 对象地址<!-- raw HTML omitted --></strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Time <span style="color:#a6e22e">t1</span>(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">15</span>), t2;
Time <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> ptr1 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>t1;
ptr1 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>t2; <span style="color:#75715e">//错误，ptr1不能改变指向
</span><span style="color:#75715e"></span>
</code></pre></div><div class="notice tip" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"></use></svg></span>Tip</p><p>常指针始终指向同一个对象，但是可以改变其所指对象中数据成员的值。</p></div>

</li>
<li>
<p><!-- raw HTML omitted -->指向常对象的指针<!-- raw HTML omitted --></p>
<p><strong><!-- raw HTML omitted -->const 类名 *指针变量名 = 对象地址<!-- raw HTML omitted --></strong></p>
<ul>
<li>
<p>如果存在一个常对象，只能用指向常对象的指针去指向它，而不能用非const型的指针去指向它。</p>
</li>
<li>
<p>指向常对象的指针还可以指向非const型的对象，此时不能通过指针改变该对象的值，但是通过该对象本身来改变。指针本身的值也可以改变。</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Time <span style="color:#a6e22e">t1</span>(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">15</span>), t2;
<span style="color:#66d9ef">const</span> Time <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>t1; <span style="color:#75715e">// p是指向常对象的指针，并指向t1对象
</span><span style="color:#75715e"></span>(<span style="color:#f92672">*</span>p).hour <span style="color:#f92672">=</span> <span style="color:#ae81ff">18</span>;      <span style="color:#75715e">// 错误，不能通过指针改变t1的值
</span><span style="color:#75715e"></span>t1.hour <span style="color:#f92672">=</span> <span style="color:#ae81ff">18</span>;        <span style="color:#75715e">// 正确，t1不是常对象
</span><span style="color:#75715e"></span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>t2;             <span style="color:#75715e">// 正确，p改为指向t2
</span></code></pre></div><div class="notice note" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#note-notice"></use></svg></span>Note</p><p>指向常对象的指针可以指向const和非const型的对象，而指向非const型对象的指针只能指向非const的对象。</p></div>

</li>
</ul>
<h3 id="对象数组">对象数组</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/* Author: fffzlfk */</span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Box</span> {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Box(<span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>, <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>, <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> <span style="color:#ae81ff">15</span>)
        <span style="color:#f92672">:</span> height(h), width(w), length(len) {}
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">volume</span>();

  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> height, width, length;
};

<span style="color:#66d9ef">int</span> Box<span style="color:#f92672">::</span>volume() { <span style="color:#66d9ef">return</span> height <span style="color:#f92672">*</span> width <span style="color:#f92672">*</span> length; }

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// Box a[2]{{10, 12, 15}, {15, 18, 20}}; C++11标准
</span><span style="color:#75715e"></span>    Box a[<span style="color:#ae81ff">2</span>]{Box(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">15</span>),
            Box(<span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">20</span>)};  <span style="color:#75715e">// Box a[2] = {Box(10, 12, 15), Box(15, 18,
</span><span style="color:#75715e"></span>                                <span style="color:#75715e">// 20)}; 加不加等号都可
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> a[<span style="color:#ae81ff">0</span>].volume() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> a[<span style="color:#ae81ff">1</span>].volume() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
}
</code></pre></div><h3 id="类模板">类模板</h3>
<p><!-- raw HTML omitted -->类模板是对一批仅有成员数据类型不同的类的抽象<!-- raw HTML omitted --></p>
<blockquote>
<p><a href="https://blog.csdn.net/WChQGouge/article/details/100085331"><em>关于函数模板</em></a></p>
</blockquote>
<h4 id="类模板中的成员函数的定义">类模板中的成员函数的定义</h4>
<ol>
<li>
<p>可以放在类模板的定义定义体中（此时与类中的成员函数定义方法一致）</p>
</li>
<li>
<p>也可以放在类模板的外部，此时成员函数的定义格式如下：</p>
</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#960050;background-color:#1e0010">类型参数</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">返回值类型</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">类模板名</span><span style="color:#f92672">&gt;&lt;</span><span style="color:#960050;background-color:#1e0010">类型参数</span><span style="color:#f92672">&gt;::&lt;</span><span style="color:#960050;background-color:#1e0010">函数名</span><span style="color:#f92672">&gt;</span> (<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">参数表</span><span style="color:#f92672">&gt;</span>) {
<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">函数体</span><span style="color:#f92672">&gt;</span>
}
</code></pre></div><div class="notice warn" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#warn-notice"></use></svg></span></p><p>在类模板外定义成员函数时，<!-- raw HTML omitted -->每一个<!-- raw HTML omitted -->函数前均加上：<br>
<strong>template &lt;class 类型参数&gt;</strong></p></div>

<h3 id="第二次上机题目">第二次上机题目</h3>
<ol>
<li>编写设计一个People（人）类。该类的数据成员有年龄（age）、身高（height）、体重（weight）和人数（num），其中人数为静态数据成员，成员函数有构造函数（People）、进食（Eating）、运动（Sporting）、睡眠（Sleeping）、显示（Show）和显示人数（ShowNum）。其中构造函数由已知参数年龄(a)、身高(h)和体重(w)构造对象，进食函数使体重加1，运动函数使身高加1，睡眠函数使年龄、身高、体重各加1，显示函数用于显示人的年龄、身高、体重，显示人数函数为静态成员函数，用于显示人的个数。假设年龄的单位为岁，身高的单位为厘米，体重的单位为市斤，要求所有数据成员为protected访问权限，所有成员函数为public访问权限，在主函数中通过对象直接访问类的所有成员函数。</li>
<li>定义一个描述学生（Student）基本情况的类，数据成员包括姓名(name)、学号(num)、数学成绩(mathScore)、英语成绩(englishScore)、人数(count)、数学总成绩(mathTotalScore)和英语总成绩(englishTotalScore)。其中姓名定义为长度为18的字符数组，其他数据成员类型为整型，数学总成绩、英语总成绩和人数为静态数据成员，函数成员包括构造函数、显示基本数据函数（ShowBase）和显示静态数据函数(showStatic)，其中构造函数由已知参数姓名(nm)、学号(nu)、数学成绩(math)和英语成绩(english)构造对象，显示基本数据函数用于显示学生的姓名、学号、数学成绩、英语成绩，显示静态数据函数为静态成员函数，用于显示人数、数学总成绩、英语总成绩；要求所有数据成员为private访问权限，所有成员函数为public访问权限，在主函数中定义若干个学生对象，分别显示学生基本信息，以及显示学生人数，数学总成绩与英语总成绩。</li>
<li>定义一个Dog，包含name、age、sex和weight等属性以及对这些属性操作的方法。要求用字符指针描述name，并且用对象指针来测试这个类。</li>
<li>管理个人活期账户：个人储蓄活期账户包括账号、户名、密码、余额、活期年利率等信息。要求能够对个人账户进行存钱、取钱、计算年利息、打印账户相关信息等操作。编写主函数测试账户相关功能。
5．建立一个对象数组，内放5个学生的数据（学号、成绩），（1）用指针指向数组首元素，输出第1，3，5个学生的数据；（2）设立一个函数max，用指向对象的指针作函数参数，在max函数中找出5个学生中成绩最高者，并输出其学号。</li>
</ol>
<h4 id="源码下载-1">源码下载</h4>
<p><a href="/0x02/test1.cc">1</a><br>
<a href="/0x02/test2.cc">2</a><br>
<a href="/0x02/test3.cc">3</a><br>
<a href="/0x02/test4.cc">4</a><br>
<a href="/0x02/test5.cc">5</a></p>
<h2 id="运算符重载">运算符重载</h2>
<h3 id="不能重载的运算符">不能重载的运算符</h3>
<table>
<thead>
<tr>
<th>不能重载的运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>::</td>
<td>作用域运算符</td>
</tr>
<tr>
<td>.</td>
<td>成员访问运算符</td>
</tr>
<tr>
<td>.*</td>
<td>成员指针</td>
</tr>
<tr>
<td>?:</td>
<td>条件运算符</td>
</tr>
<tr>
<td>sizeof</td>
<td>长度运算符</td>
</tr>
</tbody>
</table>
<h3 id="重载为类的成员函数">重载为类的成员函数</h3>
<blockquote>
<p><strong>&lt;函数类型&gt; operator &lt;运算符&gt;(&lt;参数表&gt;) {函数体}</strong></p>
</blockquote>
<ul>
<li>C++中不允许重载有三个操作数的运算符</li>
<li>运算符作为成员函数时<strong>最多有一个形参</strong>：参数可以是对象，对象的引用，或其它类型的参数</li>
<li>运算符重载的<strong>实质就是函数重载</strong></li>
<li>运算符重载的函数参数<strong>就是该运算符涉及的操作数</strong></li>
</ul>
<h4 id="单目运算符的重载--">单目运算符的重载++、&ndash;</h4>
<ul>
<li>++为<strong>前置运算符</strong>时：<strong><!-- raw HTML omitted --> operator++() {&hellip;}</strong></li>
<li>++为<strong>后置运算符</strong>时：<strong><!-- raw HTML omitted --> operator++(int) {&hellip;}</strong></li>
</ul>
<h3 id="友元函数">友元函数</h3>
<p>有时候需要某些函数访问对象的私有成员，可以通过声明该函数为类的友元函数</p>
<div class="notice tip" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"></use></svg></span>Tip</p><ul>
<li>友元函数是可以直接访问类的私有成员的非成员函数。</li>
<li>它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend，其格式如下：<br>
<strong>friend 类型 函数名(形式参数);</strong></li>
</ul></div>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
    <span style="color:#66d9ef">int</span> i;

  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">void</span> foo(A);
};
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(A a) { cout <span style="color:#f92672">&lt;&lt;</span> a.i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    A a;
    foo(a);
}
</code></pre></div><ul>
<li>
<p>大多数情况下友元函数是某个类的成员函数，即A类中的某个成员函数是B类中的友元函数，这个成员函数可以直接访问B类中的私有数据。这实现了类与类之间的沟通。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {               <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> {
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun</span>(B <span style="color:#f92672">&amp;</span>);          <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">void</span> A<span style="color:#f92672">::</span>fun(B <span style="color:#f92672">&amp;</span>b);
};                      };
</code></pre></div></li>
<li>
<p>友元类</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {             <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> {
  ...                   ...
  <span style="color:#75715e">// B类是A类的友元       // B类可以自由使用A类中的成员
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span>;     }<span style="color:#960050;background-color:#1e0010">；</span>
};
</code></pre></div></li>
</ul>
<h3 id="重载为类的友元函数">重载为类的友元函数</h3>
<p><strong>friend &lt;函数值类型&gt; operator&lt;运算符&gt;(&lt;参数表&gt;) {函数体}</strong></p>
<ul>
<li>运算符重载为类的友元函数****最多只能有两个参数**</li>
<li>如果重载双目运算符，则第一个参数代表左操作数，第二个参数代表右操作数</li>
</ul>
<h4 id="单目运算符重载">单目运算符重载</h4>
<ul>
<li>++为<strong>前置</strong>运算符时，它的运算符重载函数的一般格式为：<strong>A operator ++(A &amp;a)</strong></li>
<li>++为<strong>后置</strong>运算符时，它的运算符重载函数的一般格式为：<strong>A operator ++(A &amp;a, int)</strong>(使用哑元区分)</li>
</ul>
<h3 id="重载输入输出运算符">重载输入输出运算符</h3>
<ul>
<li>
<p><strong>输入</strong>运算符：<strong>friend istream &amp;  operater &raquo;(istream &amp;is, ClassName &amp;f){…}</strong></p>
</li>
<li>
<p><strong>输出</strong>运算符：<strong>friend  ostream &amp;  operater &laquo;(ostream &amp;, ClassName &amp;){&hellip;}</strong></p>
</li>
</ul>
<h3 id="函数对象">函数对象</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">operator</span>()(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;operator() called. &#34;</span> <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">&lt;&lt;</span> b <span style="color:#f92672">&lt;&lt;</span> endl;
        <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b;
    }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Test sum;
    <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> sum(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>);  <span style="color:#75715e">// sum看上去像是一个函数，故也称“函数对象”
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a + b = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> s <span style="color:#f92672">&lt;&lt;</span> endl;
}
</code></pre></div><h3 id="类型转换运算符重载">类型转换运算符重载</h3>
<h4 id="基本类型到类类型的转换">基本类型到类类型的转换</h4>
<ul>
<li>如果<strong>直接将数据赋值给对象</strong>，所赋入的数据要强制类型转换，这种转换<strong>需要调用构造函数</strong>。也就是利用<strong>构造函数</strong>能完成基本类型到类类型的转换</li>
<li>使用构造函数进行类型转换必须有一个前提，那就是在这个类中定义一个只有一个参数的构造函数（或者其他参数有默认值）——<strong>转换构造函数</strong></li>
</ul>
<h4 id="类类型到基本类型的转换">类类型到基本类型的转换</h4>
<ul>
<li>
<p>C++引入一种特殊的成员函数——<strong>类型转换函数</strong>。类型转换函数实际上就是一个类型转换运算符重载函数</p>
</li>
<li>
<p>类型转换函数专门用来将类类型转换为基本数据类型，它只能被重载为成员函数</p>
</li>
<li>
<p>重载类型转换运算符函数格式：<br>
<strong>operator〈返回基本类型名〉（）
{
……
return 〈基本类型值〉
}</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
    <span style="color:#66d9ef">int</span> i;

  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    A(<span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> i(a) {}
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">show</span>(<span style="color:#66d9ef">void</span>) { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
    <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">int</span>() { <span style="color:#66d9ef">return</span> i; }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    A a1(<span style="color:#ae81ff">10</span>), a2(<span style="color:#ae81ff">20</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> a1 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> a2 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div></li>
</ul>
<h3 id="示例代码">示例代码</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Complex</span> {
    <span style="color:#66d9ef">double</span> real, imag;

   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Complex(<span style="color:#66d9ef">double</span> r <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>, <span style="color:#66d9ef">double</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>) <span style="color:#f92672">:</span> real(r), imag(i) {}
    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">getReal</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> real; }
    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">getImag</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> imag; }
    Complex <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>();
    Complex <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>(<span style="color:#66d9ef">int</span>);
    Complex <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(Complex <span style="color:#f92672">&amp;</span>);
    Complex <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(<span style="color:#66d9ef">double</span> d);
    <span style="color:#66d9ef">friend</span> istream <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">&gt;&gt;</span>(istream <span style="color:#f92672">&amp;</span>, Complex <span style="color:#f92672">&amp;</span>);
    <span style="color:#66d9ef">friend</span> ostream <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;&lt;</span>(ostream <span style="color:#f92672">&amp;</span>, <span style="color:#66d9ef">const</span> Complex <span style="color:#f92672">&amp;</span>);
};

Complex Complex<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>() { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Complex</span>(<span style="color:#f92672">++</span>real, imag); }

Complex Complex<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>(<span style="color:#66d9ef">int</span> a) { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Complex</span>(real<span style="color:#f92672">++</span>, imag); }

Complex Complex<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(Complex <span style="color:#f92672">&amp;</span>c) {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Complex</span>(real <span style="color:#f92672">+</span> c.real, imag <span style="color:#f92672">+</span> c.imag);
}

Complex Complex<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(<span style="color:#66d9ef">double</span> d) { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Complex</span>(real <span style="color:#f92672">+</span> d, imag); }

istream <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">&gt;&gt;</span>(istream <span style="color:#f92672">&amp;</span>in, Complex <span style="color:#f92672">&amp;</span>c) {
    in <span style="color:#f92672">&gt;&gt;</span> c.real <span style="color:#f92672">&gt;&gt;</span> c.imag;
    <span style="color:#66d9ef">return</span> in;
}

ostream <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;&lt;</span>(ostream <span style="color:#f92672">&amp;</span>out, <span style="color:#66d9ef">const</span> Complex <span style="color:#f92672">&amp;</span>c) {
    out <span style="color:#f92672">&lt;&lt;</span> to_string(c.real) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;+&#34;</span> <span style="color:#f92672">+</span> to_string(c.imag) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;i&#34;</span>;
    <span style="color:#66d9ef">return</span> out;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Complex a(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">+</span> a <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> a<span style="color:#f92672">++</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">++</span>a <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;  <span style="color:#75715e">// 相当于a = Complex(10); 产生临时对象，调用构造函数和析构函数
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="继承与派生">继承与派生</h2>
<h3 id="派生类定义">派生类定义</h3>
<h4 id="三种继承方式派生类中基类成员的访问控制权限">三种继承方式派生类中基类成员的访问控制权限</h4>
<table>
<thead>
<tr>
<th></th>
<th>公有继承</th>
<th>私有继承</th>
<th>保护继承</th>
</tr>
</thead>
<tbody>
<tr>
<td>公有成员</td>
<td>公有</td>
<td>私有</td>
<td>保护</td>
</tr>
<tr>
<td>私有成员</td>
<td>派生类不可访问</td>
<td>派生类不可访问</td>
<td>派生类不可访问</td>
</tr>
<tr>
<td>保护成员</td>
<td>保护</td>
<td>私有</td>
<td>保护</td>
</tr>
</tbody>
</table>
<h3 id="派生类的构造函数和析构函数">派生类的构造函数和析构函数</h3>
<h4 id="派生类构造函数">派生类构造函数</h4>
<ul>
<li>
<p>不能在派生类构造函数体中显式调用基类构造函数</p>
</li>
<li>
<p>在成员初始化表中可以显式调用基类构造函数</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Rectangle(<span style="color:#66d9ef">float</span> x,<span style="color:#66d9ef">float</span> y,<span style="color:#66d9ef">float</span> w,<span style="color:#66d9ef">float</span> h) <span style="color:#f92672">:</span> Point(x,y)
{ W<span style="color:#f92672">=</span>w; H<span style="color:#f92672">=</span>h; }
<span style="color:#960050;background-color:#1e0010">或</span><span style="color:#f92672">:</span>
Rectangle(<span style="color:#66d9ef">float</span> x,<span style="color:#66d9ef">float</span> y,<span style="color:#66d9ef">float</span> w,<span style="color:#66d9ef">float</span> h) <span style="color:#f92672">:</span> Point(x,y),W(w),H(h) {}
</code></pre></div></li>
</ul>
<h4 id="构造函数和析构函数的调用顺序">构造函数和析构函数的调用顺序</h4>
<ul>
<li>
<p>构造函数调用顺序：基类的构造函数-&gt;对象成员构造函数-&gt;派生类构造函数</p>
</li>
<li>
<p>析构函数调用顺序刚好相反</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">O</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    O() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;O()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
    <span style="color:#f92672">~</span>O() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;~O()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    A() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
    <span style="color:#f92672">~</span>A() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;~A()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A {
    O o;

   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    B() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;B()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
    <span style="color:#f92672">~</span>B() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;~B()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    B b;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>A()
O()
B()
~B()
~O()
~A()
</code></pre></li>
<li>
<p>⚠️注意</p>
<ul>
<li>当基类中没有显式定义构造函数，或定义了无参数构造函数时，派生类构造函数的初始化表可以省略对基类构造函数的调用，而采用<strong>隐含调用</strong></li>
<li>当基类的构造函数使用<strong>一个或多个参数时候</strong>，<strong>派生类必须定义构造函数</strong>，提供将<strong>参数传递</strong>给基类的构造函数的途径。这时，派生类构造函数体可能为空，仅起到参数传递作用</li>
<li>无论是哪种继承方式，基类的私有成员在派生类中都是不可被访问的。只能通过基类的成员函数访问基类的私有数据成员。</li>
<li>如果在一个派生类中要访问基类中的私有成员，可以将这个派生类声明为基类的友元。
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {              <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derive</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {              
  <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derive</span>;        <span style="color:#75715e">// 直接使用Base中的私有成员
</span><span style="color:#75715e"></span>}                         }
</code></pre></div></li>
<li>友元关系是不能继承的：B类是A类的友元，C类是B类的派生类，则C类和A类之间没有任何友元关系，除非C类声明A类是友元。</li>
</ul>
</li>
</ul>
<h3 id="多继承与虚基类">多继承与虚基类</h3>
<h4 id="多继承派生类的定义">多继承派生类的定义</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#960050;background-color:#1e0010">&lt;派生类名</span><span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">继承方式</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">基类名</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">，…，</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">继承方式</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">基类名</span>n<span style="color:#f92672">&gt;</span>
{
    <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">派生类新定义成员</span><span style="color:#f92672">&gt;</span>
}<span style="color:#960050;background-color:#1e0010">；</span>
</code></pre></div><h4 id="多继承派生类的构造函数">多继承派生类的构造函数</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">派生类名</span><span style="color:#f92672">&gt;</span>(<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">总参数表</span><span style="color:#f92672">&gt;</span>)<span style="color:#f92672">:&lt;</span><span style="color:#960050;background-color:#1e0010">基类名</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span>(<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">参数表</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span>)<span style="color:#960050;background-color:#1e0010">，…，</span><span style="color:#f92672">&lt;</span> <span style="color:#960050;background-color:#1e0010">基类名</span>n<span style="color:#f92672">&gt;</span> (<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">参数表</span>n<span style="color:#f92672">&gt;</span>)
{
    <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">派生类数据成员的初始化</span><span style="color:#f92672">&gt;</span>
};
</code></pre></div><ul>
<li>
<p>构造函数的调用顺序是：先调用所有基类的构造函数，再调用对象成员构造函数，最后调用派生类的构造函数</p>
</li>
<li>
<p>处于同一层次的各基类构造函数的调用顺序取决于<strong>定义派生类时所指定的基类顺序</strong>，与派生类构造函数中所定义的成员初始化列表无关</p>
</li>
<li>
<p>如果有多个成员类对象，则构造函数额调用顺序是<strong>对象在类中被声明的顺序</strong>，而不是它们出现在成员初始化列表的顺序</p>
</li>
<li>
<p>析构函数的调用顺序与构造函数的调用顺序相反</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">M1</span> {
    <span style="color:#66d9ef">int</span> i;

   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    M1(<span style="color:#66d9ef">int</span> _i) <span style="color:#f92672">:</span> i(_i) { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;M1(&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span>  <span style="color:#e6db74">&#34;)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">M2</span> {
    <span style="color:#66d9ef">int</span> i;

   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    M2(<span style="color:#66d9ef">int</span> _i) <span style="color:#f92672">:</span> i(_i) { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;M2(&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span>  <span style="color:#e6db74">&#34;)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base1</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Base1() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base1()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base2</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Base2() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base2()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derive</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base1, <span style="color:#66d9ef">public</span> Base2 {
    M2 m2;
    M1 m1;

   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Derive(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) <span style="color:#f92672">:</span> m1(a), m2(b), Base2()  , Base1() {}
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Derive d(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>Base1()
Base2()
M2(9)
M1(8)
</code></pre></li>
</ul>
<h3 id="多继承引起的二义性问题">多继承引起的二义性问题</h3>
<h4 id="两个基类有同名成员">两个基类有同名成员</h4>
<ul>
<li>implementation
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
  <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">void</span> display() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;display() in A&#34;</span>   <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
  };

  <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> {
    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">void</span> display() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;display() in B&#34;</span>   <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
  };

  <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A, <span style="color:#66d9ef">public</span> B {
      
  };

  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
      C c;
      c.display();
      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
  }
</code></pre></div></li>
<li>编译错误

    <img src="https://s1.ax1x.com/2020/11/10/BL72ZT.jpg"  class="center"  style="border-radius: 5px; box-shadow: inset 2px 2px 5px black, 2px 2px 5px black;"  />

</li>
</ul>
<h4 id="两个基类和派生类三者都有同名成员">两个基类和派生类三者都有同名成员</h4>
<ul>
<li>基类的同名成员在派生类中被屏蔽，或者说，派生类新增加的同名成员隐藏了基类中的同名成员</li>
<li>implementation
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> display() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;display() in A&#34;</span>   <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> display() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;display() in B&#34;</span>   <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A, <span style="color:#66d9ef">public</span> B {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> display() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;display() in C&#34;</span>   <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    C c;
    c.display();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div></li>
<li>访问的是派生类C中的成员
<pre><code>display() in C
</code></pre></li>
</ul>
<h3 id="虚基类">虚基类</h3>
<h4 id="虚基类概念">虚基类概念</h4>
<ul>
<li>为了避免对基类成员访问的二义性问题，可以将<strong>直接基类（如A、B）的共同基类如N设置为虚基类</strong>，这样共同基类N在内存中只有一个副本存在</li>
<li>引进虚基类后，派生类对象中只存在一个虚基类成员的副本</li>
<li>为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类，否则仍然会出现对基类的多次继承。</li>
</ul>

    <img src="https://s1.ax1x.com/2020/11/10/BLOP3Q.jpg"  class="center"  style="width: 60% ;border-radius: 5px; box-shadow: inset 2px 2px 5px black, 2px 2px 5px black;"  />


<h4 id="构造函数的调用顺序">构造函数的调用顺序</h4>
<ul>
<li>先调用<strong>虚基类</strong>的构造函数，<strong>再调用非虚基类</strong>的构造函数</li>
<li>若同一层次包含多个虚基类，其调用顺序为<strong>定义时的顺序</strong></li>
<li>若虚基类构造函数由非虚基类派生而来，则仍先按先调用基类构造函数，再调用派生类构造函数的顺序
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base1</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Base1() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;class Base1&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base2</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Base2() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;class Base2&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Level1</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base2, <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">public</span>   Base1 {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Level1() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;class Level1&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Level2</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base2, <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">public</span>   Base1 {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Level2() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;class Level2&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TopLevel</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Level1, <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">public</span>  Level2 {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    TopLevel() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;class TopLevel&#34;</span> <span style="color:#f92672">&lt;&lt;</span>  endl; }
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    TopLevel obj;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出</p>
<pre><code>class Base1
class Base2
class Level2
class Base2
class Level1
class TopLevel
</code></pre></li>
</ul>
<h4 id="虚基类的初始化">虚基类的初始化</h4>
<p>如果在虚基类中只定义了带参数的构造函数，则要在其所有派生类（包括直接派生类或间接派生类）中，通过构造函数的初始化表对虚基类进行初始化。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
{ A(<span style="color:#66d9ef">int</span> i){} <span style="color:#960050;background-color:#1e0010">…</span> };

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span><span style="color:#f92672">:</span><span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">public</span> A
{ B(<span style="color:#66d9ef">int</span> n)<span style="color:#f92672">:</span>A(n){}<span style="color:#960050;background-color:#1e0010">…</span> };

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span><span style="color:#f92672">:</span><span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">public</span> A
{ C(<span style="color:#66d9ef">int</span> n)<span style="color:#f92672">:</span>A(n){}<span style="color:#960050;background-color:#1e0010">…</span> }; 

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> B, <span style="color:#66d9ef">public</span> C
{ D(<span style="color:#66d9ef">int</span> n)<span style="color:#f92672">:</span>A(n),B(n),C(n){}<span style="color:#960050;background-color:#1e0010">…</span> };
</code></pre></div><ul>
<li>⚠️注意
<ul>
<li>如果多继承不牵扯到对同一基类的派生，就没有必要定义虚基类</li>
<li>使用多继承要十分小心，经常会出现二义性问题</li>
<li>能用单一继承的问题就不要用多继承</li>
</ul>
</li>
</ul>
<h2 id="多态性与虚函数">多态性与虚函数</h2>
<h3 id="类型兼容规则">类型兼容规则</h3>
<ul>
<li>派生类的对象可以赋值给基类对象</li>
<li>派生类的对象可以初始化基类的引用</li>
<li>派生类的对象的地址可以赋给基类的指针变量</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> who() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base class&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derive1</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> who() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Derive1 class&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derive2</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> who() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Derive2 class&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Base obj1, <span style="color:#f92672">*</span>p;
    <span style="color:#75715e">//定义基类对象obj1和基类对象指针p
</span><span style="color:#75715e"></span>    Derive1 obj2;
    Derive2 obj3;
    p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>obj1;  <span style="color:#75715e">// p指向obj1
</span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>who();
    <span style="color:#75715e">//通过指针p调用obj1的公有成员函数//who()
</span><span style="color:#75715e"></span>    p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>obj2;  <span style="color:#75715e">// p指向obj2
</span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>who();
    <span style="color:#75715e">// p只能访问从基类继承下来的who()
</span><span style="color:#75715e"></span>    p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>obj3;
    <span style="color:#75715e">// p指向obj2
</span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>who();
    <span style="color:#75715e">// p只能访问从基类继承下来的who()
</span><span style="color:#75715e"></span>    obj2.who();
    obj3.who();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出</p>
<pre><code>Base class
Base class
Base class
Derive1 class
Derive2 class
</code></pre><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> {
    <span style="color:#66d9ef">int</span> num;

   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Student(<span style="color:#66d9ef">int</span> n) <span style="color:#f92672">:</span> num(n) {}
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">display</span>() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;num = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> num <span style="color:#f92672">&lt;&lt;</span> endl; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graduate</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Student {
    string name;

   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Graduate(<span style="color:#66d9ef">int</span> n, string _name) <span style="color:#f92672">:</span> Student(n), name(_name) {}
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">display</span>() {
        Student<span style="color:#f92672">::</span>display();
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;name = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> name <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Student stu(<span style="color:#ae81ff">1001</span>);
    Graduate grad(<span style="color:#ae81ff">2001</span>, <span style="color:#e6db74">&#34;Jack&#34;</span>);
    Student <span style="color:#f92672">*</span>pt <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>stu;
    pt<span style="color:#f92672">-&gt;</span>display();
    pt <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>grad;
    pt<span style="color:#f92672">-&gt;</span>display();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出</p>
<pre><code>num = 1001
num = 2001
</code></pre><h3 id="多态polymorphism">多态（Polymorphism）</h3>
<p>相似功能的不同函数使用一个名称来实现，从而可以使用相同的调用方式来调用这些具有不同功能的同名函数</p>
<h4 id="多态的分类">多态的分类</h4>
<ul>
<li>静态多态性（编译时的多态性）：通过函数重载实现</li>
<li>动态多态性（运行时的多态性）：通过虚函数实现</li>
</ul>
<h4 id="虚函数">虚函数</h4>
<p>虚函数就是在基类中被关键字virtual说明、并在一个或多个派生类中被重新定义的成员函数</p>
<p><strong>virtual &lt;函数值类型&gt; &lt;函数名&gt;(&lt;参数表&gt;);</strong></p>
<ul>
<li>
<p>程序运行时，不同类的对象调用各自的虚函数，这就是动态多态</p>
</li>
<li>
<p>实现动态的多态性时，必须使用<strong>基类类型的指针变量或对象引用</strong>，并使其<strong>指向不同的派生对象</strong>，并通过调用指针或引用所指向的虚函数才能实现动态的多态性</p>
</li>
<li>
<p>声明虚函数要注意</p>
<ul>
<li>静态成员函数和友元函数不能声明为虚函数</li>
<li>内联成员函数不能声明为虚函数</li>
<li>构造函数不能是虚函数</li>
<li>析构函数可以是虚函数
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Base() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Base() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base destructor&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Derived() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
    <span style="color:#f92672">~</span>Derived() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Derived destructor&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Base <span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Derived;
    <span style="color:#66d9ef">delete</span> b;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div></li>
</ul>
</li>
</ul>
<h4 id="联编">联编</h4>
<ul>
<li>联编的分类
<ul>
<li>
<p>静态联编：在<strong>编译阶段</strong>完成的联编</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> print() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A student&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GStudent</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Student {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> print() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A graduate student&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Student s1, <span style="color:#f92672">*</span>ps;
    GStudent s2;
    s1.print();
    s2.print();
    s2.Student<span style="color:#f92672">::</span>print();
    ps <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s1;
    ps<span style="color:#f92672">-&gt;</span>print();  <span style="color:#75715e">//基类指针和基类成员函数发生关联
</span><span style="color:#75715e"></span>    ps <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s2;
    ps<span style="color:#f92672">-&gt;</span>print();
    <span style="color:#75715e">//希望调用对象s2的输出函数，但调用的却是对象s1的输出函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出</p>
<pre><code>A student
A graduate student
A student
A student
A student
</code></pre></li>
<li>
<p>动态联编：<strong>根据具体的执行情况来动态的确定</strong>，在<strong>运行阶段</strong>完成</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
   <span style="color:#75715e">// virtual可省略
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> print() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a Student&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GStudent</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Student {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> print() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A graduate student&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Student s1, <span style="color:#f92672">*</span>ps;
    GStudent s2;
    s1.print();
    s2.print();
    s2.Student<span style="color:#f92672">::</span>print();
    ps <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s1;
    ps<span style="color:#f92672">-&gt;</span>print();
    ps <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s2;
    <span style="color:#75715e">// 对象指针调用虚函数，采用动态联编方式
</span><span style="color:#75715e"></span>    ps<span style="color:#f92672">-&gt;</span>print();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出</p>
<pre><code>a Student
A graduate student
a Student
a Student
A graduate student
</code></pre><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> print() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A studnet&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GStudent</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Student {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> print() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A graduate studnet&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun</span>(Student <span style="color:#f92672">&amp;</span>s) { s.print(); }
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Student s1;
    GStudent s2;
    fun(s1);
    fun(s2);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出</p>
<pre><code>A studnet
A graduate studnet
</code></pre><ul>
<li>⚠️注意
<ul>
<li><strong>virtual</strong>关键字只能用在虚函数声明中，不能用在虚函数的实现中</li>
<li>只有通过<strong>对象指针或对象引用</strong>来调用虚函数，才能实现动态联编。如果采用对象来调用虚函数，则采用的是静态联编方式</li>
<li>在派生类中重新定义虚函数时，返回值类型、函数名、参数个数、类型和顺序，都必须与<strong>基类的原型相同</strong></li>
<li>当在派生类中定义了虚函数的重载函数，但并没有重新定义虚函数时，与虚函数同名的重载函数<strong>覆盖</strong>了派生类中的虚函数。此时若试图通过派生类对象、指针调用派生类对象的虚函数就会产生错误
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> PI <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.1415</span>;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span> {
    <span style="color:#66d9ef">int</span> X, Y;

   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Point(<span style="color:#66d9ef">int</span> X <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">int</span> Y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>X <span style="color:#f92672">=</span> X;
        <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>Y <span style="color:#f92672">=</span> Y;
    }
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">area</span>() { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0.0</span>; }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Circle</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Point {
    <span style="color:#66d9ef">double</span> radius;

   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Circle(<span style="color:#66d9ef">int</span> X, <span style="color:#66d9ef">int</span> Y, <span style="color:#66d9ef">double</span> R) <span style="color:#f92672">:</span> Point(X, Y) { radius <span style="color:#f92672">=</span> R; }
    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">area</span>(<span style="color:#66d9ef">int</span> i) { <span style="color:#66d9ef">return</span> PI <span style="color:#f92672">*</span> radius <span style="color:#f92672">*</span> radius; }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Point P1(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;P1.area = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> P1.area() <span style="color:#f92672">&lt;&lt;</span> endl;
    Circle C1(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;C1.area = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> C1.area() <span style="color:#f92672">&lt;&lt;</span> endl;
    Point <span style="color:#f92672">*</span>Pp;
    Pp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>C1;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Pp.area = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> Pp<span style="color:#f92672">-&gt;</span>area() <span style="color:#f92672">&lt;&lt;</span> endl;
    Point <span style="color:#f92672">&amp;</span>Rp <span style="color:#f92672">=</span> C1;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Rp.area = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> Rp.area() <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>
    <img src="https://s3.ax1x.com/2020/11/18/DeW6O0.png"  class="center"  style="width: 120% ;border-radius: 5px; box-shadow: inset 2px 2px 5px black,2px 2px 5px black;"  />


</li>
<li>如果在派生类中没有重新定义虚函数，则不实现动态联编，派生类的对象将使用基类虚函数的代码</li>
<li>一个类中的虚函数说明只对派生类中重定义的函数有影响，对它的基类中的函数并没有影响
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> func(<span style="color:#66d9ef">int</span> x) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;This is Base class&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        <span style="color:#66d9ef">return</span> x;
    }
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SubClass</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">int</span> func(<span style="color:#66d9ef">int</span> x) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;This is SubClass&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        <span style="color:#66d9ef">return</span> x;
    }
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SubSubClass</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> SubClass {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> func(<span style="color:#66d9ef">int</span> x) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;This is SubSubClass&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        <span style="color:#66d9ef">return</span> x;
    }
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    SubSubClass ss;
    Base <span style="color:#f92672">&amp;</span>b <span style="color:#f92672">=</span> ss;
    cout <span style="color:#f92672">&lt;&lt;</span> b.func(<span style="color:#ae81ff">5</span>) <span style="color:#f92672">&lt;&lt;</span> endl;
    SubClass <span style="color:#f92672">&amp;</span>s <span style="color:#f92672">=</span> ss;
    cout <span style="color:#f92672">&lt;&lt;</span> s.func(<span style="color:#ae81ff">5</span>) <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出</p>
<pre><code>This is Base class  5
This is Sub2 class  5
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="纯虚函数">纯虚函数</h4>
<p>纯虚函数用virtual声明，<strong>没有任何实现</strong>，必须由派生类重新定义该函数提供实现</p>
<ul>
<li>
<p>纯虚函数与函数体为空的虚函数</p>
<ul>
<li>区别
<ul>
<li>前者没有函数体，后者有函数体</li>
<li>前者所在的类是抽象类，不能直接实例化；后者所在的类是可以实例化的（该类中不含有其他纯虚函数）</li>
</ul>
</li>
<li>共同点
<ul>
<li>可以派生出新的类，然后在新类中给出虚函数的实现，而且这种实现可以具有动态特征</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
  <span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> x;

  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    A() { x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000</span>; }
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// 定义纯虚函数
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A {
    <span style="color:#66d9ef">int</span> y;

  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    B() { y <span style="color:#f92672">=</span> <span style="color:#ae81ff">2000</span>; }
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;y = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> y <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }  <span style="color:#75715e">// 重新定义纯虚函数
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A {
    <span style="color:#66d9ef">int</span> z;

  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    C() { z <span style="color:#f92672">=</span> <span style="color:#ae81ff">3000</span>; }
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;z = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> z <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }  <span style="color:#75715e">// 重新定义纯虚函数
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    A <span style="color:#f92672">*</span>pa;
    B b;
    C c;
    pa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>b;
    pa<span style="color:#f92672">-&gt;</span>print();
    pa <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>c;
    pa<span style="color:#f92672">-&gt;</span>print();
    <span style="color:#75715e">// A a;          不能定义抽象类的对象
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// pa = &amp;a;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// pa-&gt;pritn();
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出</p>
<pre><code>y = 2000
z = 3000
</code></pre></li>
</ul>
<h4 id="抽象类">抽象类</h4>
<ul>
<li>
<p>包含一个或多个纯虚函数的类称为抽象类</p>
</li>
<li>
<p>如果派生类没有实现基类中的<strong>所有</strong>纯虚函数，派生类也是抽象类</p>
</li>
<li>
<p>抽象类无法实例化</p>
</li>
<li>
<p>抽象类不能用作<strong>参数类型、函数值类型或显式转换的类型</strong>，但可以声明指向抽象类的的指针或引用，通过指针或引用来指向并访问派生类对象，从而实现动态多态</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span> PI <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14159</span>;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Shapes</span>  <span style="color:#75715e">//抽象类
</span><span style="color:#75715e"></span>{
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> setvalue(<span style="color:#66d9ef">int</span> d, <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {
        x <span style="color:#f92672">=</span> d;
        y <span style="color:#f92672">=</span> w;
    }
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">area</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">//纯虚函数
</span><span style="color:#75715e"></span>   <span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> x, y;
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Square</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Shapes {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> area()  <span style="color:#75715e">//计算矩形面积
</span><span style="color:#75715e"></span>    {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;area of rectangle:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> x <span style="color:#f92672">*</span> y <span style="color:#f92672">&lt;&lt;</span> endl;
    }
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Circle</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Shapes {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> area()  <span style="color:#75715e">//计算圆面积
</span><span style="color:#75715e"></span>    {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;area of circle:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> PI <span style="color:#f92672">*</span> x <span style="color:#f92672">*</span> x <span style="color:#f92672">&lt;&lt;</span> endl;
    }
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Shapes <span style="color:#f92672">*</span>ptr[<span style="color:#ae81ff">2</span>];  <span style="color:#75715e">//声明抽象类指针
</span><span style="color:#75715e"></span>    Square s1;       <span style="color:#75715e">//声明派生类对象
</span><span style="color:#75715e"></span>    Circle c1;       <span style="color:#75715e">//声明派生类对象
</span><span style="color:#75715e"></span>    ptr[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s1;
    <span style="color:#75715e">//抽象类指针指向派生类对象
</span><span style="color:#75715e"></span>    ptr[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>setvalue(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">5</span>);
    ptr[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>area();
    <span style="color:#75715e">//抽象类指针调用派生类成员函数,实现多态
</span><span style="color:#75715e"></span>    ptr[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>c1;
    <span style="color:#75715e">//抽象类指针指向派生类对象
</span><span style="color:#75715e"></span>    ptr[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>setvalue(<span style="color:#ae81ff">10</span>);
    ptr[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>area();
    <span style="color:#75715e">//抽象类指针调用派生类成员函数,实现多态
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>输出</p>
<pre><code>area of rectangle:50
area of circle:314.159
</code></pre></li>
</ul>
<h3 id="第三次上机题目">第三次上机题目</h3>
<ol>
<li>定义一个复数类Complex，重载运算符“+”，“-”，“*”，“/”,使之能用于复数的加、减、乘、除。运算符重载函数作为Complex类的成员函数。编程序，分别求两个复数之和、差、积和商。</li>
<li>对于2行3列矩阵，重载流插入运算符“&laquo;”和流提取运算符“&raquo;”，使之能用于矩阵的输入和输出。</li>
<li>定义Time类和Date类，Time类为Date类的友元类，通过Time类中的display函数引用Date类对象的私有数据，输出年、月、日和时、分、秒。</li>
<li>分别定义Teacher（教师）类和Cadre（干部）类，采用多继承方式由这两个类派生出新类Teacher_Cadre（教师兼干部）。要求：
<ul>
<li>在两个基类中都包含姓名、年龄、性别、地址、电话等数据成员。</li>
<li>在Teacher类中还包含数据成员titile（职称），在Cadre类中还包含数据成员post（职务），在Teacher_Cadre类中还包含数据成员wages（工资）。</li>
<li>对两个基类中的姓名、年龄、性别、地址、电话等数据成员用相同的名字，在引用这些数据成员时，指定作用域。</li>
<li>在类体中声明成员函数，在类外定义成员函数。</li>
<li>在派生类Teacher_Cadre的成员函数show中调用Teacher类中的display函数，输出姓名、年龄、性别、职称、地址、电话，然后再用cout语句输出职务与工资。</li>
</ul>
</li>
<li>写一个程序，定义抽象基类Shape，由它派生出5个派生类：Circle（圆形）、Square（正方形）、Rectangle（矩形）、Trapezoid（梯形）、Triangle（三角形）。用虚函数分别计算几种图形面积，并求它们的和。要求用基类指针数组，使它的每一个元素指向一个派生类对象。</li>
</ol>
<h4 id="源码下载-2">源码下载</h4>
<p><a href="/0x03/test1.cc">1</a><br>
<a href="/0x03/test2.cc">2</a><br>
<a href="/0x03/test3.cc">3</a><br>
<a href="/0x03/test4.cc">4</a><br>
<a href="/0x03/test5.cc">5</a></p>
<h2 id="输入输出流">输入输出流</h2>
<h3 id="流">流</h3>
<p>数据从一个位置流向另一个位置。流是字节的序列。</p>
<h3 id="io流类库的层次结构">I/O流类库的层次结构</h3>
<ul>
<li>C++编译系统提供的I/O流类库含有两个平行基类：
<ul>
<li>streambuf</li>
<li>ios</li>
</ul>
</li>
<li>ios类有4个直接派生类：
<ul>
<li>输入流类istream</li>
<li>输出流类ostream</li>
<li>文件流类基类fstreambase</li>
<li>字符串流类基类strstreambase

    <img src="https://i.postimg.cc/YSF0JJhX/1.jpg"  class="left"  style="width: 80%"  />

</li>
</ul>
</li>
</ul>
<h3 id="io流类库的头文件">I/O流类库的头文件</h3>
<ul>
<li><strong>iostream</strong>：I/O流类库的最主要的头文件，包含了对输入输出流进行操作的所需的基本信息，还包括cin、cout、cerr、clog共4个流对象</li>
<li><strong>fstream</strong>：用于用户管理的文件的I/O操作</li>
<li><strong>strstream</strong>：用于字符串流I/O</li>
<li><strong>stdiostream</strong>：用于混合使用C和C++的I/O操作</li>
<li><strong>iomanip</strong>：用于格式化I/O时应包含此头文件</li>
</ul>
<h3 id="输入输出的格式控制">输入输出的格式控制</h3>
<ul>
<li>两种格式化方式
<ul>
<li>用流对象的有关成员函数进行格式化</li>
<li>用专门的控制符进行格式化输入输出</li>
</ul>
</li>
</ul>
<h4 id="用流对象的成员函数格式化">用流对象的成员函数格式化</h4>
<ul>
<li>设置状态标志
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">long</span> ios<span style="color:#f92672">::</span>setf(<span style="color:#66d9ef">long</span> flags)
</code></pre></div></li>
<li>清楚状态标志
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">long</span> ios<span style="color:#f92672">::</span>unsetf(<span style="color:#66d9ef">long</span> flags)
</code></pre></div></li>
<li>取状态标志
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">long</span> ios<span style="color:#f92672">::</span>flags()
</code></pre></div></li>
<li>取状态标志并设置状态标志
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">long</span> ios<span style="color:#f92672">::</span>flags(<span style="color:#66d9ef">long</span> flag)
</code></pre></div></li>
</ul>
<p>⚠️以上三组函数必须用流式对象（cin或cout）来调用</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">showflags</span>(<span style="color:#66d9ef">long</span> f) {
    <span style="color:#66d9ef">long</span> i;
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x8000</span>; i; i <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> ((i <span style="color:#f92672">&amp;</span> f) <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;0&#34;</span>);
    }
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">long</span> f;
    f <span style="color:#f92672">=</span> cout.flags();
    showflags(f);
    cout.setf(ios<span style="color:#f92672">::</span>showpos <span style="color:#f92672">|</span> ios<span style="color:#f92672">::</span>scientific <span style="color:#f92672">|</span> ios<span style="color:#f92672">::</span>fixed);  <span style="color:#75715e">// 追加状态标志
</span><span style="color:#75715e"></span>    f <span style="color:#f92672">=</span> cout.flags();
    showflags(f);
    cout.unsetf(ios<span style="color:#f92672">::</span>scientific);  <span style="color:#75715e">// 从状态标志中去掉scientific
</span><span style="color:#75715e"></span>    f <span style="color:#f92672">=</span> cout.flags();
    showflags(f);
    f <span style="color:#f92672">=</span> cout.flags(ios<span style="color:#f92672">::</span>hex);  <span style="color:#75715e">// 重新设置状态标志
</span><span style="color:#75715e"></span>    showflags(f);              <span style="color:#75715e">// 重新设置状态标志之前
</span><span style="color:#75715e"></span>    f <span style="color:#f92672">=</span> cout.flags();
    showflags(f);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><ul>
<li>用流对象的成员函数设置输出宽度</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> ios<span style="color:#f92672">::</span>width(<span style="color:#66d9ef">int</span> len)
<span style="color:#66d9ef">int</span> ios<span style="color:#f92672">::</span>width()
</code></pre></div><ul>
<li>第一种设置输出宽度并返回原来的输出宽度；第二种返回当前输出宽度，默认输出宽度为0</li>
<li>只对其后的第一个输出项有效</li>
<li>设置填充字符</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">char</span> ios<span style="color:#f92672">::</span>fill(<span style="color:#66d9ef">char</span> ch)
<span style="color:#66d9ef">char</span> ios<span style="color:#f92672">::</span>fill()
</code></pre></div><ul>
<li>设置输出精度</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> ios<span style="color:#f92672">::</span>precision(<span style="color:#66d9ef">int</span> p)
<span style="color:#66d9ef">int</span> ios<span style="color:#f92672">::</span>precision()
</code></pre></div><ul>
<li>默认输出精度为6</li>
<li>用流成员函数put输出字符</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">cout.out(<span style="color:#e6db74">&#39;a&#39;</span>)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> cout.width();
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;width: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> endl;
    cout.width(<span style="color:#ae81ff">8</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> cout.width() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;new width&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">char</span> c <span style="color:#f92672">=</span> cout.fill();
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;filling word is: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;(ASCII code&#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">int</span>)c <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    cout.fill(<span style="color:#e6db74">&#39;*&#39;</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> cout.fill() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;(&#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">int</span>)cout.fill() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;)(new filling word)&#34;</span>
         <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> cout.precision();
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;precision: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> j <span style="color:#f92672">&lt;&lt;</span> endl;
    cout.precision(<span style="color:#ae81ff">8</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">123.456789</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;(example)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    cout <span style="color:#f92672">&lt;&lt;</span> cout.precision() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;(new precision)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>width:0
       8(new width)
filling word is: (ASCII code32)
*(42)(new filling word)
precision:6
123.45679(example)
8(new precision)
</code></pre><ul>
<li>用于字符输入的流成员函数
<ul>
<li>不带参数的get函数
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> c;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;enter a sentence:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">while</span> ((c <span style="color:#f92672">=</span> cin.get()) <span style="color:#f92672">!=</span> EOF) <span style="color:#75715e">// 函数的返回值就是读入的字符
</span><span style="color:#75715e"></span>        cout.put(c);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div></li>
<li>有一个参数的get函数
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">char</span> c;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;enter a sentence:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">while</span> (cin.get(
        c))  <span style="color:#75715e">// 读取一个字符赋给c，如果读取成功，返回真，如失败（如遇文件结束符）则返回假
</span><span style="color:#75715e"></span>        cout.put(c);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;end&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div></li>
<li>有三个参数的get函数
<ul>
<li>cin.get(字符数组/字符指针, 字符个数n, 终止字符)</li>
<li>从输入流中读取n-1个字符，赋给指定的字符数组（或字符指针指向的数组）</li>
<li>如果在读取n-1个字符之前遇到指定的终止字符，则提前读取结束</li>
<li>如果读取成功返回真，失败（遇文件结束符）则返回假</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">char</span> ch[<span style="color:#ae81ff">20</span>];
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;enter a sentence:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    cin.get(ch, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#39;/&#39;</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> ch <span style="color:#f92672">&lt;&lt;</span> endl;
    cin.get(ch, <span style="color:#ae81ff">20</span>, <span style="color:#e6db74">&#39;\n&#39;</span>);  <span style="color:#75715e">// cin.get(ch, 20);
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> ch <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>enter a sentence:
you!/her.
you!
/her.
</code></pre></li>
<li>用getline函数读入一行字符
<ul>
<li>cin.getline(字符数组（或字符指针）, 字符个数n, 终止字符)</li>
<li>从输入流中读取一行字符，其用法与带3个参数的get函数类似
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">char</span> ch[<span style="color:#ae81ff">20</span>];
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;enter a sentence:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    cin <span style="color:#f92672">&gt;&gt;</span> ch;
    cout <span style="color:#f92672">&lt;&lt;</span> ch <span style="color:#f92672">&lt;&lt;</span> endl;
    cin.getline(ch, <span style="color:#ae81ff">20</span>, <span style="color:#e6db74">&#39;/&#39;</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> ch <span style="color:#f92672">&lt;&lt;</span> endl;
    cin.getline(ch, <span style="color:#ae81ff">20</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> ch <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>enter a sentence:
I like C++./I study C++./I am happy.
I
 like C++.
I study C++./I am h
</code></pre></li>
</ul>
</li>
<li>eof函数
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>cin.eof())
</code></pre></div></li>
<li>peek函数
<ul>
<li>无参函数，表示“观察”，观测下一字符</li>
<li>返回值是当前指针指向的当前字符，但只是观测，指针仍停留在当前位置，并不后移</li>
<li>如果要访问的字符是文件结束符时，则函数值是EOF</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">c <span style="color:#f92672">=</span> cin.peek();
</code></pre></div></li>
<li>putback函数
<ul>
<li>将前面用get或getline函数从输入流中读取的字符ch返回到输入流，插入到当前指针位置，供后面读取</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">char</span> c[<span style="color:#ae81ff">20</span>];
    <span style="color:#66d9ef">int</span> ch;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;enter a sentence:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    cin.getline(c, <span style="color:#ae81ff">15</span>, <span style="color:#e6db74">&#39;/&#39;</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> c <span style="color:#f92672">&lt;&lt;</span> endl;
    ch <span style="color:#f92672">=</span> cin.peek(); <span style="color:#75715e">// 观看当前字符
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> ch <span style="color:#f92672">&lt;&lt;</span> endl;
    cin.putback(c[<span style="color:#ae81ff">0</span>]); <span style="color:#75715e">// 将&#39;I&#39;插入到指针所指处
</span><span style="color:#75715e"></span>    cin.getline(c, <span style="color:#ae81ff">15</span>, <span style="color:#e6db74">&#39;/&#39;</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> c <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>enter a sentence:
I am a boy./ am a student./
I am a boy.
32
I am a student
</code></pre></li>
<li>ignore函数
<ul>
<li>cin.ignore(n, 终止字符)</li>
<li>跳过输入流中n个字符，或在遇到指定的终止字符时提前结束（此时跳过包括终止字符在内的若干字符）</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ignore(<span style="color:#ae81ff">5</span>, <span style="color:#e6db74">&#39;A&#39;</span>); <span style="color:#75715e">// 跳过5个字符，遇&#39;A&#39;后不再跳
</span><span style="color:#75715e"></span>ignore(); <span style="color:#f92672">&lt;-&gt;</span> ignore(<span style="color:#ae81ff">1</span>, EOF);
</code></pre></div><ul>
<li>示例代码
<ul>
<li>不加ignore
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">char</span> ch[<span style="color:#ae81ff">20</span>];
    cin.get(ch, <span style="color:#ae81ff">20</span>, <span style="color:#e6db74">&#39;/&#39;</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;the first part is: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ch <span style="color:#f92672">&lt;&lt;</span> endl;
    cin.get(ch, <span style="color:#ae81ff">20</span>, <span style="color:#e6db74">&#39;/&#39;</span>);  <span style="color:#75715e">// get不跳过终止字符
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;the second part is: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ch <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>I like C++./I study C++./I am happy.
The first part is:I like C++.
The second part is:
</code></pre></li>
<li>加ignore
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">char</span> ch[<span style="color:#ae81ff">20</span>];
    cin.get(ch, <span style="color:#ae81ff">20</span>, <span style="color:#e6db74">&#39;/&#39;</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;the first part is: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ch <span style="color:#f92672">&lt;&lt;</span> endl;
    cin.ignore();          <span style="color:#75715e">// 跳过输入流中一个字符
</span><span style="color:#75715e"></span>    cin.get(ch, <span style="color:#ae81ff">20</span>, <span style="color:#e6db74">&#39;/&#39;</span>);  <span style="color:#75715e">// get不跳过终止字符
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;the second part is: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ch <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>I like C++./I study C++./I am happy.
The first part is:I like C++.
The second part is:I study C++.
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>用控制符格式化
<ul>
<li>这组控制符<strong>不属于任何类成员</strong>，定义在inomanip头文件中</li>
<li>将他们用在提取运算符&quot;&raquo;&ldquo;或插入运算符&rdquo;&laquo;&ldquo;后面来<strong>设定输入/输出格式</strong>，即在读写对象之间插入一个修改状态的操作</li>
<li>设置输入/输出宽度setw(int)
<ul>
<li>用整型参数来指定输入/输出域的宽度。使用时只对其后一项输入/输出有效</li>
<li>当用于输出时，若实际宽度小于设置宽度时，数据向右对齐，反之则按照数据的实际宽度输出</li>
<li>当用于输入时，若输入的数据宽度超过设置宽度时，超出的数据部分被截断而被作为下一项输入内容</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;12345&#34;</span>, <span style="color:#f92672">*</span>q <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;678&#34;</span>;
    <span style="color:#66d9ef">char</span> f[<span style="color:#ae81ff">4</span>], g[<span style="color:#ae81ff">4</span>];
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> p <span style="color:#f92672">&lt;&lt;</span> setw(<span style="color:#ae81ff">6</span>) <span style="color:#f92672">&lt;&lt;</span> q <span style="color:#f92672">&lt;&lt;</span> setw(<span style="color:#ae81ff">4</span>) <span style="color:#f92672">&lt;&lt;</span> p <span style="color:#f92672">&lt;&lt;</span> q <span style="color:#f92672">&lt;&lt;</span> endl;
    cin <span style="color:#f92672">&gt;&gt;</span> setw(<span style="color:#ae81ff">4</span>) <span style="color:#f92672">&gt;&gt;</span> f <span style="color:#f92672">&gt;&gt;</span> g;
    cout <span style="color:#f92672">&lt;&lt;</span> f <span style="color:#f92672">&lt;&lt;</span> endl <span style="color:#f92672">&lt;&lt;</span> g <span style="color:#f92672">&lt;&lt;</span> endl <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i : &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>12345   67812345678
12345
123
45
i:10
</code></pre></li>
<li>设置输出填充字符setfill(char)</li>
<li>setprecision(int)
<ul>
<li>在以fixed形式和scientific形式输出时参数为小数位数</li>
</ul>
</li>
<li>setiosflags(ios::fixed)用定点方式表示实数</li>
<li>setiosflags(ios::scientific)用科学记数法方式表示实数</li>
<li>setiosflags(ios::left)左对齐</li>
<li>setiosflags(ios::right)右对齐</li>
<li>setiosflags(ios::uppercase)大写表示</li>
<li>setiosflags(ios::showpos)正号</li>
<li>setiosflags(ios::skipws)忽略前导空格</li>
<li>resetiosflags() 终止已设置的输出格式状态，在括号中应指定内容</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iomanip&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">double</span> f<span style="color:#f92672">=</span><span style="color:#ae81ff">22.0</span><span style="color:#f92672">/</span><span style="color:#ae81ff">7</span>;
    <span style="color:#75715e">//在用浮点形式表示的输出中，setprecision(n)表示实数的有效位数
</span><span style="color:#75715e"></span>    cout<span style="color:#f92672">&lt;&lt;</span>f<span style="color:#f92672">&lt;&lt;</span>endl;                    <span style="color:#75715e">//默认有效位数为6
</span><span style="color:#75715e"></span>    cout<span style="color:#f92672">&lt;&lt;</span>setprecision(<span style="color:#ae81ff">3</span>)<span style="color:#f92672">&lt;&lt;</span>f<span style="color:#f92672">&lt;&lt;</span>endl;   <span style="color:#75715e">//设置有效位数为3
</span><span style="color:#75715e">//在用定点形式表示的输出中，setprecision(n)表示实数的小数位数
</span><span style="color:#75715e"></span>    cout<span style="color:#f92672">&lt;&lt;</span>setiosflags(ios<span style="color:#f92672">::</span>fixed); 
    cout<span style="color:#f92672">&lt;&lt;</span>setprecision(<span style="color:#ae81ff">8</span>)<span style="color:#f92672">&lt;&lt;</span>f<span style="color:#f92672">&lt;&lt;</span>endl;   <span style="color:#75715e">//小数位数为8
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>3.14286
3.14
3.14285714
</code></pre><ul>
<li>设置输入/输出整型数数制dec、hex和oct</li>
<li>控制换行的控制符endl</li>
<li>代表输出单字符'\0&rsquo;的控制符ends</li>
</ul>
</li>
</ul>
<h2 id="大作业">大作业</h2>
<script type="text/javascript" src="/js/pdf-js/build/pdf.js"></script>
<style>
#the-canvas {
  border: 1px solid black;
  direction: ltr;
  width: 100%;
  height: auto;
}
#paginator{
    text-align: center;
    margin-bottom: 10px;
}
</style>

<div id="paginator">
    <button id="prev">Previous</button>
    <button id="next">Next</button>
    &nbsp; &nbsp;
    <span>Page: <span id="page_num"></span> / <span id="page_count"></span></span>
</div>
<div id="embed-pdf-container">
    <canvas id="the-canvas"></canvas>
</div>

<script type="text/javascript">
window.onload = function() {



var url = "\\pdf\\OOP-bighomework.pdf";


var pdfjsLib = window['pdfjs-dist/build/pdf'];


pdfjsLib.GlobalWorkerOptions.workerSrc = '/js/pdf-js/build/pdf.worker.js';


var pdfDoc = null,
    pageNum = 1,
    pageRendering = false,
    pageNumPending = null,
    scale = 3,
    canvas = document.getElementById('the-canvas'),
    ctx = canvas.getContext('2d');



function renderPage(num) {
  pageRendering = true;
  
  pdfDoc.getPage(num).then(function(page) {
    var viewport = page.getViewport({scale: scale});
    canvas.height = viewport.height;
    canvas.width = viewport.width;

    
    var renderContext = {
      canvasContext: ctx,
      viewport: viewport
    };
    var renderTask = page.render(renderContext);

    
    renderTask.promise.then(function() {
      pageRendering = false;
      if (pageNumPending !== null) {
        
        renderPage(pageNumPending);
        pageNumPending = null;
      }
    });
  });

  
  document.getElementById('page_num').textContent = num;
}



function queueRenderPage(num) {
  if (pageRendering) {
    pageNumPending = num;
  } else {
    renderPage(num);
  }
}



function onPrevPage() {
  if (pageNum <= 1) {
    return;
  }
  pageNum--;
  queueRenderPage(pageNum);
}
document.getElementById('prev').addEventListener('click', onPrevPage);



function onNextPage() {
  if (pageNum >= pdfDoc.numPages) {
    return;
  }
  pageNum++;
  queueRenderPage(pageNum);
}
document.getElementById('next').addEventListener('click', onNextPage);



pdfjsLib.getDocument(url).promise.then(function(pdfDoc_) {
  pdfDoc = pdfDoc_;
  document.getElementById('page_count').textContent = pdfDoc.numPages;

  
  renderPage(pageNum);
});
}

</script>
]]></content>
        </item>
        
        <item>
            <title>LeetCode杂题2</title>
            <link>https://fffzlfk.gitlab.io/posts/leetcode%E6%9D%82%E9%A2%982/</link>
            <pubDate>Sun, 04 Oct 2020 12:25:11 +0800</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/posts/leetcode%E6%9D%82%E9%A2%982/</guid>
            <description>杂题记录2</description>
            <content type="html"><![CDATA[<h3 id="特殊数组的特征值">特殊数组的特征值</h3>
<p>给你一个非负整数数组 nums 。如果存在一个数 x ，使得 nums 中恰好有 x 个元素 大于或者等于 x ，那么就称 nums 是一个 特殊数组 ，而 x 是该数组的 特征值 。</p>
<blockquote>
<p>注意： x 不必 是 nums 的中的元素。</p>
</blockquote>
<p>如果数组 nums 是一个 特殊数组 ，请返回它的特征值 x 。否则，返回 -1 。可以证明的是，如果 nums 是特殊数组，那么其特征值 x 是 唯一的 。</p>
<blockquote>
<p>示例 1:<br>
输入：nums = [3,5]<br>
输出：2<br>
解释：有 2 个元素（3 和 5）大于或等于 2 。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：nums = [0,0]<br>
输出：-1<br>
解释：没有满足题目要求的特殊数组，故而也不存在特征值 x 。<br>
如果 x = 0，应该有 0 个元素 &gt;= x，但实际有 2 个。<br>
如果 x = 1，应该有 1 个元素 &gt;= x，但实际有 0 个。<br>
如果 x = 2，应该有 2 个元素 &gt;= x，但实际有 0 个。<br>
x 不能取更大的值，因为 nums 中只有两个元素。</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：nums = [0,4,3,0,4]<br>
输出：3<br>
解释：有 3 个元素大于或等于 3 。</p>
</blockquote>
<blockquote>
<p>示例 4：<br>
输入：nums = [3,6,7,7,0]<br>
输出：-1</p>
</blockquote>
<blockquote>
<p>提示：<br>
1 &lt;= nums.length &lt;= 100<br>
0 &lt;= nums[i] &lt;= 1000</p>
</blockquote>
<h4 id="code">Code</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> specialArray(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1001</span>; i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>e : nums) {
                <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;=</span> e) <span style="color:#f92672">++</span>cnt;
            }
            <span style="color:#66d9ef">if</span> (cnt <span style="color:#f92672">==</span> i)
                <span style="color:#66d9ef">return</span> i;
        }
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
};
</code></pre></div><h3 id="奇偶树">奇偶树</h3>
<p>如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：</p>
<ul>
<li>二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。</li>
<li>偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增</li>
<li>奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减</li>
</ul>
<p>给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。<br>
示例 1：
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_1_1966.png" alt=""></p>
<blockquote>
<p>输入：root = [1,10,4,3,null,7,9,12,8,6,null,null,2]<br>
输出：true<br>
解释：每一层的节点值分别是：<br>
0 层：[1]<br>
1 层：[10,4]<br>
2 层：[3,7,9]<br>
3 层：[12,8,6,2]<br>
由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。</p>
</blockquote>
<p>示例 2：
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_2_1966.png" alt=""></p>
<blockquote>
<p>输入：root = [5,4,2,3,3,7]<br>
输出：false<br>
解释：每一层的节点值分别是：<br>
0 层：[5]<br>
1 层：[4,2]<br>
2 层：[3,3,7]<br>
2 层上的节点值不满足严格递增的条件，所以这不是一棵奇偶树。</p>
</blockquote>
<p>示例 3：
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_1_333_1966.png" alt=""></p>
<blockquote>
<p>输入：root = [5,9,1,3,5,7]<br>
输出：false<br>
解释：1 层上的节点值应为偶数。</p>
</blockquote>
<p>示例 4：</p>
<blockquote>
<p>输入：root = [1]<br>
输出：true</p>
</blockquote>
<p>示例 5：</p>
<blockquote>
<p>输入：root = [11,8,6,1,3,9,11,30,20,18,16,12,10,4,2,17]<br>
输出：true</p>
</blockquote>
<p>提示：</p>
<blockquote>
<p>树中节点数在范围 [1, 105] 内<br>
1 &lt;= Node.val &lt;= 106</p>
</blockquote>
<h4 id="code-1">Code</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">bool</span> isEvenOddTree(TreeNode <span style="color:#f92672">*</span>root) {
        <span style="color:#66d9ef">int</span> depth <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        queue<span style="color:#f92672">&lt;</span>TreeNode <span style="color:#f92672">*&gt;</span> Q;
        Q.emplace(root);
        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>Q.empty()) {
            <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> Q.size();
            <span style="color:#66d9ef">auto</span> t <span style="color:#f92672">=</span> Q.front();
            Q.pop();
            <span style="color:#66d9ef">if</span> (t<span style="color:#f92672">-&gt;</span>left) Q.emplace(t<span style="color:#f92672">-&gt;</span>left);
            <span style="color:#66d9ef">if</span> (t<span style="color:#f92672">-&gt;</span>right) Q.emplace(t<span style="color:#f92672">-&gt;</span>right);
            <span style="color:#66d9ef">int</span> pre <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>val;
            <span style="color:#66d9ef">int</span> cur <span style="color:#f92672">=</span> pre;
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>check(depth, pre)) <span style="color:#66d9ef">return</span> false;
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
                t <span style="color:#f92672">=</span> Q.front();
                Q.pop();
                <span style="color:#66d9ef">if</span> (t<span style="color:#f92672">-&gt;</span>left) Q.emplace(t<span style="color:#f92672">-&gt;</span>left);
                <span style="color:#66d9ef">if</span> (t<span style="color:#f92672">-&gt;</span>right) Q.emplace(t<span style="color:#f92672">-&gt;</span>right);
                cur <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>val;
                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>check(depth, cur) <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>judge(depth, pre, cur)) <span style="color:#66d9ef">return</span> false;
                pre <span style="color:#f92672">=</span> cur;
            }
            <span style="color:#f92672">++</span>depth;
        }
        <span style="color:#66d9ef">return</span> true;
    }

    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">check</span>(<span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> n) {
        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>) {
            <span style="color:#66d9ef">return</span> n <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">return</span> n <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>;
        }
    }

    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">judge</span>(<span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> pre, <span style="color:#66d9ef">int</span> cur) {
        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>) {
            <span style="color:#66d9ef">return</span> cur <span style="color:#f92672">&lt;</span> pre;
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">return</span> cur <span style="color:#f92672">&gt;</span> pre;
        }
    }
};
</code></pre></div><h3 id="416-分割等和子集httpsleetcode-cncomproblemspartition-equal-subset-sum"><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h3>
<p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
<style type="text/css">.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative}</style>
<svg width="0" height="0" display="none" xmlns="http://www.w3.org/2000/svg"><symbol id="tip-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"/></symbol><symbol id="note-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="warning-notice" viewBox="0 0 576 512" preserveAspectRatio="xMidYMid meet"><path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="info-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/></symbol></svg><div class="notice warning" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#warning-notice"></use></svg></span>Warning</p><p>注意:
每个数组中的元素不会超过 100
数组的大小不会超过 200</p></div>
</p>
<p>示例 1:</p>
<blockquote>
<p>输入: [1, 5, 11, 5]<br>
输出: true</p>
</blockquote>
<p>解释: 数组可以分割成 [1, 5, 5] 和 [11].</p>
<p>示例 2:</p>
<blockquote>
<p>输入: [1, 2, 3, 5]<br>
输出: false</p>
</blockquote>
<p>解释: 数组不能分割成两个元素和相等的子集.</p>
<h4 id="思路">思路</h4>
<p>求解此问题等价于判断是否可以从这些数中选出若干书使得它们的和所有数之和（前提是偶数）的一半。因此这个问题可以转换成01背包问题.<br>
转移方程
$$ dp[j]=dp[j] ∣ dp[j−nums[i]] $$</p>
<h4 id="code-2">Code</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">bool</span> canPartition(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> nums.size();
        <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">return</span> false;
        <span style="color:#66d9ef">auto</span> sum <span style="color:#f92672">=</span> accumulate(nums.begin(), nums.end(), <span style="color:#ae81ff">0</span>);
        <span style="color:#66d9ef">if</span> (sum <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> false;
        <span style="color:#66d9ef">auto</span> _max <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>max_element(nums.begin(), nums.end());
        <span style="color:#66d9ef">auto</span> target <span style="color:#f92672">=</span> sum <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (_max <span style="color:#f92672">&gt;</span> target) <span style="color:#66d9ef">return</span> false;
        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> dp(target <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, false);
        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> true;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> target; j <span style="color:#f92672">&gt;=</span> nums[i]; j<span style="color:#f92672">--</span>)
                dp[j] <span style="color:#f92672">=</span> dp[j] <span style="color:#f92672">||</span> dp[j <span style="color:#f92672">-</span> nums[i]];
        }
        <span style="color:#66d9ef">return</span> dp[target];
    }
};
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>字典树（trie tree）</title>
            <link>https://fffzlfk.gitlab.io/posts/%E5%AD%97%E5%85%B8%E6%A0%91trie-tree/</link>
            <pubDate>Sat, 03 Oct 2020 12:45:22 +0800</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/posts/%E5%AD%97%E5%85%B8%E6%A0%91trie-tree/</guid>
            <description>hihoCoder#1014</description>
            <content type="html"><![CDATA[<style type="text/css">.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative}</style>
<svg width="0" height="0" display="none" xmlns="http://www.w3.org/2000/svg"><symbol id="tip-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"/></symbol><symbol id="note-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="warning-notice" viewBox="0 0 576 512" preserveAspectRatio="xMidYMid meet"><path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="info-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/></symbol></svg><div class="notice warning" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#warning-notice"></use></svg></span>Warning</p><p>时间限制:10000ms<br>
单点时限:1000ms<br>
内存限制:256MB</p></div>

<h2 id="描述">描述</h2>
<p>小Hi和小Ho是一对好朋友，出生在信息化社会的他们对编程产生了莫大的兴趣，他们约定好互相帮助，在编程的学习道路上一同前进。</p>
<p>这一天，他们遇到了一本词典，于是小Hi就向小Ho提出了那个经典的问题：“小Ho，你能不能对于每一个我给出的字符串，都在这个词典里面找到以这个字符串开头的所有单词呢？”</p>
<p>身经百战的小Ho答道：“怎么会不能呢！你每给我一个字符串，我就依次遍历词典里的所有单词，检查你给我的字符串是不是这个单词的前缀不就是了？”</p>
<p>小Hi笑道：“你啊，还是太年轻了！~假设这本词典里有10万个单词，我询问你一万次，你得要算到哪年哪月去？”</p>
<p>小Ho低头算了一算，看着那一堆堆的0，顿时感觉自己这辈子都要花在上面了&hellip;</p>
<p>小Hi看着小Ho的囧样，也是继续笑道：“让我来提高一下你的知识水平吧~你知道树这样一种数据结构么？”</p>
<p>小Ho想了想，说道：“知道~它是一种基础的数据结构，就像<a href="http://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)">这里</a>说的一样！”</p>
<p>小Hi满意的点了点头，说道：“那你知道我怎么样用一棵树来表示整个词典么？”</p>
<p>小Ho摇摇头表示自己不清楚。</p>
<div class="notice tip" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"></use></svg></span>Tip</p><p>提示一：Trie树的建立<br>
小Hi于是在纸上画了一会，递给小Ho，道：“你看这棵树和这个词典有什么关系？”</p>
<p><img src="http://media.hihocoder.com//problem_images/20140712/14051554971354.jpg" alt=""></p>
<p>小Ho盯着手里的纸想了一会道：“我知道了！对于从树的根节点走到每一个黑色节点所经过的路径，如果将路径上的字母都连起来的话，就都对应着词典中的一个单词呢！”</p>
<p>小Hi说道：“那你知道如何根据一个词典构建这样一棵树么？”</p>
<p>“不造！”</p>
<p>“想你也不知道，我来告诉你吧~”小Hi摆出一副老师的样子，说道：“你先这么想，如果我已经有了这样的一个词典和对应的一棵树，我要添加一个新的单词apart，我应该怎么做？”</p>
<p>“让我想想……”小Ho又开始苦思冥想：“首先我要先看看已经能走到哪一步了对吧？比如我从1号节点走&quot;a&quot;这一条边就可以走到2号节点，然后从2号节点走&quot;p&quot;这一条边可以走到3号节点，然后……就没路可走了！这时候我就需要添加一条从3号节点出发且标记为&quot;p&quot;的边才可以接着往下走……最后就是这样了！然后我把最后到达的这个结点标记为黑色就可以了。”</p>
<p><img src="http://media.hihocoder.com//problem_images/20140712/14051555414053.jpg" alt=""></p>
<p>小Hi说道：“真聪明~那你不妨再算算如果是一个有10W个单词的词典，每个单词的长度不超过10的话，这棵树会有多大？”</p>
<p>小Ho于是掏出笔来，一边画一遍念叨：“假设我已经将前三个单词构成了这样一棵树，那么我要添加一个新的单词的时候，最坏情况是这个单词和之前的三个单词都没有公共前缀，那么这个新的单词的长度如果是5的话，我就至少要添加5个结点到树中才能够继续表示这个词典！”</p>
<p>“而如果每次都是最坏情况的话，这棵树最多也就100W个结点这么大！更何况最坏情况是不可能次次都发生的！毕竟字母表也才26个字母呢！”小Ho继续说道。</p>
<p>“嗯~这样我们是不是就可以用（单词个数*单词长度）个结点来表示一个词典了呢？小Hi问道。</p>
<p>“是的呢！”小Ho道：“但是这样一棵树又有什么用呢？”</p>
<p>“可别小看了它，它就是传说中的Trie树哦~至于他有什么用，一会你就知道了！”小Hi笑嘻嘻的回答道。</p></div>

<p>“你看，我们现在得到了这样一棵树，那么你看，如果我给你一个字符串ap，你要怎么找到所有以ap开头的单词呢？”小Hi又开始考校小Ho。</p>
<p>“唔&hellip;一个个遍历所有的单词？”小Ho还是不忘自己最开始提出来的算法。</p>
<p>“笨！这棵树难道就白构建了！”小Hi教训完小Ho，继续道：“看好了！”
<div class="notice tip" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"></use></svg></span>Tip</p><p>提示二：如何使用Trie树<br>
小Hi在树上用绿色标出了一个节点，递给小Ho。
<img src="http://media.hihocoder.com//problem_images/20140712/14051555696936.jpg" alt=""></p>
<p>“这个结点……是从根节点先走&quot;a&quot;然后走&quot;p&quot;到达的结点呢！哦~~我知道了，以这个结点为根的子树里所有标记结点都是以&quot;ap&quot;为前缀的单词呢！而且所有以&quot;ap&quot;为前缀的单词都在以这个节点为根的子树里~”小Ho惊喜道。</p>
<p>“是的呢~那你对怎么解决我的问题有想法了么？”小Hi追问道。</p>
<p>“唔&hellip;那就是每次拿到你的字符串之后，我在树上找到其对应的那个结点，然后统计这个节点中有多少个标记节点？”小Ho不是很确定的答道：“但是这样&hellip;似乎在最坏情况，也就是你每次给个字符串都很短的时候，我还是要扫描这棵树的很大一部分呢？也就是说虽然平均时间复杂度降低了，但是最坏情况时间复杂度还是很高的样子！”</p>
<p>小Hi笑嘻嘻道：”没想到你自己看出来了呢~我还以为又要教训你了！~那你有什么好的解决方法么？”</p>
<p>“没呢！小Hi你就别卖关子了，赶紧告诉我吧！”被折磨的够呛的小Ho开始求饶。</p>
<p>“好吧！就帮你这一回~”</p></div>

<div class="notice tip" >
<p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#tip-notice"></use></svg></span>Tip</p><p>提示三：在建立Trie树时同时进行统计！<br>
“小Ho你有没有想过这样一个问题？不妨称以T为根的子树中标记节点的个数为L[T]，既然我要统计某个L[T1]，，而这个结点是不确定的，我有没有办法一次性把所有结点的L[T]求出来呢？”小Hi整理了下思绪，问道。</p>
<p>“似乎是有的，老师以前说过，递归什么的。。”小Ho答道。</p>
<p>“递归太复杂了！我们可以之后再说，你这么想，在你构建Trie树的时候，当你经过一个结点的时候，说明了什么？”小Hi撇了撇头，继续问道。</p>
<p>“我想想，经过一个结点……标记结点……说明了以这个结点为根的子树中将要多出来一个标记结点？”</p>
<p>“没错！那你有没有什么办法来记录这个改变呢？”</p>
<p>“我想想，我在最开始置所有L[T]=0，然后每次添加一个新的单词的时候，都将它经过的所有结点的L[T]全部+1，这样我构建完这棵Trie树的时候，我也就能够同时统计到所有L[T]了，对么？”小Ho开心道。</p></div>

“那么现在！赶紧去用代码实现吧！”小Hi如是说道</p>
<h2 id="样例输入">样例输入</h2>
<blockquote>
<p>5<br>
babaab<br>
babbbaaaa<br>
abba<br>
aaaaabaa<br>
babaababb<br>
5<br>
babb<br>
baabaaa<br>
bab<br>
bb<br>
bbabbaab</p>
</blockquote>
<h2 id="样例输出">样例输出</h2>
<blockquote>
<p>1<br>
0<br>
3<br>
0<br>
0</p>
</blockquote>
<h2 id="代码">代码</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span> {
    Node<span style="color:#f92672">*</span> next[<span style="color:#ae81ff">26</span>];
    <span style="color:#66d9ef">int</span> count;
    Node() {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">26</span>; i<span style="color:#f92672">++</span>) next[i] <span style="color:#f92672">=</span> NULL;
        count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    }
};
Node <span style="color:#f92672">*</span>root;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(string word) {
	Node <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> root;
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>e : word) {
		<span style="color:#66d9ef">int</span>	tmp <span style="color:#f92672">=</span> e <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>;
		<span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>next[tmp] <span style="color:#f92672">==</span> NULL)
			p<span style="color:#f92672">-&gt;</span>next[tmp] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node();
		p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next[tmp];
		p<span style="color:#f92672">-&gt;</span>count<span style="color:#f92672">++</span>;
	}
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get_cnt</span>(string word) {
	Node <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> root;
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>e : word) {
		<span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> e <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>;
		<span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>next[tmp] <span style="color:#f92672">==</span> NULL)
			p<span style="color:#f92672">-&gt;</span>next[tmp] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node();
		p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next[tmp];
	}
	<span style="color:#66d9ef">return</span> p<span style="color:#f92672">-&gt;</span>count;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() { 
	ios<span style="color:#f92672">::</span>sync_with_stdio(false);
	cin.tie(<span style="color:#ae81ff">0</span>);
	root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node();
	<span style="color:#66d9ef">int</span> n, m;
	cin <span style="color:#f92672">&gt;&gt;</span> n;
	string str;
	<span style="color:#66d9ef">while</span> (n<span style="color:#f92672">--</span>) {
		cin <span style="color:#f92672">&gt;&gt;</span> str;
		insert(str);	
	}
	cin <span style="color:#f92672">&gt;&gt;</span> m;
	<span style="color:#66d9ef">while</span> (m<span style="color:#f92672">--</span>) {
		cin <span style="color:#f92672">&gt;&gt;</span> str;
		printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, get_cnt(str));
	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>算法进阶指南打卡</title>
            <link>https://fffzlfk.gitlab.io/posts/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%E6%89%93%E5%8D%A1/</link>
            <pubDate>Tue, 22 Sep 2020 12:45:22 +0800</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/posts/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%E6%89%93%E5%8D%A1/</guid>
            <description>蓝书</description>
            <content type="html"><![CDATA[<h3 id="位运算">位运算</h3>
<h4 id="ab">a^b</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">using</span> ll <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;

ll <span style="color:#a6e22e">fast_pow</span>(ll a, ll b, ll p) {
    ll ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> (b) {
        <span style="color:#66d9ef">if</span> (b <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) ans <span style="color:#f92672">=</span> ans <span style="color:#f92672">*</span> a <span style="color:#f92672">%</span> p;
        a <span style="color:#f92672">=</span> a <span style="color:#f92672">*</span> a <span style="color:#f92672">%</span> p;
        b <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">return</span> ans <span style="color:#f92672">%</span> p;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    ll a, b, p;
    cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b <span style="color:#f92672">&gt;&gt;</span> p;
    cout <span style="color:#f92672">&lt;&lt;</span> fast_pow(a, b, p) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="ab-1">a*b</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">using</span> ll <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
ll <span style="color:#a6e22e">mul</span>(ll a, ll b, ll p) {
    ll ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> (b) {
        <span style="color:#66d9ef">if</span> (b <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) ans <span style="color:#f92672">=</span> (ans <span style="color:#f92672">+</span> a) <span style="color:#f92672">%</span> p;
        a <span style="color:#f92672">=</span> a <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">%</span> p;
        b <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">return</span> ans;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    ll a, b, p;
    cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b <span style="color:#f92672">&gt;&gt;</span> p;
    cout <span style="color:#f92672">&lt;&lt;</span> mul(a, b, p) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

</code></pre></div><h4 id="hamilton">hamilton</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/*************************************************************************
</span><span style="color:#75715e">    &gt; File Name: hamilton.cpp
</span><span style="color:#75715e">    &gt; Author: fffzlfk
</span><span style="color:#75715e">    &gt; Mail: fffzlfk@qq.com
</span><span style="color:#75715e">    &gt; Created Time: Wed Sep 23 10:29:48 2020
</span><span style="color:#75715e"> ************************************************************************/</span>

<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> w[<span style="color:#ae81ff">20</span>][<span style="color:#ae81ff">20</span>];
<span style="color:#66d9ef">int</span> f[<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">20</span>][<span style="color:#ae81ff">20</span>];
<span style="color:#66d9ef">int</span> n;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hamilton</span>() {
    memset(f, <span style="color:#ae81ff">0x3f</span>, <span style="color:#66d9ef">sizeof</span>(f));
    f[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> n; i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&gt;&gt;</span> j <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>)
                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k <span style="color:#f92672">&lt;</span> n; k<span style="color:#f92672">++</span>)
                    <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&gt;&gt;</span> k <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>)
                        f[i][j] <span style="color:#f92672">=</span> min(f[i][j], f[i <span style="color:#f92672">^</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> j][k] <span style="color:#f92672">+</span> w[k][j]);
    <span style="color:#66d9ef">return</span> f[(<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> n) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>) cin <span style="color:#f92672">&gt;&gt;</span> w[i][j];
    cout <span style="color:#f92672">&lt;&lt;</span> hamilton() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="递归">递归</h3>
<h4 id="递归实现指数型枚举">递归实现指数型枚举</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> n;
vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> tmp;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> idx) {
    <span style="color:#66d9ef">if</span> (idx <span style="color:#f92672">==</span> n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>e : tmp) cout <span style="color:#f92672">&lt;&lt;</span> e <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span>;
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
        <span style="color:#66d9ef">return</span>;
    }
    tmp.emplace_back(idx);
    dfs(idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
    tmp.pop_back();
    dfs(idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    dfs(<span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="递归实现组合型枚举">递归实现组合型枚举</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> n, m;
vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> tmp;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> idx) {
    <span style="color:#66d9ef">if</span> (tmp.size() <span style="color:#f92672">&gt;</span> m <span style="color:#f92672">||</span> tmp.size() <span style="color:#f92672">+</span> (n <span style="color:#f92672">-</span> idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&lt;</span> m) <span style="color:#66d9ef">return</span>;
    <span style="color:#66d9ef">if</span> (idx <span style="color:#f92672">==</span> n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>e : tmp) cout <span style="color:#f92672">&lt;&lt;</span> e <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span>;
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
        <span style="color:#66d9ef">return</span>;
    }
    tmp.emplace_back(idx);
    dfs(idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
    tmp.pop_back();
    dfs(idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
    dfs(<span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="二分">二分</h3>
<h4 id="二分查找左右边界">二分查找左右边界</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get_right</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> a, <span style="color:#66d9ef">int</span> x) {
    <span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, r <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)a.size();
    <span style="color:#66d9ef">while</span> (l <span style="color:#f92672">&lt;</span> r) {
        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (a[mid] <span style="color:#f92672">&gt;=</span> x)
            r <span style="color:#f92672">=</span> mid;
        <span style="color:#66d9ef">else</span>
            l <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">return</span> l;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get_left</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> a, <span style="color:#66d9ef">int</span> x) {
    <span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, r <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)a.size();
    <span style="color:#66d9ef">while</span> (l <span style="color:#f92672">&lt;</span> r) {
        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (a[mid] <span style="color:#f92672">&lt;=</span> x)
            l <span style="color:#f92672">=</span> mid;
        <span style="color:#66d9ef">else</span>
            r <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">return</span> l;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> a <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">19</span>};
    cout <span style="color:#f92672">&lt;&lt;</span> get_left(a, <span style="color:#ae81ff">6</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> get_right(a, <span style="color:#ae81ff">6</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="三分法求极值">三分法求极值</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> a;
<span style="color:#66d9ef">int</span> n;
<span style="color:#66d9ef">double</span> l, r;

<span style="color:#66d9ef">double</span> <span style="color:#a6e22e">cal</span>(<span style="color:#66d9ef">double</span> x) {
    <span style="color:#66d9ef">double</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) res <span style="color:#f92672">+=</span> a[i] <span style="color:#f92672">*</span> pow(x, i);
    <span style="color:#66d9ef">return</span> res;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> l <span style="color:#f92672">&gt;&gt;</span> r;
    a.resize(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) cin <span style="color:#f92672">&gt;&gt;</span> a[i];
    <span style="color:#66d9ef">while</span> (fabs(l <span style="color:#f92672">-</span> r) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1e-6</span>) {
        <span style="color:#66d9ef">double</span> mid <span style="color:#f92672">=</span> (l <span style="color:#f92672">+</span> r) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">if</span> (cal(mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1e-6</span>) <span style="color:#f92672">&lt;</span> cal(mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1e-6</span>))
            l <span style="color:#f92672">=</span> mid;
        <span style="color:#66d9ef">else</span>
            r <span style="color:#f92672">=</span> mid;
    }
    printf(<span style="color:#e6db74">&#34;%.5lf</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, r);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="二分答案转换为判定">二分答案转换为判定</h4>
<blockquote>
<p>有n本书排成一行，已知第i本书的厚度是$A_i$。把它们分成连续的M组，使得T最小化，其中T表示厚度之和最大的一组的厚度。</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> n, m;
<span style="color:#66d9ef">int</span> a[<span style="color:#ae81ff">1005</span>];
<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">check</span>(<span style="color:#66d9ef">int</span> size) {
    <span style="color:#66d9ef">int</span> tot <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, rest <span style="color:#f92672">=</span> size;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (res <span style="color:#f92672">&gt;=</span> a[i])
            res <span style="color:#f92672">-=</span> a[i];
        <span style="color:#66d9ef">else</span> {
            tot<span style="color:#f92672">++</span>;
            res <span style="color:#f92672">=</span> size <span style="color:#f92672">-</span> a[i];
        }
    }
	<span style="color:#66d9ef">return</span> tol <span style="color:#f92672">&lt;=</span> m;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> sum_of_ai <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> a[i];
        sum_of_ai <span style="color:#f92672">+=</span> a[i];
    }
    <span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, r <span style="color:#f92672">=</span> sum_of_ai;
    <span style="color:#66d9ef">while</span> (l <span style="color:#f92672">&lt;</span> r) {
        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (check(mid))
            r <span style="color:#f92672">=</span> mid;
        <span style="color:#66d9ef">else</span>
            l <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    }
    cout <span style="color:#f92672">&lt;&lt;</span> l <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>CF#653(div3)</title>
            <link>https://fffzlfk.gitlab.io/2020/08/03/cf#653div3/</link>
            <pubDate>Mon, 03 Aug 2020 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2020/08/03/cf#653div3/</guid>
            <description>AC代码 AC代码 AC代码 AC代码 AC代码 </description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<h4 id="ac代码">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-1">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-2">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-3">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-4">AC代码</h4>
<!-- raw HTML omitted -->
]]></content>
        </item>
        
        <item>
            <title>LeetCode杂题</title>
            <link>https://fffzlfk.gitlab.io/2020/07/27/leetcode/</link>
            <pubDate>Mon, 27 Jul 2020 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2020/07/27/leetcode/</guid>
            <description>AC代码 &amp;lt;span class=&amp;quot;hljs-function&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;bool&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;hljs-title&amp;quot;&amp;gt;isPathCrossing&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;hljs-params&amp;quot;&amp;gt;(&amp;lt;span class=&amp;quot;hljs-built_in&amp;quot;&amp;gt;string&amp;lt;/span&amp;gt; path)&amp;lt;/span&amp;gt; &amp;lt;/span&amp;gt;{M[make_pair(&amp;lt;span class=&amp;quot;hljs-number&amp;quot;&amp;gt;0&amp;lt;/span&amp;gt;, &amp;lt;span class=&amp;quot;hljs-number&amp;quot;&amp;gt;0&amp;lt;/span&amp;gt;)] = &amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;true&amp;lt;/span&amp;gt;;&amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;int&amp;lt;/span&amp;gt; x = &amp;lt;span class=&amp;quot;hljs-number&amp;quot;&amp;gt;0&amp;lt;/span&amp;gt;, y = &amp;lt;span class=&amp;quot;hljs-number&amp;quot;&amp;gt;0&amp;lt;/span&amp;gt;;&amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;for&amp;lt;/span&amp;gt; (&amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;auto&amp;lt;/span&amp;gt; i : path) {&amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;if&amp;lt;/span&amp;gt; (i == &amp;lt;span class=&amp;quot;hljs-string&amp;quot;&amp;gt;&#39;N&#39;&amp;lt;/span&amp;gt;) {x--;} &amp;lt;span class=&amp;quot;hljs-function&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;else&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;hljs-title&amp;quot;&amp;gt;if&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;hljs-params&amp;quot;&amp;gt;(i == &#39;S&#39;)&amp;lt;/span&amp;gt; &amp;lt;/span&amp;gt;{x++;} &amp;lt;span class=&amp;quot;hljs-function&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;else&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;hljs-title&amp;quot;&amp;gt;if&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;hljs-params&amp;quot;&amp;gt;(i == &#39;W&#39;)&amp;lt;/span&amp;gt; &amp;lt;/span&amp;gt;{y--;} &amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;else&amp;lt;/span&amp;gt; y++;&amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;if&amp;lt;/span&amp;gt; (M[make_pair(x, y)]) &amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;true&amp;lt;/span&amp;gt;;M[make_pair(x, y)] = &amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;true&amp;lt;/span&amp;gt;;}&amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;hljs-keyword&amp;quot;&amp;gt;false&amp;lt;/span&amp;gt;;} };AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 AC代码 面试题-二分 求波动数组[1, 3, 5, 7, 9, 11, 13, 8, 1]中的最大值。</description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<h4 id="ac代码">AC代码</h4>
<!-- raw HTML omitted -->
<pre><code>&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;isPathCrossing&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; path)&lt;/span&gt; &lt;/span&gt;{
    M[make_pair(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)] = &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, y = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; i : path) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (i == &lt;span class=&quot;hljs-string&quot;&gt;'N'&lt;/span&gt;) {
            x--;
        } &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(i == 'S')&lt;/span&gt; &lt;/span&gt;{
            x++;
        } &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(i == 'W')&lt;/span&gt; &lt;/span&gt;{
            y--;
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; y++;
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (M[make_pair(x, y)]) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;
        M[make_pair(x, y)] = &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;
}
</code></pre>
<p>};<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<h4 id="ac代码-1">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-2">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-3">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-4">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-5">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-6">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-7">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-8">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-9">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-10">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-11">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-12">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-13">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-14">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-15">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-16">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-17">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-18">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-19">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-20">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-21">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-22">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-23">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="面试题-二分">面试题-二分</h3>
<p>求波动数组[1, 3, 5, 7, 9, 11, 13, 8, 1]中的最大值。</p>
<h4 id="ac代码-24">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-25">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-26">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-27">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-28">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-29">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-30">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-31">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-32">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-33">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-34">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-35">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-36">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-37">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-38">AC代码</h4>
<!-- raw HTML omitted -->
]]></content>
        </item>
        
        <item>
            <title>不修改数组找出重复的数字</title>
            <link>https://fffzlfk.gitlab.io/2020/07/13/%D2%B3%D8%B8/</link>
            <pubDate>Mon, 13 Jul 2020 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2020/07/13/%D2%B3%D8%B8/</guid>
            <description>问题描述 给定一个长度为$$ n+1 $$的数组nums，数组中所有的数均在$$ 1∼n $$的范围内，其中$$ n≥1 $$。
请找出数组中任意一个重复的数，但不能修改输入的数组。
样例 给定$ nums = [2, 3, 5, 4, 3, 2, 6, 7]$。
返回 2 或 3。 思考题：如果只能使用 $ O(1) $ 的额外空间，该怎么做呢？
分治，抽屉原理解法-$ O(nlogn) $  抽屉原理：n+1 个苹果放在 n 个抽屉里，那么至少有一个抽屉中会放两个苹果。
 用在这个题目中就是，一共有$ n+1 $个数，每个数的取值范围是1到n，所以至少会有一个数出现两次。
然后我们采用分治的思想，将每个数的取值的区间 $ [1, n] $划分成$ [1, n/2] $和$ [n/2+1, n] $两个子区间，然后分别统计两个区间中数的个数。 注意这里的区间是指 数的取值范围，而不是 数组下标。
划分之后，左右两个区间里一定至少存在一个区间，区间中数的个数大于区间长度。 这个可以用反证法来说明：如果两个区间中数的个数都小于等于区间长度，那么整个区间中数的个数就小于等于n，和有n+1个数矛盾。
因此我们可以把问题划归到左右两个子区间中的一个，而且由于区间中数的个数大于区间长度，根据抽屉原理，在这个子区间中一定存在某个数出现了两次。
依次类推，每次我们可以把区间长度缩小一半，直到区间长度为1时，我们就找到了答案。
复杂度分析 时间复杂度：每次会将区间长度缩小一半，一共会缩小 $ O(logn) $次。每次统计两个子区间中的数时需要遍历整个数组，时间复杂度是$ O(n) $。所以总时间复杂度是$ O(nlogn) $。 空间复杂度：代码中没有用到额外的数组，所以额外的空间复杂度是 $ O(1) $。</description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="问题描述">问题描述</h3>
<p>给定一个长度为$$ n+1 $$的数组nums，数组中所有的数均在$$ 1∼n $$的范围内，其中$$ n≥1 $$。</p>
<p>请找出数组中任意一个重复的数，但不能修改输入的数组。</p>
<p>样例
给定$ nums = [2, 3, 5, 4, 3, 2, 6, 7]$。</p>
<p>返回 2 或 3。
思考题：如果只能使用 $ O(1) $ 的额外空间，该怎么做呢？</p>
<h3 id="分治抽屉原理解法--onlogn-">分治，抽屉原理解法-$ O(nlogn) $</h3>
<blockquote>
<p>抽屉原理：n+1 个苹果放在 n 个抽屉里，那么至少有一个抽屉中会放两个苹果。</p>
</blockquote>
<p>用在这个题目中就是，一共有$ n+1 $个数，每个数的取值范围是1到n，所以至少会有一个数出现两次。</p>
<p>然后我们采用分治的思想，将每个数的取值的区间 $ [1, n] $划分成$ [1, n/2] $和$ [n/2+1, n] $两个子区间，然后分别统计两个区间中数的个数。
注意这里的区间是指 数的取值范围，而不是 数组下标。</p>
<p>划分之后，左右两个区间里一定至少存在一个区间，区间中数的个数大于区间长度。
这个可以用反证法来说明：如果两个区间中数的个数都小于等于区间长度，那么整个区间中数的个数就小于等于n，和有n+1个数矛盾。</p>
<p>因此我们可以把问题划归到左右两个子区间中的一个，而且由于区间中数的个数大于区间长度，根据抽屉原理，在这个子区间中一定存在某个数出现了两次。</p>
<p>依次类推，每次我们可以把区间长度缩小一半，直到区间长度为1时，我们就找到了答案。</p>
<h4 id="复杂度分析">复杂度分析</h4>
<p>时间复杂度：每次会将区间长度缩小一半，一共会缩小 $ O(logn) $次。每次统计两个子区间中的数时需要遍历整个数组，时间复杂度是$ O(n) $。所以总时间复杂度是$ O(nlogn) $。
空间复杂度：代码中没有用到额外的数组，所以额外的空间复杂度是 $ O(1) $。</p>
<p><!-- raw HTML omitted -->参考链接<!-- raw HTML omitted --></p>
<h4 id="ac代码">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="链表解法--on-">链表解法-$ O(n) $</h3>
<p>两点前置知识：</p>
<ol>
<li>如何判断链表是否存在环？
双指针，一快（每次跑两格）一慢（每次跑一格），从链表首部开始遍历，两个指针最终都会进入环内，由于快指针每次比慢指针多走一格，因此快指针一定能在环内追上慢指针。而如果链表没环，那么快慢指针不会相遇。</li>
<li>对于有环的链表，如何找到环的起点？
基于第一点，快慢指针相遇时，我们可以证明相遇的点与环起点的距离，一定和链表首部与环起点的距离相等。</li>
</ol>
<p>我们可以将数组视为一个（或多个链表），每个元素都是一个节点，元素的下标代表节点地址，元素的值代表next指针，因此，重复的元素意味着两个节点的next指针一样，即指向同一个节点，因此存在环，且环的起点即重复的元素。</p>
<p>为了找到任意一个环的起点（重复元素），我们只需要拿到一个链表的首部，然后利用前置知识即可解决问题。显然，0一定是一个链表的首部，因为所有元素值的范围在1 - n-1之间，即没有节点指向0节点。</p>
<p>题解流程即为：从0开始，快慢指针分别以2、1的速度向前遍历，当它们相遇时，将快指针置为0，继续分别以1、1的速度向前遍历，当它们再次相遇时，此时它们的下标就是题解。</p>
<h4 id="时间复杂度分析">时间复杂度分析</h4>
<p>慢指针每次走一格，刚好遍历到链表尾部（即环起点）处结束，因此复杂度为$ O(n) $
空间复杂度分析：$ O(1) $</p>
<p><!-- raw HTML omitted -->参考链接<!-- raw HTML omitted --></p>
<h4 id="ac代码-1">AC代码</h4>
<!-- raw HTML omitted -->
]]></content>
        </item>
        
        <item>
            <title>单调队列</title>
            <link>https://fffzlfk.gitlab.io/2020/07/03//</link>
            <pubDate>Fri, 03 Jul 2020 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2020/07/03//</guid>
            <description>&amp;lt;script&amp;gt;hljs.initHighlightingOnLoad();&amp;lt;/script&amp;gt; 题目描述 有一个长为$ n $的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。
例如：
The array is $[1,3,-1,-3,5,3,6,7]$, and $k = 3$。 输入格式 输入一共有两行，第一行有两个正整数 $n, k$。 第二行 $n $个整数，表示序列 $a$
输出格式 输出共两行，第一行为每次窗口滑动的最小值 第二行为每次窗口滑动的最大值
输入输出样例 输入8 31 3 -1 -3 5 3 6 7输出-1 -3 -3 -3 3 33 3 5 5 6 7说明/提示 【数据范围】 对于 $50% $的数据，$1 \le n \le 10^5$； 对于 $100%$的数据，$1\le k \le n \le 10^6 ，a_i \in [-2^{31},2^{31})$。</description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<pre><code>&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;
</code></pre>
<!-- raw HTML omitted -->
<h3 id="题目描述">题目描述</h3>
<p>有一个长为$ n $的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。</p>
<p>例如：</p>
<p>The array is $[1,3,-1,-3,5,3,6,7]$, and $k = 3$。
<!-- raw HTML omitted --></p>
<h3 id="输入格式">输入格式</h3>
<p>输入一共有两行，第一行有两个正整数 $n, k$。 第二行 $n $个整数，表示序列 $a$</p>
<h3 id="输出格式">输出格式</h3>
<p>输出共两行，第一行为每次窗口滑动的最小值
第二行为每次窗口滑动的最大值</p>
<h3 id="输入输出样例">输入输出样例</h3>
<pre><code>输入
8 3
1 3 -1 -3 5 3 6 7
</code></pre><pre><code>输出
-1 -3 -3 -3 3 3
3 3 5 5 6 7
</code></pre><h3 id="说明提示">说明/提示</h3>
<p>【数据范围】
对于 $50% $的数据，$1 \le n \le 10^5$；
对于 $100%$的数据，$1\le k \le n \le 10^6
，a_i \in [-2^{31},2^{31})$。</p>
<h3 id="分析">分析</h3>
<p>要求的是每连续的$k$个数中的最大（最小）值，很明显，当一个数进入所要 &ldquo;寻找&rdquo; 最大值的范围中时，若这个数比其前面（先进队）的数要大，显然，前面的数会比这个数先出队且不再可能是最大值。</p>
<p>也就是说——当满足以上条件时，可将前面的数 &ldquo;弹出&rdquo;，再将该数真正 push 进队尾。</p>
<p>这就相当于维护了一个递减的队列，符合单调队列的定义，减少了重复的比较次数，不仅如此，由于维护出的队伍是查询范围内的且是递减的，队头必定是该查询区域内的最大值，因此输出时只需输出队头即可。</p>
<p>显而易见的是，在这样的算法中，每个数只要进队与出队各一次，因此时间复杂度被降到了$O(N)$。</p>
<p>而由于查询区间长度是固定的，超出查询空间的值再大也不能输出，因此还需要 site 数组记录第 $i$ 个队中的数在原数组中的位置，以弹出越界的队头。</p>
<h3 id="ac代码">AC代码</h3>
<!-- raw HTML omitted -->
<p>void getmin() {
<!-- raw HTML omitted -->int<!-- raw HTML omitted --> head = <!-- raw HTML omitted -->0<!-- raw HTML omitted -->, tail = <!-- raw HTML omitted -->0<!-- raw HTML omitted -->;
<!-- raw HTML omitted -->for<!-- raw HTML omitted --> (<!-- raw HTML omitted -->int<!-- raw HTML omitted --> i = <!-- raw HTML omitted -->1<!-- raw HTML omitted -->; i &lt; k; i++) {
<!-- raw HTML omitted -->while<!-- raw HTML omitted --> (head &lt;= tail &amp;&amp; a[<!-- raw HTML omitted -->q[tail]<!-- raw HTML omitted -->] &gt;= a[i])
tail&ndash;;
<!-- raw HTML omitted -->q[++tail]<!-- raw HTML omitted --> = i;
}
<!-- raw HTML omitted -->for<!-- raw HTML omitted --> (<!-- raw HTML omitted -->int<!-- raw HTML omitted --> i = k; i &lt;= n; i++) {
<!-- raw HTML omitted -->while<!-- raw HTML omitted --> (head &lt;= tail &amp;&amp; a[<!-- raw HTML omitted -->q[tail]<!-- raw HTML omitted -->] &gt;= a[i])
tail&ndash;;
<!-- raw HTML omitted -->q[++tail]<!-- raw HTML omitted --> = i;
<!-- raw HTML omitted -->while<!-- raw HTML omitted --> (<!-- raw HTML omitted -->q[head]<!-- raw HTML omitted --> &lt;= i - k)
head++;
<!-- raw HTML omitted -->printf<!-- raw HTML omitted -->(<!-- raw HTML omitted -->&quot;<!-- raw HTML omitted -->%d<!-- raw HTML omitted --> &ldquo;<!-- raw HTML omitted -->, a[<!-- raw HTML omitted -->q[head]<!-- raw HTML omitted -->]);
}
<!-- raw HTML omitted -->printf<!-- raw HTML omitted -->(<!-- raw HTML omitted -->&quot;\n&rdquo;<!-- raw HTML omitted -->);
}</p>
<p>void getmax() {
<!-- raw HTML omitted -->int<!-- raw HTML omitted --> head = <!-- raw HTML omitted -->0<!-- raw HTML omitted -->, tail = <!-- raw HTML omitted -->0<!-- raw HTML omitted -->;
<!-- raw HTML omitted -->for<!-- raw HTML omitted --> (<!-- raw HTML omitted -->int<!-- raw HTML omitted --> i = <!-- raw HTML omitted -->1<!-- raw HTML omitted -->; i &lt; k; i++) {
<!-- raw HTML omitted -->while<!-- raw HTML omitted --> (head &lt;= tail &amp;&amp; a[<!-- raw HTML omitted -->q[tail]<!-- raw HTML omitted -->] &lt;= a[i])
tail&ndash;;
<!-- raw HTML omitted -->q[++tail]<!-- raw HTML omitted --> = i;
}
<!-- raw HTML omitted -->for<!-- raw HTML omitted --> (<!-- raw HTML omitted -->int<!-- raw HTML omitted --> i = k; i &lt;= n; i++) {
<!-- raw HTML omitted -->while<!-- raw HTML omitted --> (head &lt;= tail &amp;&amp; a[<!-- raw HTML omitted -->q[tail]<!-- raw HTML omitted -->] &lt;= a[i])
tail&ndash;;
<!-- raw HTML omitted -->q[++tail]<!-- raw HTML omitted --> = i;
<!-- raw HTML omitted -->while<!-- raw HTML omitted --> (<!-- raw HTML omitted -->q[head]<!-- raw HTML omitted --> &lt;= i - k)
head++;
<!-- raw HTML omitted -->printf<!-- raw HTML omitted -->(<!-- raw HTML omitted -->&quot;<!-- raw HTML omitted -->%d<!-- raw HTML omitted --> &ldquo;<!-- raw HTML omitted -->, a[<!-- raw HTML omitted -->q[head]<!-- raw HTML omitted -->]);
}
<!-- raw HTML omitted -->printf<!-- raw HTML omitted -->(<!-- raw HTML omitted -->&quot;\n&rdquo;<!-- raw HTML omitted -->);
}</p>
<!-- raw HTML omitted -->
]]></content>
        </item>
        
        <item>
            <title>LeetCode第29场双周赛</title>
            <link>https://fffzlfk.gitlab.io/2020/06/28/leetcode29/</link>
            <pubDate>Sun, 28 Jun 2020 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2020/06/28/leetcode29/</guid>
            <description>题目描述 给你一个整数数组 salary ，数组里每个数都是 唯一 的，其中 salary[i] 是第 i 个员工的工资。 请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。
AC代码 class Solution { public: double average(vector&amp;lt;int&amp;gt;&amp;amp; salary) { int Max = *max_element(salary.begin(), salary.end()); int Min = *min_element(salary.begin(), salary.end()); int s = 0, cnt = 0; for (auto i : salary) if (i != Max &amp;amp;&amp;amp; i != Min) s += i, cnt++; return (double)s/(cnt); } }; 题目描述 给你两个正整数 n 和 k 。
如果正整数 i 满足 n % i == 0 ，那么我们就说正整数 i 是整数 n 的因子。</description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<h4 id="题目描述">题目描述</h4>
<p>给你一个整数数组 salary ，数组里每个数都是 唯一 的，其中 salary[i] 是第 i 个员工的工资。
请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。</p>
<h4 id="ac代码">AC代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">double</span> average(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> salary) {
        <span style="color:#66d9ef">int</span> Max <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>max_element(salary.begin(), salary.end());
        <span style="color:#66d9ef">int</span> Min <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>min_element(salary.begin(), salary.end());
        <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> i : salary)  <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> Max <span style="color:#f92672">&amp;&amp;</span> i <span style="color:#f92672">!=</span> Min) s <span style="color:#f92672">+=</span> i, cnt<span style="color:#f92672">++</span>;
        <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">double</span>)s<span style="color:#f92672">/</span>(cnt);
    }
};
</code></pre></div><!-- raw HTML omitted -->
<h4 id="题目描述-1">题目描述</h4>
<p>给你两个正整数 n 和 k 。</p>
<p>如果正整数 i 满足 n % i == 0 ，那么我们就说正整数 i 是整数 n 的因子。</p>
<p>考虑整数 n 的所有因子，将它们 升序排列 。请你返回第 k 个因子。如果 n 的因子数少于 k ，请你返回 -1 。</p>
<h4 id="ac代码-1">AC代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> kthFactor(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> k) {
        <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">%</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
                cnt<span style="color:#f92672">++</span>;
            }
            <span style="color:#66d9ef">if</span> (cnt <span style="color:#f92672">==</span> k) <span style="color:#66d9ef">return</span> i;
        }
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
};
</code></pre></div><!-- raw HTML omitted -->
<h4 id="题目描述-2">题目描述</h4>
<p>给你一个二进制数组 nums ，你需要从中删掉一个元素。</p>
<p>请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。</p>
<p>如果不存在这样的子数组，请返回 0 。</p>
<h4 id="ac代码-2">AC代码</h4>
<h5 id="解法1">解法1</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> longestSubarray(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
        <span style="color:#66d9ef">int</span> flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">int</span> Max <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)nums.size();
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len; i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">if</span> (nums[i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
                flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
                <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, right <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
                <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
                <span style="color:#66d9ef">while</span> (left <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> nums[left]) left<span style="color:#f92672">--</span>, cnt<span style="color:#f92672">++</span>;
                <span style="color:#66d9ef">while</span> (right <span style="color:#f92672">&lt;</span> len <span style="color:#f92672">&amp;&amp;</span> nums[right]) right<span style="color:#f92672">++</span>, cnt<span style="color:#f92672">++</span>;
                Max <span style="color:#f92672">=</span> max(cnt, Max);
            }
        }
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>flag) <span style="color:#66d9ef">return</span> len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">return</span> Max;
    }
};
</code></pre></div><h5 id="解法2">解法2</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> longestSubarray(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, z <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">if</span> (nums[i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) z<span style="color:#f92672">++</span>;
            <span style="color:#66d9ef">while</span> (z <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) z <span style="color:#f92672">-=</span> <span style="color:#f92672">!</span>nums[j<span style="color:#f92672">++</span>]; <span style="color:#75715e">// 如果当前有两个零，移动左指针到第一个零后面
</span><span style="color:#75715e"></span>            ans <span style="color:#f92672">=</span> max(ans, i <span style="color:#f92672">-</span> j);  
        }
        <span style="color:#66d9ef">return</span> ans;
    }
};
</code></pre></div><!-- raw HTML omitted -->
<h4 id="题目描述-3">题目描述</h4>
<p>给你一个整数 n 表示某所大学里课程的数目，编号为 1 到 n ，数组 dependencies 中， dependencies[i] = [xi, yi]  表示一个先修课的关系，也就是课程 xi 必须在课程 yi 之前上。同时你还有一个整数 k 。</p>
<p>在一个学期中，你 最多 可以同时上 k 门课，前提是这些课的先修课在之前的学期里已经上过了。</p>
<p>请你返回上完所有课最少需要多少个学期。题目保证一定存在一种上完所有课的方式。</p>
<h4 id="ac代码-3">AC代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/*
</span><span style="color:#75715e"> * f(state): 表示已经修过的所有课是state的所有方案的集合
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> f;
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">minNumberOfSemesters</span>(<span style="color:#66d9ef">int</span> n, vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> dependencies, <span style="color:#66d9ef">int</span> k) {
        f <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> n, <span style="color:#ae81ff">1000</span>);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> e : dependencies) {
            e[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">--</span>;
            e[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">--</span>;
        }
        f[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> n; i<span style="color:#f92672">++</span>) {
            vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> vis(n);
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> e : dependencies) {
                <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> e[<span style="color:#ae81ff">0</span>], y <span style="color:#f92672">=</span> e[<span style="color:#ae81ff">1</span>];
                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(i <span style="color:#f92672">&gt;&gt;</span> x <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>)) vis[y] <span style="color:#f92672">=</span> true;
            }
            <span style="color:#66d9ef">int</span> state <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>)
                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[j] <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>(i <span style="color:#f92672">&gt;&gt;</span> j <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>)) state <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> j;
            dfs(n, k, i, state, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
        }
        <span style="color:#66d9ef">return</span> f[(<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> n) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
    }
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> k, <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> state, <span style="color:#66d9ef">int</span> now, <span style="color:#66d9ef">int</span> start) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>k <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>state) {
            f[i <span style="color:#f92672">|</span> now] <span style="color:#f92672">=</span> min(f[i <span style="color:#f92672">|</span> now], f[i] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
            <span style="color:#66d9ef">return</span>;
        }
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> start; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">if</span> (state <span style="color:#f92672">&gt;&gt;</span> j <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>)
                dfs(n, k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, i, state <span style="color:#f92672">-</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> j), now <span style="color:#f92672">+</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> j), j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
        }
    }
};
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>背包九讲</title>
            <link>https://fffzlfk.gitlab.io/2020/06/25/%C5%BE/</link>
            <pubDate>Thu, 25 Jun 2020 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2020/06/25/%C5%BE/</guid>
            <description>#01 01背包问题 AC代码 AC代码 #02 完全背包问题 AC代码 AC代码 #03 多重背包问题 AC代码 AC代码 AC代码 #04 混合背包问题 AC代码 AC代码 AC代码 #06 分组背包问题 AC代码 #07 有依赖的背包问题 AC代码 AC代码 #08 背包问题求方案数 AC代码 #09 背包问题求具体方案 AC代码   </description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="01-01背包问题">#01 01背包问题</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-1">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="02-完全背包问题">#02 完全背包问题</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-2">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-3">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="03-多重背包问题">#03 多重背包问题</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-4">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-5">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-6">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="04-混合背包问题">#04 混合背包问题</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-7">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-8">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-9">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="06-分组背包问题">#06 分组背包问题</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-10">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="07-有依赖的背包问题">#07 有依赖的背包问题</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-11">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码-12">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="08-背包问题求方案数">#08 背包问题求方案数</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-13">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="09-背包问题求具体方案">#09 背包问题求具体方案</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-14">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<blockquote>
</blockquote>
]]></content>
        </item>
        
        <item>
            <title>KMP &amp; Manacher</title>
            <link>https://fffzlfk.gitlab.io/2020/06/24/kmpandmanacher/</link>
            <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2020/06/24/kmpandmanacher/</guid>
            <description>P3375 【模板】KMP字符串匹配 AC代码 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; const int maxn = 1e6 + 5; char s1[maxn]; char s2[maxn]; int _next[maxn]; void get_next(int len) { int j = 0; for (int i = 2; i &amp;lt;= len; i++) { while (j &amp;amp;&amp;amp; s2[j + 1] != s2[i]) j = _next[j]; if (s2[j + 1] == s2[i]) j++; _next[i] = j; } } void find(int len1, int len2) { int j = 0; for (int i = 1; i &amp;lt;= len1; i++) { while (j &amp;amp;&amp;amp; s2[j + 1] !</description>
            <content type="html"><![CDATA[<h3 id="p3375-模板kmp字符串匹配">P3375 【模板】KMP字符串匹配</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码">AC代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> maxn <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e6</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">5</span>;
<span style="color:#66d9ef">char</span> s1[maxn];
<span style="color:#66d9ef">char</span> s2[maxn];
<span style="color:#66d9ef">int</span> _next[maxn];

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">get_next</span>(<span style="color:#66d9ef">int</span> len) {
    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;=</span> len; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&amp;&amp;</span> s2[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> s2[i])
            j <span style="color:#f92672">=</span> _next[j];
        <span style="color:#66d9ef">if</span> (s2[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> s2[i])
            j<span style="color:#f92672">++</span>;
        _next[i] <span style="color:#f92672">=</span> j;
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> len1, <span style="color:#66d9ef">int</span> len2) {
    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> len1; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&amp;&amp;</span> s2[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> s1[i])
            j <span style="color:#f92672">=</span> _next[j];
        <span style="color:#66d9ef">if</span> (s2[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> s1[i])
            j<span style="color:#f92672">++</span>;
        <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> len2) {
            printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i <span style="color:#f92672">-</span> len2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
            j <span style="color:#f92672">=</span> _next[j];
        }
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> s1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    cin <span style="color:#f92672">&gt;&gt;</span> s2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">int</span> len1 <span style="color:#f92672">=</span> strlen(s1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">int</span> len2 <span style="color:#f92672">=</span> strlen(s2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
    get_next(len2);
    find(len1, len2);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> len2; i<span style="color:#f92672">++</span>)
        printf(<span style="color:#e6db74">&#34;%d &#34;</span>, _next[i]);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="p3805-模板manacher算法">P3805 【模板】manacher算法</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-1">AC代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> maxn <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.1e7</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">5</span>;
<span style="color:#66d9ef">char</span> s[maxn];
<span style="color:#66d9ef">char</span> ns[maxn <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>];
<span style="color:#66d9ef">int</span> p[maxn <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>];
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(<span style="color:#66d9ef">int</span> len) {
    ns[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;$&#39;</span>;
    ns[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;#&#39;</span>;
    <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len; i<span style="color:#f92672">++</span>) {
        ns[k<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> s[i];
        ns[k<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;#&#39;</span>;
    }
    ns[k] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">manacher</span>(<span style="color:#66d9ef">int</span> len) {
    <span style="color:#66d9ef">int</span> idx;
    <span style="color:#66d9ef">int</span> max_len <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">int</span> mx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> len; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> mx)
            p[i] <span style="color:#f92672">=</span> min(p[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> idx <span style="color:#f92672">-</span> i], mx <span style="color:#f92672">-</span> i);
        <span style="color:#66d9ef">else</span>
            p[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">while</span> (ns[i <span style="color:#f92672">-</span> p[i]] <span style="color:#f92672">==</span> ns[i <span style="color:#f92672">+</span> p[i]])
            p[i]<span style="color:#f92672">++</span>;
        <span style="color:#66d9ef">if</span> (mx <span style="color:#f92672">&lt;</span> i <span style="color:#f92672">+</span> p[i]) {
            idx <span style="color:#f92672">=</span> i;
            mx <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> p[i];
        }
        max_len <span style="color:#f92672">=</span> max(max_len, p[i] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
    }
    <span style="color:#66d9ef">return</span> max_len;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> s;
    <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> strlen(s);
    init(len);
    cout <span style="color:#f92672">&lt;&lt;</span> manacher(strlen(ns)) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>二分</title>
            <link>https://fffzlfk.gitlab.io/2020/06/23//</link>
            <pubDate>Tue, 23 Jun 2020 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2020/06/23//</guid>
            <description>P1024 一元三次方程求解【浮点数二分模版】 AC代码 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; double A, B, C, D; double check(double x) { return A * pow(x, 3) + B * pow(x, 2) + C * x + D; } void bs() { double l, r, mid; int cnt = 0; for (double i = -100.0; i &amp;lt;= 100.0; i++) { l = i, r = i + 1; double chl = check(l); double chr = check(r); if (chl == 0) { printf(&amp;#34;%.</description>
            <content type="html"><![CDATA[<h3 id="p1024-一元三次方程求解浮点数二分模版">P1024 一元三次方程求解【浮点数二分模版】</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码">AC代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">double</span> A, B, C, D;
<span style="color:#66d9ef">double</span> <span style="color:#a6e22e">check</span>(<span style="color:#66d9ef">double</span> x) { <span style="color:#66d9ef">return</span> A <span style="color:#f92672">*</span> pow(x, <span style="color:#ae81ff">3</span>) <span style="color:#f92672">+</span> B <span style="color:#f92672">*</span> pow(x, <span style="color:#ae81ff">2</span>) <span style="color:#f92672">+</span> C <span style="color:#f92672">*</span> x <span style="color:#f92672">+</span> D; }

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bs</span>() {
    <span style="color:#66d9ef">double</span> l, r, mid;
    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">double</span> i <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">100.0</span>; i <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">100.0</span>; i<span style="color:#f92672">++</span>) {
        l <span style="color:#f92672">=</span> i, r <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">double</span> chl <span style="color:#f92672">=</span> check(l);
        <span style="color:#66d9ef">double</span> chr <span style="color:#f92672">=</span> check(r);
        <span style="color:#66d9ef">if</span> (chl <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            printf(<span style="color:#e6db74">&#34;%.2lf &#34;</span>, l);
            cnt<span style="color:#f92672">++</span>;
        }
        <span style="color:#66d9ef">if</span> (chl <span style="color:#f92672">*</span> chr <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
            <span style="color:#66d9ef">while</span> (l <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.001</span> <span style="color:#f92672">&lt;=</span> r) {
                mid <span style="color:#f92672">=</span> (l <span style="color:#f92672">+</span> r) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
                <span style="color:#66d9ef">if</span> (check(mid) <span style="color:#f92672">*</span> check(r) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
                    l <span style="color:#f92672">=</span> mid;
                } <span style="color:#66d9ef">else</span> {
                    r <span style="color:#f92672">=</span> mid;
                }
            }
            printf(<span style="color:#e6db74">&#34;%.2lf &#34;</span>, l);
            cnt<span style="color:#f92672">++</span>;
        }
        <span style="color:#66d9ef">if</span> (cnt <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>) <span style="color:#66d9ef">break</span>;
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> A <span style="color:#f92672">&gt;&gt;</span> B <span style="color:#f92672">&gt;&gt;</span> C <span style="color:#f92672">&gt;&gt;</span> D;
    bs();
    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="p2678-跳石头二分模版">P2678 跳石头【二分模版】</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-1">AC代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> maxn <span style="color:#f92672">=</span> <span style="color:#ae81ff">50005</span>;
<span style="color:#66d9ef">int</span> d[maxn];
<span style="color:#66d9ef">int</span> n, l, m;

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">judge</span>(<span style="color:#66d9ef">int</span> step) {
    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> cur <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> next <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> (next <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) {
        next<span style="color:#f92672">++</span>;
        <span style="color:#66d9ef">if</span> (d[next] <span style="color:#f92672">-</span> d[cur] <span style="color:#f92672">&lt;</span> step) {
            cnt<span style="color:#f92672">++</span>;
        } <span style="color:#66d9ef">else</span> {
            cur <span style="color:#f92672">=</span> next;
        }
    }
    <span style="color:#66d9ef">return</span> cnt <span style="color:#f92672">&lt;=</span> m;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bs</span>(<span style="color:#66d9ef">int</span> _l, <span style="color:#66d9ef">int</span> r) {
    <span style="color:#66d9ef">int</span> mid, ans;
    <span style="color:#66d9ef">while</span> (_l <span style="color:#f92672">&lt;=</span> r) {
        mid <span style="color:#f92672">=</span> (_l <span style="color:#f92672">+</span> r) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">if</span> (judge(mid)) {
            ans <span style="color:#f92672">=</span> mid;
            _l <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        } <span style="color:#66d9ef">else</span> {
            r <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
        }
    }
    <span style="color:#66d9ef">return</span> ans;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> l <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
    <span style="color:#66d9ef">int</span> t;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> d[i];
    }
    d[n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> l;
    cout <span style="color:#f92672">&lt;&lt;</span> bs(<span style="color:#ae81ff">1</span>, l) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>归并排序、树状数组、线段树、RMQ、LRU(倍增)</title>
            <link>https://fffzlfk.gitlab.io/2020/06/22/%E9%B2%A2/</link>
            <pubDate>Mon, 22 Jun 2020 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2020/06/22/%E9%B2%A2/</guid>
            <description>P1908 逆序对 AC代码(归并排序) AC代码(树状数组) P3374 【模板】树状数组 1 AC代码 P3368 【模板】树状数组 2 AC代码 P3372 【模板】线段树 1 AC代码 P3865 【模板】ST表 AC代码 POJ3264 Balanced Lineup【RMQ模板】 AC代码 P1816 忠诚【RMQ】 AC代码 P3379 【模板】最近公共祖先（LCA） AC代码   </description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="p1908-逆序对">P1908 逆序对</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码归并排序">AC代码(归并排序)</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="ac代码树状数组">AC代码(树状数组)</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="p3374-模板树状数组-1">P3374 【模板】树状数组 1</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="p3368-模板树状数组-2">P3368 【模板】树状数组 2</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-1">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="p3372-模板线段树-1">P3372 【模板】线段树 1</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-2">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="p3865-模板st表">P3865 【模板】ST表</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-3">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="poj3264-balanced-lineuprmq模板">POJ3264 Balanced Lineup【RMQ模板】</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-4">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="p1816-忠诚rmq">P1816 忠诚【RMQ】</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-5">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="p3379-模板最近公共祖先lca">P3379 【模板】最近公共祖先（LCA）</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-6">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<blockquote>
</blockquote>
]]></content>
        </item>
        
        <item>
            <title>图论练习</title>
            <link>https://fffzlfk.gitlab.io/2020/06/21/%CD%BC%CF%B0/</link>
            <pubDate>Sun, 21 Jun 2020 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2020/06/21/%CD%BC%CF%B0/</guid>
            <description>UVA10129 单词 Play on Words（欧拉路径） AC代码 P3367 【模板】并查集 AC代码 P1551 亲戚-【模板】并查集 AC代码 P1111 修复公路 AC代码 P1195 口袋的天空 AC代码 P1196 [NOI2002]银河英雄传说-【模板】带权并查集 AC代码 P1536 村村通 AC代码 P3916 图的遍历 AC代码 P4779 【模板】单源最短路径（标准版） AC代码 POJ2186 Popular Cows AC代码 P3366 【模板】最小生成树 AC代码 POJ2421 Constructing Roads AC代码   </description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="uva10129-单词-play-on-words欧拉路径">UVA10129 单词 Play on Words（欧拉路径）</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="p3367-模板并查集">P3367 【模板】并查集</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-1">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="p1551-亲戚-模板并查集">P1551 亲戚-【模板】并查集</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-2">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="p1111-修复公路">P1111 修复公路</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-3">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="p1195-口袋的天空">P1195 口袋的天空</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-4">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="p1196-noi2002银河英雄传说-模板带权并查集">P1196 [NOI2002]银河英雄传说-【模板】带权并查集</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-5">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="p1536-村村通">P1536 村村通</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-6">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="p3916-图的遍历">P3916 图的遍历</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-7">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="p4779-模板单源最短路径标准版">P4779 【模板】单源最短路径（标准版）</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-8">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="poj2186-popular-cows">POJ2186 Popular Cows</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-9">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="p3366-模板最小生成树">P3366 【模板】最小生成树</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-10">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="poj2421-constructing-roads">POJ2421 Constructing Roads</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-11">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<blockquote>
</blockquote>
]]></content>
        </item>
        
        <item>
            <title>搜索练习</title>
            <link>https://fffzlfk.gitlab.io/2020/06/17/%CF%B0/</link>
            <pubDate>Wed, 17 Jun 2020 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2020/06/17/%CF%B0/</guid>
            <description>以下题目来自洛谷 P1379 八数码难题 AC代码 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; const int maxn = 4e5; typedef int state[9]; state st[maxn], goal; int dist[maxn]; const int dx[] = {0, 0, -1, 1}; const int dy[] = {-1, 1, 0, 0}; set&amp;amp;lt;int&amp;amp;gt; vis; bool try_insert(int s) { int res = 0; for (int i = 0; i &amp;lt; 9; i++) res = res * 10 + st[s][i]; if (vis.count(res)) return false; vis.insert(res); return true; } int bfs() { vis.</description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="以下题目来自洛谷">以下题目来自洛谷</h2>
<h3 id="p1379-八数码难题">P1379 八数码难题</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码">AC代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> maxn <span style="color:#f92672">=</span> <span style="color:#ae81ff">4e5</span>;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> state[<span style="color:#ae81ff">9</span>];
state st[maxn], goal;
<span style="color:#66d9ef">int</span> dist[maxn];

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dx[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>};
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> dy[] <span style="color:#f92672">=</span> {<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>};

set<span style="color:#f92672">&amp;</span>lt;<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span>gt; vis;

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">try_insert</span>(<span style="color:#66d9ef">int</span> s) {
    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">9</span>; i<span style="color:#f92672">++</span>) res <span style="color:#f92672">=</span> res <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">+</span> st[s][i];
    <span style="color:#66d9ef">if</span> (vis.count(res)) <span style="color:#66d9ef">return</span> false;
    vis.insert(res);
    <span style="color:#66d9ef">return</span> true;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bfs</span>() {
    vis.clear();
    <span style="color:#66d9ef">int</span> front <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, rear <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
    <span style="color:#66d9ef">while</span> (front <span style="color:#f92672">&lt;</span> rear) {
        state<span style="color:#f92672">&amp;</span> s <span style="color:#f92672">=</span> st[front];
        <span style="color:#66d9ef">if</span> (memcmp(goal, s, <span style="color:#66d9ef">sizeof</span>(s)) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> front;
        <span style="color:#66d9ef">int</span> z;
        <span style="color:#66d9ef">for</span> (z <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; z <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">9</span>; z<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>s[z]) <span style="color:#66d9ef">break</span>;
        <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> z <span style="color:#f92672">/</span> <span style="color:#ae81ff">3</span>, y <span style="color:#f92672">=</span> z <span style="color:#f92672">%</span> <span style="color:#ae81ff">3</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">int</span> nx <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> dx[i], ny <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> dy[i];
            <span style="color:#66d9ef">int</span> nz <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> nx <span style="color:#f92672">+</span> ny;
            <span style="color:#66d9ef">if</span> (nx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> nx <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">||</span> ny <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> ny <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">3</span>) <span style="color:#66d9ef">continue</span>;
            state<span style="color:#f92672">&amp;</span> t <span style="color:#f92672">=</span> st[rear];  <span style="color:#75715e">// 入队列
</span><span style="color:#75715e"></span>            memcpy(<span style="color:#f92672">&amp;</span>t, <span style="color:#f92672">&amp;</span>s, <span style="color:#66d9ef">sizeof</span>(s));
            t[nz] <span style="color:#f92672">=</span> s[z];
            t[z] <span style="color:#f92672">=</span> s[nz];
            dist[rear] <span style="color:#f92672">=</span> dist[front] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">if</span> (try_insert(rear)) rear<span style="color:#f92672">++</span>;
        }
        front<span style="color:#f92672">++</span>;  <span style="color:#75715e">//扩展完毕后出队列
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">9</span>; i<span style="color:#f92672">++</span>) st[<span style="color:#ae81ff">1</span>][i] <span style="color:#f92672">=</span> getchar() <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>;
    <span style="color:#66d9ef">int</span> tmp[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">5</span>};
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">9</span>; i<span style="color:#f92672">++</span>) goal[i] <span style="color:#f92672">=</span> tmp[i];
    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> bfs();
    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dist[ans]);
    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="马的遍历">马的遍历</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-1">AC代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {
    <span style="color:#66d9ef">int</span> x;
    <span style="color:#66d9ef">int</span> y;
    node(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) {
        x <span style="color:#f92672">=</span> a;
        y <span style="color:#f92672">=</span> b;
    }
};

<span style="color:#66d9ef">int</span> dx[] <span style="color:#f92672">=</span> {<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>};
<span style="color:#66d9ef">int</span> dy[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>};

<span style="color:#66d9ef">int</span> n, m;
<span style="color:#66d9ef">bool</span> visit[<span style="color:#ae81ff">405</span>][<span style="color:#ae81ff">405</span>];
<span style="color:#66d9ef">int</span> moves[<span style="color:#ae81ff">405</span>][<span style="color:#ae81ff">405</span>];

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bfs</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y, <span style="color:#66d9ef">int</span> step) {
    queue<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">&gt;</span> Q;
    Q.push(node(x, y));
    visit[x][y] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    moves[x][y] <span style="color:#f92672">=</span> step;
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>Q.empty()) {
        node t <span style="color:#f92672">=</span> Q.front();
        Q.pop();
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">int</span> nx <span style="color:#f92672">=</span> t.x <span style="color:#f92672">+</span> dx[i];
            <span style="color:#66d9ef">if</span> (nx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> nx <span style="color:#f92672">&gt;</span> n) <span style="color:#66d9ef">continue</span>;
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; j<span style="color:#f92672">++</span>) {
                <span style="color:#66d9ef">if</span> (abs(dx[i]) <span style="color:#f92672">==</span> abs(dy[j])) <span style="color:#66d9ef">continue</span>;
                <span style="color:#66d9ef">int</span> ny <span style="color:#f92672">=</span> t.y <span style="color:#f92672">+</span> dy[j];
                <span style="color:#66d9ef">if</span> (ny <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> ny <span style="color:#f92672">&lt;=</span> m <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>visit[nx][ny]) {
                    Q.push(node(nx, ny));
                    visit[nx][ny] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
                    moves[nx][ny] <span style="color:#f92672">=</span> moves[t.x][t.y] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
                }
            }
        }
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> x, y;
    scanf(<span style="color:#e6db74">&#34;%d%d%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m, <span style="color:#f92672">&amp;</span>x, <span style="color:#f92672">&amp;</span>y);
    memset(moves, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">sizeof</span>(moves));
    bfs(x, y, <span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> m; j<span style="color:#f92672">++</span>) { printf(<span style="color:#e6db74">&#34;%-5d&#34;</span>, moves[i][j]); }
        printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="填涂颜色">填涂颜色</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-2">AC代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> dx[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>};
<span style="color:#66d9ef">int</span> dy[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};

<span style="color:#66d9ef">int</span> n;
<span style="color:#66d9ef">int</span> M[<span style="color:#ae81ff">35</span>][<span style="color:#ae81ff">35</span>];
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
    M[x][y] <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">int</span> nx <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> dx[i];
        <span style="color:#66d9ef">if</span> (nx <span style="color:#f92672">&gt;</span> n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> nx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
        <span style="color:#66d9ef">int</span> ny <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> dy[i];
        <span style="color:#66d9ef">if</span> (ny <span style="color:#f92672">&gt;</span> n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> ny <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>M[nx][ny]) dfs(nx, ny);
    }
    <span style="color:#66d9ef">return</span>;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
    memset(M, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(M));
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>) scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>M[i][j]);
    }
    dfs(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">if</span> (M[i][j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>)
                printf(<span style="color:#e6db74">&#34;0 &#34;</span>);
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (M[i][j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
                printf(<span style="color:#e6db74">&#34;2 &#34;</span>);
            <span style="color:#66d9ef">else</span>
                printf(<span style="color:#e6db74">&#34;%d &#34;</span>, M[i][j]);
        }
        printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="迷宫">迷宫</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-3">AC代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> dx[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>};
<span style="color:#66d9ef">int</span> dy[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};

<span style="color:#66d9ef">int</span> n, m, t;
<span style="color:#66d9ef">int</span> x11, y11;
<span style="color:#66d9ef">int</span> x22, y22;
<span style="color:#66d9ef">int</span> M[<span style="color:#ae81ff">7</span>][<span style="color:#ae81ff">7</span>];
<span style="color:#66d9ef">bool</span> visit[<span style="color:#ae81ff">7</span>][<span style="color:#ae81ff">7</span>];
<span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
    visit[x][y] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">==</span> x22 <span style="color:#f92672">&amp;&amp;</span> y <span style="color:#f92672">==</span> y22) cnt<span style="color:#f92672">++</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">int</span> nx <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> dx[i];
        <span style="color:#66d9ef">int</span> ny <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> dy[i];
        <span style="color:#66d9ef">if</span> (nx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> nx <span style="color:#f92672">&gt;</span> n <span style="color:#f92672">||</span> ny <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> ny <span style="color:#f92672">&gt;</span> m) <span style="color:#66d9ef">continue</span>;
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>M[nx][ny] <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>visit[nx][ny]) { dfs(nx, ny); }
    }
    visit[x][y] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">return</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74">&#34;%d%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m, <span style="color:#f92672">&amp;</span>t);
    scanf(<span style="color:#e6db74">&#34;%d%d%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>x11, <span style="color:#f92672">&amp;</span>y11, <span style="color:#f92672">&amp;</span>x22, <span style="color:#f92672">&amp;</span>y22);
    <span style="color:#66d9ef">int</span> xx, yy;
    <span style="color:#66d9ef">while</span> (t<span style="color:#f92672">--</span>) {
        scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>xx, <span style="color:#f92672">&amp;</span>yy);
        M[xx][yy]<span style="color:#f92672">++</span>;
    }
    dfs(x11, y11);
    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, cnt);
}
</code></pre></div><h3 id="数的划分">数的划分</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-4">AC代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;set&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#define in(n) scanf(&#34;%d&#34;, &amp;n)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">func</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> k) {
    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;</span> k) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> k <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> n <span style="color:#f92672">==</span> k) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">return</span> func(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> func(n <span style="color:#f92672">-</span> k, k);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> n, k;
    in(n);
    in(k);
    cout <span style="color:#f92672">&lt;&lt;</span> func(n, k) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="奇怪的电梯">奇怪的电梯</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-5">AC代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;set&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#define in(n) scanf(&#34;%d&#34;, &amp;n)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> n;
<span style="color:#66d9ef">int</span> M[<span style="color:#ae81ff">205</span>];
<span style="color:#66d9ef">int</span> a, b;
<span style="color:#66d9ef">int</span> visit[<span style="color:#ae81ff">205</span>];
<span style="color:#66d9ef">int</span> step[<span style="color:#ae81ff">205</span>];
<span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x3f3f3f3f</span>;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bfs</span>(<span style="color:#66d9ef">int</span> x) {
    <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">==</span> b) {
        ans <span style="color:#f92672">=</span> step[x];
    }
    queue<span style="color:#f92672">&amp;</span>lt;<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span>gt; Q;
    Q.push(x);
    visit[x] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>Q.empty()) {
        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> Q.front();
        Q.pop();
        <span style="color:#66d9ef">if</span> (t <span style="color:#f92672">==</span> b) {
            ans <span style="color:#f92672">=</span> step[t];
        }
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>; i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">int</span> d <span style="color:#f92672">=</span> t <span style="color:#f92672">+</span> (i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">?</span> M[t] <span style="color:#f92672">:</span> <span style="color:#f92672">-</span>M[t]);
            <span style="color:#66d9ef">if</span> (d <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> d <span style="color:#f92672">&gt;</span> n) <span style="color:#66d9ef">continue</span>;
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visit[d]) {
                Q.push(d);
                visit[d] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
                step[d] <span style="color:#f92672">=</span> step[t] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            }
        }
    }
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74">&#34;%d%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>a, <span style="color:#f92672">&amp;</span>b);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>M[i]);
    bfs(a);
    <span style="color:#66d9ef">if</span> (ans <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x3f3f3f3f</span>) ans <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> ans <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="poj3984-迷宫问题">POJ3984 迷宫问题</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-6">AC代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {
    <span style="color:#66d9ef">int</span> x;
    <span style="color:#66d9ef">int</span> y;
    node(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) {
        x <span style="color:#f92672">=</span> a;
        y <span style="color:#f92672">=</span> b;
    }
};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">path</span> {
    <span style="color:#66d9ef">int</span> x, y;
};

<span style="color:#66d9ef">int</span> dx[] <span style="color:#f92672">=</span> {<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>};
<span style="color:#66d9ef">int</span> dy[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>};

<span style="color:#66d9ef">int</span> n, m;
<span style="color:#66d9ef">bool</span> visit[<span style="color:#ae81ff">7</span>][<span style="color:#ae81ff">7</span>];
<span style="color:#66d9ef">int</span> M[<span style="color:#ae81ff">7</span>][<span style="color:#ae81ff">7</span>];
path pre[<span style="color:#ae81ff">10</span>][<span style="color:#ae81ff">10</span>];

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bfs</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
    queue<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">&gt;</span> Q;
    Q.push(node(x, y));
    visit[x][y] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>Q.empty()) {
        node t <span style="color:#f92672">=</span> Q.front();
        Q.pop();
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">int</span> nx <span style="color:#f92672">=</span> t.x <span style="color:#f92672">+</span> dx[i];
            <span style="color:#66d9ef">int</span> ny <span style="color:#f92672">=</span> t.y <span style="color:#f92672">+</span> dy[i];
            <span style="color:#66d9ef">if</span> (nx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> nx <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">||</span> M[nx][ny] <span style="color:#f92672">||</span> ny <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> ny <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">||</span>
                visit[nx][ny]) {
                <span style="color:#66d9ef">continue</span>;
            }
            Q.push(node(nx, ny));
            visit[nx][ny] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            path p;
            p.x <span style="color:#f92672">=</span> t.x;
            p.y <span style="color:#f92672">=</span> t.y;
            pre[nx][ny] <span style="color:#f92672">=</span> p;
            <span style="color:#66d9ef">if</span> (nx <span style="color:#f92672">==</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">&amp;&amp;</span> ny <span style="color:#f92672">==</span> <span style="color:#ae81ff">5</span>) <span style="color:#66d9ef">return</span>;
        }
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> x, y;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">5</span>; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">5</span>; j<span style="color:#f92672">++</span>) scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>M[i][j]);
    }
    bfs(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>);
    stack<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">&gt;</span> S;
    <span style="color:#66d9ef">int</span> n_x <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>, n_y <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
        S.push(node(n_x <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, n_y <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
        <span style="color:#66d9ef">if</span> (n_x <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> n_y <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">break</span>;
        <span style="color:#66d9ef">int</span> _x <span style="color:#f92672">=</span> pre[n_x][n_y].x;
        <span style="color:#66d9ef">int</span> _y <span style="color:#f92672">=</span> pre[n_x][n_y].y;
        n_x <span style="color:#f92672">=</span> _x;
        n_y <span style="color:#f92672">=</span> _y;
    }
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>S.empty()) {
        printf(<span style="color:#e6db74">&#34;(%d, %d)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, S.top().x, S.top().y);
        S.pop();
    }
    <span style="color:#75715e">// system(&#34;pause&#34;);
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="poj2676-sudoku">POJ2676 Sudoku</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-7">AC代码</h4>
<pre><code class="language-cppcpp" data-lang="cppcpp">#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int arc[10][10];

bool judge(int r, int c, int n) {
    for (int i = 0; i &lt; 9; i++)
        if (arc[r][i] == n || arc[i][c] == n) return false;
    int _r = (r / 3) * 3;
    int _c = (c / 3) * 3;
    for (int i = _r; i &lt; _r + 3; i++) {
        for (int j = _c; j &lt; _c + 3; j++) {
            if (arc[i][j] == n) return false;
        }
    }
    return true;
}

vector&lt;pair&lt;int, int&gt; &gt; zero;

bool dfs(int idx) {
    if (idx &gt;= (int)zero.size()) return true;
    int r = zero[idx].first;
    int c = zero[idx].second;
    for (int i = 1; i &lt;= 9; i++) {
        if (judge(r, c, i)) {
            arc[r][c] = i;
            if (dfs(idx + 1)) return true;
            arc[r][c] = 0;  // 回溯
        }
    }
    return false;
}

int main() {
    int T;
    cin &gt;&gt; T;
    getchar();
    while (T--) {
        for (int i = 0; i &lt; 9; i++) {
            for (int j = 0; j &lt; 9; j++) {
                arc[i][j] = getchar() - '0';
                if (arc[i][j] == 0) zero.push_back(make_pair(i, j));
            }
            getchar();
        }
        dfs(0);
        for (int i = 0; i &lt; 9; i++) {
            for (int j = 0; j &lt; 9; j++) {
                printf(&quot;%d&quot;, arc[i][j]);
            }
            printf(&quot;\n&quot;);
        }
        zero.clear();
    }
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><h3 id="uva10603-倒水问题-fill">UVA10603 倒水问题 Fill</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-8">AC代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> maxn <span style="color:#f92672">=</span> <span style="color:#ae81ff">205</span>;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {
    <span style="color:#66d9ef">int</span> v[<span style="color:#ae81ff">3</span>], dist;
    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;</span>(node a, node b) { <span style="color:#66d9ef">return</span> a.dist <span style="color:#f92672">&gt;</span> b.dist; }
};

<span style="color:#66d9ef">bool</span> vis[maxn][maxn];
<span style="color:#66d9ef">int</span> cap[<span style="color:#ae81ff">3</span>], ans[maxn];

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update_ans</span>(<span style="color:#66d9ef">const</span> node<span style="color:#f92672">&amp;</span> u) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">int</span> d <span style="color:#f92672">=</span> u.v[i];
        <span style="color:#66d9ef">if</span> (ans[d] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> u.dist <span style="color:#f92672">&lt;</span> ans[d]) ans[d] <span style="color:#f92672">=</span> u.dist;
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b, <span style="color:#66d9ef">int</span> c, <span style="color:#66d9ef">int</span> d) {
    cap[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> a, cap[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> b, cap[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> c;
    memset(vis, false, <span style="color:#66d9ef">sizeof</span>(vis));
    memset(ans, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">sizeof</span>(ans));
    priority_queue<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">&gt;</span> Q;
    node start;
    start.dist <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    start.v[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, start.v[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, start.v[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> c;
    Q.push(start);
    vis[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> true;
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>Q.empty()) {
        node t <span style="color:#f92672">=</span> Q.top();
        Q.pop();
        update_ans(t);
        <span style="color:#66d9ef">if</span> (ans[d] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; j<span style="color:#f92672">++</span>) {
                <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> j) {
                    <span style="color:#66d9ef">if</span> (t.v[i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> t.v[i] <span style="color:#f92672">==</span> cap[j]) <span style="color:#66d9ef">continue</span>;
                    <span style="color:#66d9ef">int</span> amount <span style="color:#f92672">=</span> min(cap[j], t.v[i] <span style="color:#f92672">+</span> t.v[j]) <span style="color:#f92672">-</span> t.v[j];
                    node u2;
                    memcpy(<span style="color:#f92672">&amp;</span>u2, <span style="color:#f92672">&amp;</span>t, <span style="color:#66d9ef">sizeof</span>(t));
                    u2.dist <span style="color:#f92672">=</span> t.dist <span style="color:#f92672">+</span> amount;
                    u2.v[i] <span style="color:#f92672">-=</span> amount;
                    u2.v[j] <span style="color:#f92672">+=</span> amount;
                    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[u2.v[<span style="color:#ae81ff">0</span>]][u2.v[<span style="color:#ae81ff">1</span>]]) {
                        vis[u2.v[<span style="color:#ae81ff">0</span>]][u2.v[<span style="color:#ae81ff">1</span>]] <span style="color:#f92672">=</span> true;
                        Q.push(u2);
                    }
                }
            }
        }
    }
    <span style="color:#66d9ef">while</span> (d <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#66d9ef">if</span> (ans[d] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) {
            printf(<span style="color:#e6db74">&#34;%d %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ans[d], d);
            <span style="color:#66d9ef">return</span>;
        }
        d<span style="color:#f92672">--</span>;
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio();
    <span style="color:#66d9ef">int</span> T, a, b, c, d;
    cin <span style="color:#f92672">&gt;&gt;</span> T;
    <span style="color:#66d9ef">while</span> (T<span style="color:#f92672">--</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b <span style="color:#f92672">&gt;&gt;</span> c <span style="color:#f92672">&gt;&gt;</span> d;
        solve(a, b, c, d);
    }
    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>数论练习</title>
            <link>https://fffzlfk.gitlab.io/2020/06/17/%CF%B0/</link>
            <pubDate>Wed, 17 Jun 2020 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2020/06/17/%CF%B0/</guid>
            <description>以下题目来自洛谷 P3390 【模板】矩阵快速幂 AC代码 P3383 【模板】线性筛素数    10 100 1000 10000 100000 1000000 10000000 100000000     4 29 197 1426 11018 89516 754095 6515550    AC代码 CF822A I&amp;rsquo;m bored with life AC代码 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; // using ll = long long; // 不打表也能过 int get_mul[] = {1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600}; int main() { int a, b; scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;a, &amp;amp;b); printf(&amp;#34;%d\n&amp;#34;, get_mul[min(a, b) - 1]); // for (int i = 1; i &amp;lt; 13; i++) printf(&amp;#34;%d, &amp;#34;, get(i));  // system(&amp;#34;pause&amp;#34;);  return 0; } 素数个数（线性筛模版） AC代码 #include &amp;lt;bits/stdc++.</description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="以下题目来自洛谷">以下题目来自洛谷</h2>
<h3 id="p3390-模板矩阵快速幂">P3390 【模板】矩阵快速幂</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="p3383-模板线性筛素数">P3383 【模板】线性筛素数</h3>
<!-- raw HTML omitted -->
<table>
<thead>
<tr>
<th>10</th>
<th>100</th>
<th>1000</th>
<th>10000</th>
<th>100000</th>
<th>1000000</th>
<th>10000000</th>
<th>100000000</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>29</td>
<td>197</td>
<td>1426</td>
<td>11018</td>
<td>89516</td>
<td>754095</td>
<td>6515550</td>
</tr>
</tbody>
</table>
<h4 id="ac代码-1">AC代码</h4>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="cf822a-im-bored-with-life">CF822A I&rsquo;m bored with life</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-2">AC代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">// using ll = long long;
</span><span style="color:#75715e">// 不打表也能过
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> get_mul[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>,    <span style="color:#ae81ff">2</span>,     <span style="color:#ae81ff">6</span>,      <span style="color:#ae81ff">24</span>,      <span style="color:#ae81ff">120</span>,      <span style="color:#ae81ff">720</span>,
                 <span style="color:#ae81ff">5040</span>, <span style="color:#ae81ff">40320</span>, <span style="color:#ae81ff">362880</span>, <span style="color:#ae81ff">3628800</span>, <span style="color:#ae81ff">39916800</span>, <span style="color:#ae81ff">479001600</span>};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> a, b;
    scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>a, <span style="color:#f92672">&amp;</span>b);
    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, get_mul[min(a, b) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]);
    <span style="color:#75715e">// for (int i = 1; i &lt; 13; i++) printf(&#34;%d, &#34;, get(i));
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// system(&#34;pause&#34;);
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="素数个数线性筛模版">素数个数（线性筛模版）</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-3">AC代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">bool</span> ok[<span style="color:#ae81ff">100000005</span>];
<span style="color:#66d9ef">int</span> prime[<span style="color:#ae81ff">5800000</span>];
<span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> n;
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ok[i]) {
            prime[idx<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> i;
        }
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;=</span> idx <span style="color:#f92672">&amp;&amp;</span> prime[j] <span style="color:#f92672">*</span> i <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>) {
            ok[prime[j] <span style="color:#f92672">*</span> i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">%</span> prime[j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
        }
    }
    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, idx);
    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="p1029-最大公约数和最小公倍数问题">P1029 最大公约数和最小公倍数问题</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-4">AC代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">#define ll long long
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    ll x, y;
    scanf(<span style="color:#e6db74">&#34;%lld%lld&#34;</span>, <span style="color:#f92672">&amp;</span>x, <span style="color:#f92672">&amp;</span>y);
    ll s <span style="color:#f92672">=</span> x <span style="color:#f92672">*</span> y;
    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (ll i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">*</span> i <span style="color:#f92672">&lt;=</span> s; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (s <span style="color:#f92672">%</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> __gcd(i, s <span style="color:#f92672">/</span> i) <span style="color:#f92672">==</span> x) {
            <span style="color:#75715e">// printf(&#34;%d %d\n&#34;, i, s / i);
</span><span style="color:#75715e"></span>            cnt <span style="color:#f92672">+=</span> s <span style="color:#f92672">/</span> i <span style="color:#f92672">==</span> i <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>;
        }
    }
    cout <span style="color:#f92672">&lt;&lt;</span> cnt <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="codeforces-round-613-div-2c-fadi-and-lcm">Codeforces Round #613 (Div. 2)C. Fadi and LCM</h3>
<!-- raw HTML omitted -->
<h4 id="ac代码-5">AC代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">using</span> ll <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// freopen(&#34;D:\\CPP_test\\Summer\\duipai\\in.txt&#34;, &#34;r&#34;, stdin);
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// freopen(&#34;data1.out&#34;, &#34;w&#34;, stdout);
</span><span style="color:#75715e"></span>    ll x;
    scanf(<span style="color:#e6db74">&#34;%lld&#34;</span>, <span style="color:#f92672">&amp;</span>x);
    ll a <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x3f3f3f3f3f3fll</span>, b <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x3f3f3f3f3f3fll</span>;
    <span style="color:#66d9ef">for</span> (ll i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">*</span> i <span style="color:#f92672">&lt;=</span> x; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">%</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> __gcd(i, x <span style="color:#f92672">/</span> i) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> max(a, b) <span style="color:#f92672">&gt;</span> max(i, x <span style="color:#f92672">/</span> i)) {
            a <span style="color:#f92672">=</span> i;
            b <span style="color:#f92672">=</span> x <span style="color:#f92672">/</span> i;
        }
    }
    printf(<span style="color:#e6db74">&#34;%lld %lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, a, b);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>CF#640(div4)</title>
            <link>https://fffzlfk.gitlab.io/2020/06/15/cf#640div4/</link>
            <pubDate>Mon, 15 Jun 2020 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2020/06/15/cf#640div4/</guid>
            <description>Problem A For example, the following numbers are round: $$ 4000, 1, 9, 800, 90. $$ The following numbers are not round: $$ 110, 707, 222, 1001. $$
You are given a positive integer n ($$1≤n≤10^4$$). Represent the number n as a sum of round numbers using the minimum number of summands (addends). In other words, you need to represent the given number n as a sum of the least number of terms, each of which is a round number.</description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<h2 id="problem-a">Problem A</h2>
<!-- raw HTML omitted -->
<p>For example, the following numbers are round: $$ 4000, 1, 9, 800, 90. $$ The following numbers are not round: $$ 110, 707, 222, 1001. $$</p>
<p>You are given a positive integer n ($$1≤n≤10^4$$). Represent the number n as a sum of round numbers using the minimum number of summands (addends). In other words, you need to represent the given number n as a sum of the least number of terms, each of which is a round number.</p>
<h3 id="input">Input</h3>
<p>The first line contains an integer $$ t (1≤t≤10^4)$$ — the number of test cases in the input. Then t test cases follow.</p>
<p>Each test case is a line containing an integer$$ n (1≤n≤10^4).$$</p>
<h3 id="output">Output</h3>
<p>Print t answers to the test cases. Each answer must begin with an integer k — the minimum number of summands. Next, k terms must follow, each of which is a round number, and their sum is n. The terms can be printed in any order. If there are several answers, print any of them.</p>
<h3 id="example">Example</h3>
<h4 id="input-1">input</h4>
<pre><code>5
5009
7
9876
10000
10
</code></pre><h4 id="output-1">output</h4>
<pre><code>2
5000 9
1
7
4
800 70 6 9000
1
10000
1
10
</code></pre><h3 id="ac代码">AC代码</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> T;
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>T);
    <span style="color:#66d9ef">int</span> n;
    <span style="color:#66d9ef">while</span> (T<span style="color:#f92672">--</span>) {
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v;
        <span style="color:#66d9ef">while</span> (n) {
            <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> n <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
            <span style="color:#66d9ef">if</span> (tmp) v.push_back(tmp <span style="color:#f92672">*</span> pow(<span style="color:#ae81ff">10</span>, i));
            n <span style="color:#f92672">/=</span> <span style="color:#ae81ff">10</span>;
            i<span style="color:#f92672">++</span>;
        }
        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">int</span>) v.size());
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">int</span>) v.size(); i<span style="color:#f92672">++</span>)
            printf(i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;%d&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34; %d&#34;</span>, v[i]);
        puts(<span style="color:#e6db74">&#34;&#34;</span>);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="problem-b">Problem B</h2>
<!-- raw HTML omitted -->
<p>In other words, find $$a_1,a_2,…,a_k such that all a_i&gt;0, n=a_1+a_2+…+a_k$$ and either all $$a_i$$ are even or all $$a_i$$ are odd at the same time.</p>
<p>If such a representation does not exist, then report it.</p>
<h3 id="input-2">Input</h3>
<p>The first line contains an integer t ($$1≤t≤1000$$) — the number of test cases in the input. Next, t test cases are given, one per line.</p>
<p>Each test case is two positive integers$$ n (1≤n≤10^9)$$ and$$ k (1≤k≤100).$$</p>
<h3 id="output-2">Output</h3>
<p>For each test case print:</p>
<ul>
<li>YES and the required values $$a_i$$, if the answer exists (if there are several answers, print any of them);</li>
<li>NO if the answer does not exist.
The letters in the words YES and NO can be printed in any case.</li>
</ul>
<h3 id="example-1">Example</h3>
<h4 id="input-3">input</h4>
<pre><code>8
10 3
100 4
8 7
97 2
8 8
3 10
5 3
1000000000 9
</code></pre><h4 id="output-3">output</h4>
<pre><code>YES
4 2 4
YES
55 5 5 35
NO
NO
YES
1 1 1 1 1 1 1 1
NO
YES
3 1 1
YES
111111110 111111110 111111110 111111110 111111110 111111110 111111110 111111110 111111120
</code></pre><h3 id="ac代码-1">AC代码</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">#define in(n) scanf(&#34;%d&#34;, &amp;n)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> T;
    in(T);
    <span style="color:#66d9ef">int</span> n, k;
    <span style="color:#66d9ef">while</span> (T<span style="color:#f92672">--</span>) {
        in(n);
        in(k);
        <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;</span> k) {
            puts(<span style="color:#e6db74">&#34;NO&#34;</span>);
            <span style="color:#66d9ef">continue</span>;
        }
        <span style="color:#66d9ef">int</span> div <span style="color:#f92672">=</span> n <span style="color:#f92672">/</span> k;
        <span style="color:#66d9ef">int</span> rmd <span style="color:#f92672">=</span> n <span style="color:#f92672">%</span> k;
        <span style="color:#66d9ef">if</span> (rmd <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            puts(<span style="color:#e6db74">&#34;YES&#34;</span>);
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) { printf(<span style="color:#e6db74">&#34;%d &#34;</span>, div); }
            printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, div <span style="color:#f92672">+</span> rmd);
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">if</span> (div <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> (div <span style="color:#f92672">+</span> rmd) <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
                puts(<span style="color:#e6db74">&#34;YES&#34;</span>);
                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) printf(<span style="color:#e6db74">&#34;%d &#34;</span>, div);
                printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, div <span style="color:#f92672">+</span> rmd);
            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (div <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> (rmd <span style="color:#f92672">+</span> div) <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>) {
                puts(<span style="color:#e6db74">&#34;YES&#34;</span>);
                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) printf(<span style="color:#e6db74">&#34;%d &#34;</span>, div);
                printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, div <span style="color:#f92672">+</span> rmd);
            } <span style="color:#66d9ef">else</span> {
                <span style="color:#66d9ef">if</span> (k <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
                    puts(<span style="color:#e6db74">&#34;NO&#34;</span>);
                } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (div <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
                    puts(<span style="color:#e6db74">&#34;NO&#34;</span>);
                } <span style="color:#66d9ef">else</span> {
                    puts(<span style="color:#e6db74">&#34;YES&#34;</span>);
                    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> k <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>; i<span style="color:#f92672">++</span>) {
                        printf(<span style="color:#e6db74">&#34;%d %d &#34;</span>, div <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, div <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
                    }
                    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, div <span style="color:#f92672">+</span> rmd);
                }
            }
        }
    }
}
</code></pre></div><h2 id="problem-c">Problem C</h2>
<!-- raw HTML omitted -->
<p>For example, if $$ n=3,$$ and$$ k=7,$$ then all numbers that are not divisible by 3 are:$$ 1,2,4,5,7,8,10,11,13…. $$The 7-th number among them is 10.</p>
<h3 id="input-4">Input</h3>
<p>The first line contains an integer$$ t (1≤t≤1000)$$ — the number of test cases in the input. Next, t test cases are given, one per line.</p>
<p>Each test case is two positive integers $$n (2≤n≤10^9)$$ and $$k (1≤k≤10^9).$$</p>
<h3 id="output-4">Output</h3>
<p>For each test case print the k-th positive integer that is not divisible by n.</p>
<h3 id="example-2">Example</h3>
<h4 id="input-5">input</h4>
<pre><code>6
3 7
4 12
2 1000000000
7 97
1000000000 1000000000
2 1
</code></pre><h4 id="output-5">output</h4>
<pre><code>10
15
1999999999
113
1000000001
1
</code></pre><h3 id="ac代码-2">AC代码</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">#define in(n) scanf(&#34;%d&#34;, &amp;n)
</span><span style="color:#75715e">#define ll long long
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> T;
    in(T);
    <span style="color:#66d9ef">while</span> (T<span style="color:#f92672">--</span>) {
        ll n, k;
        scanf(<span style="color:#e6db74">&#34;%lld %lld&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>k);
        ll t <span style="color:#f92672">=</span> n <span style="color:#f92672">*</span> k <span style="color:#f92672">/</span> (n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
        ll r <span style="color:#f92672">=</span> t <span style="color:#f92672">%</span> n;
        <span style="color:#66d9ef">if</span> (r <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) t<span style="color:#f92672">--</span>;
        printf(<span style="color:#e6db74">&#34;%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, t);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="problem-d">Problem D</h2>
<!-- raw HTML omitted -->
<p>Alice and Bob play an interesting and tasty game: they eat candy. Alice will eat candy from left to right, and Bob — from right to left. The game ends if all the candies are eaten.</p>
<p>The process consists of moves. During a move, the player eats one or more sweets from her/his side (Alice eats from the left, Bob — from the right).</p>
<p>Alice makes the first move. During the first move, she will eat 1 candy (its size is a1). Then, each successive move the players alternate — that is, Bob makes the second move, then Alice, then again Bob and so on.</p>
<p>On each move, a player counts the total size of candies eaten during the current move. Once this number becomes strictly greater than the total size of candies eaten by the other player on their previous move, the current player stops eating and the move ends. In other words, on a move, a player eats the smallest possible number of candies such that the sum of the sizes of candies eaten on this move is strictly greater than the sum of the sizes of candies that the other player ate on the previous move. If there are not enough candies to make a move this way, then the player eats up all the remaining candies and the game ends.</p>
<p>For example, if$$ n=11$$ and $$a=[3,1,4,1,5,9,2,6,5,3,5],$$ then:</p>
<p>move 1: Alice eats one candy of size 3 and the sequence of candies becomes $$[1,4,1,5,9,2,6,5,3,5].$$
move 2: Alice ate 3 on the previous move, which means Bob must eat 4 or more. Bob eats one candy of size 5 and the sequence of candies becomes $$[1,4,1,5,9,2,6,5,3].$$
move 3: Bob ate 5 on the previous move, which means Alice must eat 6 or more. Alice eats three candies with the total size of 1+4+1=6 and the sequence of candies becomes $$ [5,9,2,6,5,3].$$
move 4: Alice ate 6 on the previous move, which means Bob must eat 7 or more. Bob eats two candies with the total size of 3+5=8 and the sequence of candies becomes $$ [5,9,2,6].$$
move 5: Bob ate 8 on the previous move, which means Alice must eat 9 or more. Alice eats two candies with the total size of 5+9=14 and the sequence of candies becomes $$[2,6].$$
move 6 (the last): Alice ate 14 on the previous move, which means Bob must eat 15 or more. It is impossible, so Bob eats the two remaining candies and the game ends.
Print the number of moves in the game and two numbers:</p>
<p>a — the total size of all sweets eaten by Alice during the game;
b — the total size of all sweets eaten by Bob during the game.</p>
<h3 id="input-6">Input</h3>
<p>The first line contains an integer t (1≤t≤5000) — the number of test cases in the input. The following are descriptions of the t test cases.</p>
<p>Each test case consists of two lines. The first line contains an integer$$ n (1≤n≤1000)$$ — the number of candies. The second line contains a sequence of integers $$ a_1,a_2,…,a_n (1≤a_i≤1000) $$ — the sizes of candies in the order they are arranged from left to right.</p>
<p>It is guaranteed that the sum of the values of n for all sets of input data in a test does not exceed $$ 2*10^5 $$.</p>
<h3 id="output-6">Output</h3>
<p>For each set of input data print three integers — the number of moves in the game and the required values a and b.</p>
<h3 id="example-3">Example</h3>
<h4 id="input-7">input</h4>
<pre><code>7
11
3 1 4 1 5 9 2 6 5 3 5
1
1000
3
1 1 1
13
1 2 3 4 5 6 7 8 9 10 11 12 13
2
2 1
6
1 1 1 1 1 1
7
1 1 1 1 1 1 1
</code></pre><h4 id="output-7">output</h4>
<pre><code>6 23 21
1 1000 0
2 1 2
6 45 46
2 2 1
3 4 2
4 4 3
</code></pre><h3 id="ac代码-3">AC代码</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;tuple&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">#define in(n) scanf(&#34;%d&#34;, &amp;n)
</span><span style="color:#75715e">#define ll long long
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> A[<span style="color:#ae81ff">1005</span>];

tuple<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> solve(<span style="color:#66d9ef">int</span> n) {
    <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">int</span> moves <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, b <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> last <span style="color:#f92672">=</span> A[left];
    <span style="color:#66d9ef">int</span> flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> (left <span style="color:#f92672">&lt;=</span> right) {
        <span style="color:#66d9ef">int</span> cur <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">if</span> (flag) {
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>cur) moves<span style="color:#f92672">++</span>;
            a <span style="color:#f92672">+=</span> A[left];
            left<span style="color:#f92672">++</span>;
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">while</span> (cur <span style="color:#f92672">&lt;=</span> last <span style="color:#f92672">&amp;&amp;</span> left <span style="color:#f92672">&lt;=</span> right) {
                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>cur) moves<span style="color:#f92672">++</span>;
                cur <span style="color:#f92672">+=</span> A[left];
                left<span style="color:#f92672">++</span>;
            }
            a <span style="color:#f92672">+=</span> cur;
            last <span style="color:#f92672">=</span> cur;
            cur <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        }

        flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">while</span> (cur <span style="color:#f92672">&lt;=</span> last <span style="color:#f92672">&amp;&amp;</span> left <span style="color:#f92672">&lt;=</span> right) {
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>cur) moves<span style="color:#f92672">++</span>;
            cur <span style="color:#f92672">+=</span> A[right];

            right<span style="color:#f92672">--</span>;
        }
        last <span style="color:#f92672">=</span> cur;
        b <span style="color:#f92672">+=</span> cur;
    }
    <span style="color:#66d9ef">return</span> {moves, a, b};
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> T, n;
    in(T);
    <span style="color:#66d9ef">while</span> (T<span style="color:#f92672">--</span>) {
        in(n);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) { in(A[i]); }
        <span style="color:#66d9ef">auto</span> [moves, a, b] <span style="color:#f92672">=</span> solve(n);
        printf(<span style="color:#e6db74">&#34;%d %d %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, moves, a, b);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="problem-e">Problem E</h2>
<!-- raw HTML omitted -->
<p>In order to cut off efficient solutions from inefficient ones in this problem, the time limit is rather strict. Prefer to use compiled statically typed languages (e.g. C++). If you use Python, then submit solutions on PyPy. Try to write an efficient solution.</p>
<p>The array $$ a=[a_1,a_2,…,a_n] (1≤a_i≤n) $$is given. Its element ai is called special if there exists a pair of indices $$l$$ and $$ r (1≤l&lt;r≤n)$$ such that ai=al+al+1+…+ar. In other words, an element is called special if it can be represented as the sum of two or more consecutive elements of an array (no matter if they are special or not).</p>
<p>Print the number of special elements of the given array a.</p>
<p>For example, if$$ n=9 $$and$$ a=[3,1,4,1,5,9,2,6,5],$$ then the answer is 5:</p>
<p>a3=4 is a special element, since a3=4=a1+a2=3+1;
a5=5 is a special element, since a5=5=a2+a3=1+4;
a6=9 is a special element, since a6=9=a1+a2+a3+a4=3+1+4+1;
a8=6 is a special element, since a8=6=a2+a3+a4=1+4+1;
a9=5 is a special element, since a9=5=a2+a3=1+4.
Please note that some of the elements of the array a may be equal — if several elements are equal and special, then all of them should be counted in the answer.</p>
<h3 id="input-8">Input</h3>
<p>The first line contains an integer$$ t (1≤t≤1000)$$ — the number of test cases in the input. Then t test cases follow.</p>
<p>Each test case is given in two lines. The first line contains an integer$$ n (1≤n≤8000)$$ — the length of the array a. The second line contains integers $$ a_1,a_2,…,a_n (1≤a_i≤n). $$</p>
<p>It is guaranteed that the sum of the values of n for all test cases in the input does not exceed 8000.</p>
<h3 id="output-8">Output</h3>
<p>Print t numbers — the number of special elements for each of the given arrays.</p>
<h3 id="example-4">Example</h3>
<h4 id="input-9">input</h4>
<pre><code>5
9
3 1 4 1 5 9 2 6 5
3
1 1 2
5
1 1 1 1 1
8
8 7 6 5 4 3 2 1
1
1
</code></pre><h4 id="output-9">output</h4>
<pre><code>5
1
0
4
0
</code></pre><h3 id="ac代码-4">AC代码</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;map&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;tuple&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">#define in(n) scanf(&#34;%d&#34;, &amp;n)
</span><span style="color:#75715e">#define ll long long
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v;
<span style="color:#66d9ef">int</span> M[<span style="color:#ae81ff">8005</span>];
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> T, n, tmp;
    in(T);
    <span style="color:#66d9ef">while</span> (T<span style="color:#f92672">--</span>) {
        in(n);
        v.clear();
        memset(M, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(M));
        <span style="color:#66d9ef">int</span> Max <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
            in(tmp);
            v.push_back(tmp);
            Max <span style="color:#f92672">=</span> max(Max, tmp);
        }
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
            tmp <span style="color:#f92672">=</span> v[i];
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>) {
                tmp <span style="color:#f92672">+=</span> v[j];

                <span style="color:#66d9ef">if</span> (tmp <span style="color:#f92672">&gt;</span> Max) <span style="color:#66d9ef">break</span>;
                M[tmp] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            }
        }
        <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">if</span> (M[v[i]] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) cnt<span style="color:#f92672">++</span>;
        }
        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, cnt);
    }
    <span style="color:#75715e">// system(&#34;pause&#34;);
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="problem-f">Problem F</h2>
<!-- raw HTML omitted -->
<p>You are given three numbers:</p>
<p>n0 — the number of such pairs of consecutive characters (substrings) where the number of ones equals 0;
n1 — the number of such pairs of consecutive characters (substrings) where the number of ones equals 1;
n2 — the number of such pairs of consecutive characters (substrings) where the number of ones equals 2.
For example, for the string s=&ldquo;1110011110&rdquo;, the following substrings would be written: &ldquo;11&rdquo;, &ldquo;11&rdquo;, &ldquo;10&rdquo;, &ldquo;00&rdquo;, &ldquo;01&rdquo;, &ldquo;11&rdquo;, &ldquo;11&rdquo;, &ldquo;11&rdquo;, &ldquo;10&rdquo;. Thus, n0=1, n1=3, n2=5.</p>
<p>Your task is to restore any suitable binary string s from the given values n0,n1,n2. It is guaranteed that at least one of the numbers n0,n1,n2 is greater than 0. Also, it is guaranteed that a solution exists.</p>
<h3 id="input-10">Input</h3>
<p>The first line contains an integer t $$ (1≤t≤1000)$$ — the number of test cases in the input. Then test cases follow.</p>
<p>Each test case consists of one line which contains three integers$$ n_0,n_1,n_2 (0≤n_0,n_1,n_2≤100; n_0+n_1+n_2&gt;0).$$ It is guaranteed that the answer for given $$n_0,n_1,n_2$$ exists.</p>
<p>Output
Print t lines. Each of the lines should contain a binary string corresponding to a test case. If there are several possible solutions, print any of them.</p>
<h3 id="example-5">Example</h3>
<h4 id="input-11">input</h4>
<pre><code>7
1 3 5
1 1 1
3 9 3
0 1 0
3 1 2
0 0 3
2 0 0
</code></pre><h4 id="output-10">output</h4>
<pre><code>1110011110
0011
0110001100101011
10
0000111
1111
000
</code></pre><h3 id="ac代码-5">AC代码</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">#define in(n) scanf(&#34;%d&#34;, &amp;n)
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">char</span> s[<span style="color:#ae81ff">405</span>];
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> T;
    <span style="color:#66d9ef">int</span> a, b, c;
    in(T);
    <span style="color:#66d9ef">while</span> (T<span style="color:#f92672">--</span>) {
        in(a);
        in(b);
        in(c);
        <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">if</span> (a) {
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> a; i<span style="color:#f92672">++</span>) s[i] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;0&#39;</span>;
            len <span style="color:#f92672">=</span> a <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        }
        <span style="color:#66d9ef">if</span> (c) {
            <span style="color:#66d9ef">if</span> (len) b<span style="color:#f92672">--</span>;
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> len; i <span style="color:#f92672">&lt;=</span> len <span style="color:#f92672">+</span> c; i<span style="color:#f92672">++</span>) s[i] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;1&#39;</span>;
            len <span style="color:#f92672">=</span> len <span style="color:#f92672">+</span> c <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        }
        <span style="color:#66d9ef">if</span> (b) {
            <span style="color:#66d9ef">if</span> (len <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
                s[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;0&#39;</span>;
                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> b; i<span style="color:#f92672">++</span>)
                    <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>)
                        s[i] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;1&#39;</span>;
                    <span style="color:#66d9ef">else</span>
                        s[i] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;0&#39;</span>;
                len <span style="color:#f92672">=</span> b <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (s[len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span>) {
                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> len; i <span style="color:#f92672">&lt;</span> len <span style="color:#f92672">+</span> b; i<span style="color:#f92672">++</span>)
                    <span style="color:#66d9ef">if</span> ((i <span style="color:#f92672">-</span> len) <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
                        s[i] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;0&#39;</span>;
                    <span style="color:#66d9ef">else</span>
                        s[i] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;1&#39;</span>;
                len <span style="color:#f92672">=</span> len <span style="color:#f92672">+</span> b;
            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (s[len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span>) {
                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> len; i <span style="color:#f92672">&lt;</span> len <span style="color:#f92672">+</span> b; i<span style="color:#f92672">++</span>)
                    <span style="color:#66d9ef">if</span> ((i <span style="color:#f92672">-</span> len) <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
                        s[i] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;1&#39;</span>;
                    <span style="color:#66d9ef">else</span>
                        s[i] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;0&#39;</span>;
                len <span style="color:#f92672">=</span> len <span style="color:#f92672">+</span> b;
            }
        }
        s[len] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
        printf(<span style="color:#e6db74">&#34;%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, s);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="problem-g">Problem G</h2>
<!-- raw HTML omitted -->
<p>For a given number$$ n (n≥2),$$ find a permutation p in which absolute difference (that is, the absolute value of difference) of any two neighboring (adjacent) elements is between 2 and 4, inclusive. Formally, find such permutation p that$$ 2≤|pi−pi+1|≤4 $$ for each $$i (1≤i&lt;n).$$</p>
<p>Print any such permutation for the given integer n or determine that it does not exist.</p>
<h3 id="input-12">Input</h3>
<p>The first line contains an integer$$ t  (1≤t≤100)$$ — the number of test cases in the input. Then t test cases follow.</p>
<p>Each test case is described by a single line containing an integer$$ n (2≤n≤1000).$$</p>
<h3 id="output-11">Output</h3>
<p>Print t lines. Print a permutation that meets the given requirements. If there are several such permutations, then print any of them. If no such permutation exists, print -1.</p>
<h3 id="example-6">Example</h3>
<h4 id="input-13">input</h4>
<pre><code>6
10
2
4
6
7
13
</code></pre><h4 id="output-12">output</h4>
<pre><code>9 6 10 8 4 7 3 1 5 2
-1
3 1 4 2
5 3 6 2 4 1
5 1 3 6 2 4 7
13 9 7 11 8 4 1 3 5 2 6 10 12
</code></pre><h3 id="ac代码-6">AC代码</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;deque&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">#define in(n) scanf(&#34;%d&#34;, &amp;n)
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> T;
    <span style="color:#66d9ef">int</span> n;
    in(T);
    <span style="color:#66d9ef">while</span> (T<span style="color:#f92672">--</span>) {

        in(n);
        <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">3</span>) {
            printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
            <span style="color:#66d9ef">continue</span>;
        }
        deque<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v;
        v.push_back(<span style="color:#ae81ff">3</span>);
        v.push_back(<span style="color:#ae81ff">1</span>);
        v.push_back(<span style="color:#ae81ff">4</span>);
        v.push_back(<span style="color:#ae81ff">2</span>);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>)
                v.push_front(i);
            <span style="color:#66d9ef">else</span>
                v.push_back(i);
        }
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">int</span>) v.size(); i<span style="color:#f92672">++</span>)
            printf(i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;%d&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34; %d&#34;</span>, v[i]);
        putchar(<span style="color:#e6db74">&#39;\n&#39;</span>);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>一个Vue实现的简易计算器</title>
            <link>https://fffzlfk.gitlab.io/2020/06/11/%D2%BBvue%CA%B5%D6%B5%C4%BC/</link>
            <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2020/06/11/%D2%BBvue%CA%B5%D6%B5%C4%BC/</guid>
            <description>点击此链接体验此计算器HTML部分 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;calculator&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;result&amp;#34; style=&amp;#34;grid-area: result&amp;#34;&amp;gt; {{ equation }} &amp;lt;/div&amp;gt; &amp;lt;button style=&amp;#34;grid-area: ac&amp;#34; @click=&amp;#34;clear&amp;#34;&amp;gt;AC&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: plus-minus&amp;#34; @click=&amp;#34;calculateToggle&amp;#34;&amp;gt;±&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: percent&amp;#34; @click=&amp;#34;calculatePercentage&amp;#34;&amp;gt;%&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: add&amp;#34; @click=&amp;#34;append(&amp;#39;+&amp;#39;)&amp;#34;&amp;gt;+&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: subtract&amp;#34; @click=&amp;#34;append(&amp;#39;-&amp;#39;)&amp;#34;&amp;gt; - &amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: multiply&amp;#34; @click=&amp;#34;append(&amp;#39;×&amp;#39;)&amp;#34;&amp;gt;×&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: divide&amp;#34; @click=&amp;#34;append(&amp;#39;÷&amp;#39;)&amp;#34;&amp;gt;÷&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: equal&amp;#34; @click=&amp;#34;calculate&amp;#34;&amp;gt;=&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: number-1&amp;#34; @click=&amp;#34;append(&amp;#39;1&amp;#39;)&amp;#34;&amp;gt;1&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: number-2&amp;#34; @click=&amp;#34;append(&amp;#39;2&amp;#39;)&amp;#34;&amp;gt;2&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: number-3&amp;#34; @click=&amp;#34;append(&amp;#39;3&amp;#39;)&amp;#34;&amp;gt;3&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: number-4&amp;#34; @click=&amp;#34;append(&amp;#39;4&amp;#39;)&amp;#34;&amp;gt;4&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: number-5&amp;#34; @click=&amp;#34;append(&amp;#39;5&amp;#39;)&amp;#34;&amp;gt;5&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: number-6&amp;#34; @click=&amp;#34;append(&amp;#39;6&amp;#39;)&amp;#34;&amp;gt;6&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: number-7&amp;#34; @click=&amp;#34;append(&amp;#39;7&amp;#39;)&amp;#34;&amp;gt;7&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: number-8&amp;#34; @click=&amp;#34;append(&amp;#39;8&amp;#39;)&amp;#34;&amp;gt;8&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: number-9&amp;#34; @click=&amp;#34;append(&amp;#39;9&amp;#39;)&amp;#34;&amp;gt;9&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: number-0&amp;#34; @click=&amp;#34;append(&amp;#39;0&amp;#39;)&amp;#34;&amp;gt;0&amp;lt;/button&amp;gt; &amp;lt;button style=&amp;#34;grid-area: dot&amp;#34; @click=&amp;#34;append(&amp;#39;.</description>
            <content type="html"><![CDATA[<p><!-- raw HTML omitted -->点击此链接体验此计算器<!-- raw HTML omitted --></p>
<h3 id="html部分">HTML部分</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">id</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;app&#34;</span>&gt;
    &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;calculator&#34;</span>&gt;
        &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;result&#34;</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grid-area: result&#34;</span>&gt;
            {{ equation }}
        &lt;/<span style="color:#f92672">div</span>&gt;
        &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grid-area: ac&#34;</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#a6e22e">click</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;clear&#34;</span>&gt;AC&lt;/<span style="color:#f92672">button</span>&gt;
        &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grid-area: plus-minus&#34;</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#a6e22e">click</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;calculateToggle&#34;</span>&gt;±&lt;/<span style="color:#f92672">button</span>&gt;
        &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grid-area: percent&#34;</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#a6e22e">click</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;calculatePercentage&#34;</span>&gt;%&lt;/<span style="color:#f92672">button</span>&gt;
        &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grid-area: add&#34;</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#a6e22e">click</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;append(&#39;+&#39;)&#34;</span>&gt;+&lt;/<span style="color:#f92672">button</span>&gt;
        &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grid-area: subtract&#34;</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#a6e22e">click</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;append(&#39;-&#39;)&#34;</span>&gt; - &lt;/<span style="color:#f92672">button</span>&gt;
        &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grid-area: multiply&#34;</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#a6e22e">click</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;append(&#39;×&#39;)&#34;</span>&gt;×&lt;/<span style="color:#f92672">button</span>&gt;
        &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grid-area: divide&#34;</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#a6e22e">click</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;append(&#39;÷&#39;)&#34;</span>&gt;÷&lt;/<span style="color:#f92672">button</span>&gt;
        &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grid-area: equal&#34;</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#a6e22e">click</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;calculate&#34;</span>&gt;=&lt;/<span style="color:#f92672">button</span>&gt;

        &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grid-area: number-1&#34;</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#a6e22e">click</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;append(&#39;1&#39;)&#34;</span>&gt;1&lt;/<span style="color:#f92672">button</span>&gt;
        &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grid-area: number-2&#34;</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#a6e22e">click</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;append(&#39;2&#39;)&#34;</span>&gt;2&lt;/<span style="color:#f92672">button</span>&gt;
        &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grid-area: number-3&#34;</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#a6e22e">click</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;append(&#39;3&#39;)&#34;</span>&gt;3&lt;/<span style="color:#f92672">button</span>&gt;
        &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grid-area: number-4&#34;</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#a6e22e">click</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;append(&#39;4&#39;)&#34;</span>&gt;4&lt;/<span style="color:#f92672">button</span>&gt;
        &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grid-area: number-5&#34;</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#a6e22e">click</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;append(&#39;5&#39;)&#34;</span>&gt;5&lt;/<span style="color:#f92672">button</span>&gt;
        &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grid-area: number-6&#34;</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#a6e22e">click</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;append(&#39;6&#39;)&#34;</span>&gt;6&lt;/<span style="color:#f92672">button</span>&gt;
        &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grid-area: number-7&#34;</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#a6e22e">click</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;append(&#39;7&#39;)&#34;</span>&gt;7&lt;/<span style="color:#f92672">button</span>&gt;
        &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grid-area: number-8&#34;</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#a6e22e">click</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;append(&#39;8&#39;)&#34;</span>&gt;8&lt;/<span style="color:#f92672">button</span>&gt;
        &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grid-area: number-9&#34;</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#a6e22e">click</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;append(&#39;9&#39;)&#34;</span>&gt;9&lt;/<span style="color:#f92672">button</span>&gt;
        &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grid-area: number-0&#34;</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#a6e22e">click</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;append(&#39;0&#39;)&#34;</span>&gt;0&lt;/<span style="color:#f92672">button</span>&gt;

        &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;grid-area: dot&#34;</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#a6e22e">click</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;append(&#39;.&#39;)&#34;</span>&gt;.&lt;/<span style="color:#f92672">button</span>&gt;
    &lt;/<span style="color:#f92672">div</span>&gt;
&lt;/<span style="color:#f92672">div</span>&gt;
</code></pre></div><h3 id="css部分">CSS部分</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-css" data-lang="css"><span style="color:#f92672">body</span> {
    <span style="color:#66d9ef">display</span>: <span style="color:#66d9ef">flex</span>;
    <span style="color:#66d9ef">justify-content</span>: <span style="color:#66d9ef">center</span>;
    <span style="color:#66d9ef">align-items</span>: <span style="color:#66d9ef">center</span>;
    <span style="color:#66d9ef">min-height</span>: <span style="color:#ae81ff">100</span><span style="color:#66d9ef">vh</span>;
    <span style="color:#66d9ef">background-color</span>: <span style="color:#ae81ff">#eee</span>;
}

.<span style="color:#a6e22e">calculator</span> {
    --button-width: <span style="color:#ae81ff">80</span><span style="color:#66d9ef">px</span>;
    --button-height: <span style="color:#ae81ff">80</span><span style="color:#66d9ef">px</span>;

    <span style="color:#66d9ef">display</span>: <span style="color:#66d9ef">grid</span>;
    <span style="color:#66d9ef">grid-template-areas</span>:
<span style="color:#e6db74">&#34;result result result result&#34;</span>
<span style="color:#e6db74">&#34;ac plus-minus percent divide&#34;</span>
<span style="color:#e6db74">&#34;number-7 number-8 number-9 multiply&#34;</span>
<span style="color:#e6db74">&#34;number-4 number-5 number-6 subtract&#34;</span>
<span style="color:#e6db74">&#34;number-1 number-2 number-3 add&#34;</span>
<span style="color:#e6db74">&#34;number-0 number-0 dot equal&#34;</span>;
    <span style="color:#66d9ef">grid-template-columns</span>: <span style="color:#a6e22e">repeat</span>(<span style="color:#ae81ff">4</span>, <span style="color:#a6e22e">var</span>(<span style="color:#f92672">--</span>button<span style="color:#f92672">-</span>width));
    <span style="color:#66d9ef">grid-template-rows</span>: <span style="color:#a6e22e">repeat</span>(<span style="color:#ae81ff">6</span>, <span style="color:#a6e22e">var</span>(<span style="color:#f92672">--</span>button<span style="color:#f92672">-</span>height));
    <span style="color:#66d9ef">box-shadow</span>: <span style="color:#ae81ff">-8</span><span style="color:#66d9ef">px</span> <span style="color:#ae81ff">-8</span><span style="color:#66d9ef">px</span> <span style="color:#ae81ff">16</span><span style="color:#66d9ef">px</span> <span style="color:#ae81ff">-10</span><span style="color:#66d9ef">px</span> rgba(<span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">1</span>),
    <span style="color:#ae81ff">8</span><span style="color:#66d9ef">px</span> <span style="color:#ae81ff">8</span><span style="color:#66d9ef">px</span> <span style="color:#ae81ff">16</span><span style="color:#66d9ef">px</span> <span style="color:#ae81ff">-10</span><span style="color:#66d9ef">px</span> rgba(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0.15</span>);
    <span style="color:#66d9ef">padding</span>: <span style="color:#ae81ff">24</span><span style="color:#66d9ef">px</span>;
    <span style="color:#66d9ef">border-radius</span>: <span style="color:#ae81ff">20</span><span style="color:#66d9ef">px</span>;
}

.<span style="color:#a6e22e">calculator</span> <span style="color:#f92672">button</span> {
    <span style="color:#66d9ef">margin</span>: <span style="color:#ae81ff">8</span><span style="color:#66d9ef">px</span>;
    <span style="color:#66d9ef">padding</span>: <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">border</span>: <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">display</span>: <span style="color:#66d9ef">block</span>;
    <span style="color:#66d9ef">outline</span>: <span style="color:#66d9ef">none</span>;
    <span style="color:#66d9ef">border-radius</span>: calc(<span style="color:#a6e22e">var</span>(<span style="color:#f92672">--</span>button<span style="color:#f92672">-</span>height) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>);
    <span style="color:#66d9ef">font-size</span>: <span style="color:#ae81ff">24</span><span style="color:#66d9ef">px</span>;
    <span style="color:#66d9ef">font-family</span>: Helvetica;
    <span style="color:#66d9ef">color</span>: <span style="color:#ae81ff">#999</span>;
    <span style="color:#66d9ef">background</span>: linear-gradient(
            <span style="color:#ae81ff">135</span><span style="color:#66d9ef">deg</span>,
            rgba(<span style="color:#ae81ff">230</span>, <span style="color:#ae81ff">230</span>, <span style="color:#ae81ff">230</span>, <span style="color:#ae81ff">1</span>) <span style="color:#ae81ff">0</span><span style="color:#66d9ef">%</span>,
            rgba(<span style="color:#ae81ff">246</span>, <span style="color:#ae81ff">246</span>, <span style="color:#ae81ff">246</span>, <span style="color:#ae81ff">1</span>) <span style="color:#ae81ff">100</span><span style="color:#66d9ef">%</span>
    );
    <span style="color:#66d9ef">box-shadow</span>: <span style="color:#ae81ff">-4</span><span style="color:#66d9ef">px</span> <span style="color:#ae81ff">-4</span><span style="color:#66d9ef">px</span> <span style="color:#ae81ff">10</span><span style="color:#66d9ef">px</span> <span style="color:#ae81ff">-8</span><span style="color:#66d9ef">px</span> rgba(<span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">1</span>),
    <span style="color:#ae81ff">4</span><span style="color:#66d9ef">px</span> <span style="color:#ae81ff">4</span><span style="color:#66d9ef">px</span> <span style="color:#ae81ff">10</span><span style="color:#66d9ef">px</span> <span style="color:#ae81ff">-8</span><span style="color:#66d9ef">px</span> rgba(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0.3</span>);
}

.<span style="color:#a6e22e">calculator</span> <span style="color:#f92672">button</span>:<span style="color:#a6e22e">active</span> {
    <span style="color:#66d9ef">box-shadow</span>: <span style="color:#ae81ff">-4</span><span style="color:#66d9ef">px</span> <span style="color:#ae81ff">-4</span><span style="color:#66d9ef">px</span> <span style="color:#ae81ff">10</span><span style="color:#66d9ef">px</span> <span style="color:#ae81ff">-8</span><span style="color:#66d9ef">px</span> rgba(<span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">1</span>),
    <span style="color:#ae81ff">4</span><span style="color:#66d9ef">px</span> <span style="color:#ae81ff">4</span><span style="color:#66d9ef">px</span> <span style="color:#ae81ff">10</span><span style="color:#66d9ef">px</span> <span style="color:#ae81ff">-8</span><span style="color:#66d9ef">px</span> rgba(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0.3</span>) <span style="color:#66d9ef">inset</span>;
}

.<span style="color:#a6e22e">result</span> {
    <span style="color:#66d9ef">text-align</span>: <span style="color:#66d9ef">right</span>;
    <span style="color:#66d9ef">line-height</span>: <span style="color:#a6e22e">var</span>(<span style="color:#f92672">--</span>button<span style="color:#f92672">-</span>height);
    <span style="color:#66d9ef">font-size</span>: <span style="color:#ae81ff">48</span><span style="color:#66d9ef">px</span>;
    <span style="color:#66d9ef">font-family</span>: Helvetic;
    <span style="color:#66d9ef">padding</span>: <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">20</span><span style="color:#66d9ef">px</span>;
    <span style="color:#66d9ef">color</span>: <span style="color:#ae81ff">#666</span>;
}
</code></pre></div><h3 id="javascript部分">JavaScript部分</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Vue</span>({
    <span style="color:#a6e22e">el</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;#app&#34;</span>,
    <span style="color:#a6e22e">data</span><span style="color:#f92672">:</span> {
        <span style="color:#a6e22e">equation</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;0&#34;</span>,
        <span style="color:#a6e22e">isDecimalAdded</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">false</span>,
        <span style="color:#a6e22e">isOperatorAdded</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">false</span>,
        <span style="color:#a6e22e">isStarted</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">false</span>
    },
    <span style="color:#a6e22e">methods</span><span style="color:#f92672">:</span> {
        <span style="color:#a6e22e">isOperator</span>(<span style="color:#a6e22e">character</span>) {
            <span style="color:#66d9ef">return</span> [<span style="color:#e6db74">&#34;+&#34;</span>, <span style="color:#e6db74">&#34;-&#34;</span>, <span style="color:#e6db74">&#34;×&#34;</span>, <span style="color:#e6db74">&#34;÷&#34;</span>].<span style="color:#a6e22e">indexOf</span>(<span style="color:#a6e22e">character</span>) <span style="color:#f92672">&gt;</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        },

        <span style="color:#a6e22e">append</span>(<span style="color:#a6e22e">character</span>) {
          <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">equation</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">9</span>) {
            <span style="color:#66d9ef">return</span>;
          }
            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">equation</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;0&#34;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isOperator</span>(<span style="color:#a6e22e">character</span>)) {
                <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">character</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;.&#34;</span>) {
                    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">equation</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">character</span>;
                    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isDecimalAdded</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
                } <span style="color:#66d9ef">else</span> {
                    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">equation</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">character</span>;
                }
                <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isStarted</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
                <span style="color:#66d9ef">return</span>;
            }
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isOperator</span>(<span style="color:#a6e22e">character</span>)) {
                <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">character</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isDecimal</span>) {
                    <span style="color:#66d9ef">return</span>;
                }
                <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">character</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;.&#34;</span>) {
                    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isDecimal</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
                    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isOperatorAdded</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
                } <span style="color:#66d9ef">else</span> {
                    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isOperatorAdded</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
                }
                <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">equation</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">character</span>;
            }

            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isOperator</span>(<span style="color:#a6e22e">character</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isOperatorAdded</span>) {
                <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">equation</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">character</span>;
                <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isDecimal</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
                <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isOperatorAdded</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
            }
        },

        <span style="color:#a6e22e">calculate</span>() {
            <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">equation</span>
                .<span style="color:#a6e22e">replace</span>(<span style="color:#66d9ef">new</span> RegExp(<span style="color:#e6db74">&#34;×&#34;</span>, <span style="color:#e6db74">&#34;g&#34;</span>), <span style="color:#e6db74">&#34;*&#34;</span>)
                .<span style="color:#a6e22e">replace</span>(<span style="color:#66d9ef">new</span> RegExp(<span style="color:#e6db74">&#34;÷&#34;</span>, <span style="color:#e6db74">&#34;g&#34;</span>), <span style="color:#e6db74">&#34;/&#34;</span>);
            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">equation</span> <span style="color:#f92672">=</span> parseFloat(eval(<span style="color:#a6e22e">result</span>).<span style="color:#a6e22e">toFixed</span>(<span style="color:#ae81ff">9</span>)).<span style="color:#a6e22e">toString</span>();
            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isOperatorAdded</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isDecimalAdded</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
        },

        <span style="color:#a6e22e">calculateToggle</span>() {
            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isOperatorAdded</span> <span style="color:#f92672">||</span> <span style="color:#f92672">!</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isStarted</span>) {
                <span style="color:#66d9ef">return</span>;
            }
            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">equation</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;* -1&#34;</span>;
            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">calculate</span>();
        },

        <span style="color:#a6e22e">calculatePercentage</span>() {
            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isOperatorAdded</span> <span style="color:#f92672">||</span> <span style="color:#f92672">!</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isStarted</span>) {
                <span style="color:#66d9ef">return</span>;
            }
            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">equation</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;* 0.01&#34;</span>;
            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">calculate</span>();
        },

        <span style="color:#a6e22e">clear</span>() {
            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">equation</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;0&#34;</span>;
            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isDecimalAdded</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isOperatorAdded</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isStarted</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
        }
    }
});
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Windows消息队列</title>
            <link>https://fffzlfk.gitlab.io/2020/05/31/windows%CF%A3/</link>
            <pubDate>Sun, 31 May 2020 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2020/05/31/windows%CF%A3/</guid>
            <description>问题描述 消息队列是Windows系统的基础。对于每个进程，系统维护一个消息队列。如果在进程中有特定事件发生，如点击鼠标、文字改变等，系统将把这个消息加到队列当中。同时，如果队列不是空的，这一进程循环地从队列中按照优先级获取消息。请注意优先级值低意味着优先级高。请编辑程序模拟消息队列，将消息加到队列中以及从队列中获取消息。
题目链接
解决思路 此次可以使用优先队列来解，priority_queue是一种先入优先级高者出的队列。
输入格式: 输入首先给出正整数N（≤10^5​​），随后N行，每行给出一个指令——GET或PUT，分别表示从队列中取出消息或将消息添加到队列中。如果指令是PUT，后面就有一个消息名称、以及一个正整数表示消息的优先级，此数越小表示优先级越高。消息名称是长度不超过10个字符且不含空格的字符串；题目保证队列中消息的优先级无重复，且输入至少有一个GET。
输出格式: 对于每个GET指令，在一行中输出消息队列中优先级最高的消息的名称和参数。如果消息队列中没有消息，输出EMPTY QUEUE!。对于PUT指令则没有输出。
输入样例: 9PUT msg1 5PUT msg2 4GETPUT msg3 2PUT msg4 4GETGETGETGET输出样例: msg2msg3msg4msg1EMPTY QUEUE!AC代码 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; struct node { char s[12]; int p; friend bool operator&amp;lt;(const node &amp;amp;a, const node &amp;amp;b) { return a.p &amp;gt; b.p; } node(char *a, int b) { strcpy(s, a); p = b; } }; priority_queue&amp;lt;node&amp;gt; Q; int main() { int T; scanf(&amp;#34;%d&amp;#34;, &amp;amp;T); char tmp[4], t[12]; int p; while (T--) { scanf(&amp;#34;%s&amp;#34;, tmp); if (tmp[0] == &amp;#39;P&amp;#39;) { scanf(&amp;#34;%s %d&amp;#34;, t, &amp;amp;p); Q.</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>消息队列是Windows系统的基础。对于每个进程，系统维护一个消息队列。如果在进程中有特定事件发生，如点击鼠标、文字改变等，系统将把这个消息加到队列当中。同时，如果队列不是空的，这一进程循环地从队列中按照优先级获取消息。请注意优先级值低意味着优先级高。请编辑程序模拟消息队列，将消息加到队列中以及从队列中获取消息。</p>
<p><a href="https://pintia.cn/problem-sets/15/problems/841">题目链接</a></p>
<h3 id="解决思路">解决思路</h3>
<p>此次可以使用优先队列来解，priority_queue是一种先入优先级高者出的队列。</p>
<h3 id="输入格式">输入格式:</h3>
<p>输入首先给出正整数N（≤10^5​​），随后N行，每行给出一个指令——GET或PUT，分别表示从队列中取出消息或将消息添加到队列中。如果指令是PUT，后面就有一个消息名称、以及一个正整数表示消息的优先级，此数越小表示优先级越高。消息名称是长度不超过10个字符且不含空格的字符串；题目保证队列中消息的优先级无重复，且输入至少有一个GET。</p>
<h3 id="输出格式">输出格式:</h3>
<p>对于每个GET指令，在一行中输出消息队列中优先级最高的消息的名称和参数。如果消息队列中没有消息，输出EMPTY QUEUE!。对于PUT指令则没有输出。</p>
<h3 id="输入样例">输入样例:</h3>
<pre><code>9
PUT msg1 5
PUT msg2 4
GET
PUT msg3 2
PUT msg4 4
GET
GET
GET
GET
</code></pre><h3 id="输出样例">输出样例:</h3>
<pre><code>msg2
msg3
msg4
msg1
EMPTY QUEUE!
</code></pre><h3 id="ac代码">AC代码</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {
    <span style="color:#66d9ef">char</span> s[<span style="color:#ae81ff">12</span>];
    <span style="color:#66d9ef">int</span> p;
    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">const</span> node <span style="color:#f92672">&amp;</span>a, <span style="color:#66d9ef">const</span> node <span style="color:#f92672">&amp;</span>b) { <span style="color:#66d9ef">return</span> a.p <span style="color:#f92672">&gt;</span> b.p; }
    node(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">int</span> b) {
        strcpy(s, a);
        p <span style="color:#f92672">=</span> b;
    }
};

priority_queue<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">&gt;</span> Q;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> T;
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>T);
    <span style="color:#66d9ef">char</span> tmp[<span style="color:#ae81ff">4</span>], t[<span style="color:#ae81ff">12</span>];
    <span style="color:#66d9ef">int</span> p;
    <span style="color:#66d9ef">while</span> (T<span style="color:#f92672">--</span>) {
        scanf(<span style="color:#e6db74">&#34;%s&#34;</span>, tmp);
        <span style="color:#66d9ef">if</span> (tmp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;P&#39;</span>) {
            scanf(<span style="color:#e6db74">&#34;%s %d&#34;</span>, t, <span style="color:#f92672">&amp;</span>p);
            Q.push(node(t, p));
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#e6db74">&#39;G&#39;</span> <span style="color:#f92672">==</span> tmp[<span style="color:#ae81ff">0</span>]) {
            <span style="color:#66d9ef">if</span> (Q.empty()) {
                puts(<span style="color:#e6db74">&#34;EMPTY QUEUE!&#34;</span>);
                <span style="color:#66d9ef">continue</span>;
            }
            cout <span style="color:#f92672">&lt;&lt;</span> Q.top().s <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
            Q.pop();
        }
    }

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>机器学习02-决策树</title>
            <link>https://fffzlfk.gitlab.io/2020/03/30/%D1%A7%CF%B002-/</link>
            <pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2020/03/30/%D1%A7%CF%B002-/</guid>
            <description>一个简单的例子 from sklearn import tree features = [[140, 1], [130, 1], [150, 0], [170, 0]] labels = [0, 0, 1, 1] clf = tree.DecisionTreeClassifier() clf = clf.fit(features, labels) print(clf.predict([[150, 1]])) 经典例子iris 代码 import numpy as np from sklearn.datasets import load_iris from sklearn import tree iris = load_iris() # print(iris.feature_names) # print(iris.target_names) # print(iris.data[0]) # print(iris.target[0]) test_idx = [0, 50, 100] train_target = np.delete(iris.target, test_idx) train_data = np.delete(iris.data, test_idx, axis=0) test_target = iris.</description>
            <content type="html"><![CDATA[<h3 id="一个简单的例子">一个简单的例子</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> sklearn <span style="color:#f92672">import</span> tree

features <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">140</span>, <span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">130</span>, <span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">150</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">170</span>, <span style="color:#ae81ff">0</span>]]
labels <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>]
clf <span style="color:#f92672">=</span> tree<span style="color:#f92672">.</span>DecisionTreeClassifier()
clf <span style="color:#f92672">=</span> clf<span style="color:#f92672">.</span>fit(features, labels)

<span style="color:#66d9ef">print</span>(clf<span style="color:#f92672">.</span>predict([[<span style="color:#ae81ff">150</span>, <span style="color:#ae81ff">1</span>]]))
</code></pre></div><h3 id="经典例子iris">经典例子iris</h3>
<h4 id="代码">代码</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np
<span style="color:#f92672">from</span> sklearn.datasets <span style="color:#f92672">import</span> load_iris
<span style="color:#f92672">from</span> sklearn <span style="color:#f92672">import</span> tree
iris <span style="color:#f92672">=</span> load_iris()
<span style="color:#75715e"># print(iris.feature_names)</span>
<span style="color:#75715e"># print(iris.target_names)</span>
<span style="color:#75715e"># print(iris.data[0])</span>
<span style="color:#75715e"># print(iris.target[0])</span>

test_idx <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">100</span>]

train_target <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>delete(iris<span style="color:#f92672">.</span>target, test_idx)
train_data <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>delete(iris<span style="color:#f92672">.</span>data, test_idx, axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)

test_target <span style="color:#f92672">=</span> iris<span style="color:#f92672">.</span>target[test_idx]
test_data <span style="color:#f92672">=</span> iris<span style="color:#f92672">.</span>data[test_idx]

clf <span style="color:#f92672">=</span> tree<span style="color:#f92672">.</span>DecisionTreeClassifier()
clf<span style="color:#f92672">.</span>fit(train_data, train_target)

<span style="color:#66d9ef">print</span>(test_target)
<span style="color:#66d9ef">print</span>(clf<span style="color:#f92672">.</span>predict(test_data))

<span style="color:#75715e"># viz code</span>
<span style="color:#f92672">from</span> sklearn.externals.six <span style="color:#f92672">import</span> StringIO
<span style="color:#f92672">import</span> pydotplus
dot_data <span style="color:#f92672">=</span> StringIO()
tree<span style="color:#f92672">.</span>export_graphviz(clf,
                     out_file<span style="color:#f92672">=</span>dot_data,
                     feature_names<span style="color:#f92672">=</span>iris<span style="color:#f92672">.</span>feature_names,
                     class_names<span style="color:#f92672">=</span>iris<span style="color:#f92672">.</span>target_names,
                     filled<span style="color:#f92672">=</span>True, rounded<span style="color:#f92672">=</span>True,
                     impurity<span style="color:#f92672">=</span>False)
graph <span style="color:#f92672">=</span> pydotplus<span style="color:#f92672">.</span>graph_from_dot_data(dot_data<span style="color:#f92672">.</span>getvalue())
graph<span style="color:#f92672">.</span>write_pdf(<span style="color:#e6db74">&#39;iris.pdf&#39;</span>)
</code></pre></div><h4 id="决策树可视化">决策树可视化</h4>
<!-- raw HTML omitted -->
]]></content>
        </item>
        
        <item>
            <title>机器学习03-KNN</title>
            <link>https://fffzlfk.gitlab.io/2020/04/01/%D1%A7%CF%B003-knn/</link>
            <pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2020/04/01/%D1%A7%CF%B003-knn/</guid>
            <description>from scipy.spatial import distance def euc(a, b): return distance.euclidean(a, b) class ScrappyKNN(): def fit(self, X_train, y_train): self.X_train = X_train self.y_train = y_train def predict(self, X_test): predictions = [] for row in X_test: label = self.closest(row) predictions.append(label) return predictions def closest(self, row): best_dist = euc(row, self.X_train[0]) best_index = 0 for i in range(1, len(self.X_train)): dist = euc(row, self.X_train[i]) if dist &amp;lt; best_dist: best_dist = dist best_index = i return self.y_train[best_index] from sklearn import datasets iris = datasets.</description>
            <content type="html"><![CDATA[<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> scipy.spatial <span style="color:#f92672">import</span> distance

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">euc</span>(a, b):
    <span style="color:#66d9ef">return</span> distance<span style="color:#f92672">.</span>euclidean(a, b)


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ScrappyKNN</span>():

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fit</span>(self, X_train, y_train):
        self<span style="color:#f92672">.</span>X_train <span style="color:#f92672">=</span> X_train
        self<span style="color:#f92672">.</span>y_train <span style="color:#f92672">=</span> y_train

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">predict</span>(self, X_test):
        predictions <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> X_test:
            label <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>closest(row)
            predictions<span style="color:#f92672">.</span>append(label)
        <span style="color:#66d9ef">return</span> predictions

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">closest</span>(self, row):
        best_dist <span style="color:#f92672">=</span> euc(row, self<span style="color:#f92672">.</span>X_train[<span style="color:#ae81ff">0</span>])
        best_index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(self<span style="color:#f92672">.</span>X_train)):
            dist <span style="color:#f92672">=</span> euc(row, self<span style="color:#f92672">.</span>X_train[i])
            <span style="color:#66d9ef">if</span> dist <span style="color:#f92672">&lt;</span> best_dist:
                best_dist <span style="color:#f92672">=</span> dist
                best_index <span style="color:#f92672">=</span> i
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>y_train[best_index]

<span style="color:#f92672">from</span> sklearn <span style="color:#f92672">import</span> datasets

iris <span style="color:#f92672">=</span> datasets<span style="color:#f92672">.</span>load_iris()

X <span style="color:#f92672">=</span> iris<span style="color:#f92672">.</span>data
y <span style="color:#f92672">=</span> iris<span style="color:#f92672">.</span>target

<span style="color:#f92672">from</span> sklearn.model_selection <span style="color:#f92672">import</span> train_test_split

X_train, X_test, y_train, y_test <span style="color:#f92672">=</span> train_test_split(X, y, test_size<span style="color:#f92672">=.</span><span style="color:#ae81ff">5</span>)

<span style="color:#75715e"># from sklearn import tree</span>

<span style="color:#75715e"># my_clf = tree.DecisionTreeClassifier()</span>

<span style="color:#75715e"># from sklearn.neighbors import KNeighborsClassifier</span>

my_clf <span style="color:#f92672">=</span> ScrappyKNN()

my_clf<span style="color:#f92672">.</span>fit(X_train, y_train)

predictions <span style="color:#f92672">=</span> my_clf<span style="color:#f92672">.</span>predict(X_test)
<span style="color:#66d9ef">print</span>(predictions)

<span style="color:#f92672">from</span> sklearn.metrics <span style="color:#f92672">import</span> accuracy_score

<span style="color:#66d9ef">print</span>(accuracy_score(y_test, predictions))
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>机器学习01</title>
            <link>https://fffzlfk.gitlab.io/2020/03/21/%D1%A7%CF%B001/</link>
            <pubDate>Sat, 21 Mar 2020 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2020/03/21/%D1%A7%CF%B001/</guid>
            <description>卷积神经网络入门 import tensorflow as tf import numpy as np from tensorflow import keras # 创建一层的神经网络 model = tf.keras.Sequential([keras.layers.Dense(units=1, input_shape=[1])]) # 指定loss和optimizer函数 &amp;#39;sgd&amp;#39;(梯度随机下降) (均方误差) model.compile(optimizer=&amp;#39;sgd&amp;#39;, loss=&amp;#39;mean_squared_error&amp;#39;) # 生成测试数据 X = [] for i in range(-1, 5): X.append(i * 1.0) Y = [3 * i + 1 for i in X] xs = np.array(X, dtype=float) ys = np.array(Y, dtype=float) model.fit(xs, ys, epochs=2500) # 使用模型 print(model.predict([0.0])) 手写数字识别代码 from tensorflow.examples.tutorials.mnist import input_data minist = input_data.</description>
            <content type="html"><![CDATA[<h3 id="卷积神经网络入门">卷积神经网络入门</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> tensorflow <span style="color:#f92672">as</span> tf
<span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np
<span style="color:#f92672">from</span> tensorflow <span style="color:#f92672">import</span> keras

<span style="color:#75715e"># 创建一层的神经网络</span>
model <span style="color:#f92672">=</span> tf<span style="color:#f92672">.</span>keras<span style="color:#f92672">.</span>Sequential([keras<span style="color:#f92672">.</span>layers<span style="color:#f92672">.</span>Dense(units<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, input_shape<span style="color:#f92672">=</span>[<span style="color:#ae81ff">1</span>])])
<span style="color:#75715e"># 指定loss和optimizer函数 &#39;sgd&#39;(梯度随机下降) (均方误差)</span>
model<span style="color:#f92672">.</span>compile(optimizer<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;sgd&#39;</span>, loss<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;mean_squared_error&#39;</span>)

<span style="color:#75715e"># 生成测试数据</span>
X <span style="color:#f92672">=</span> []
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">5</span>):
    X<span style="color:#f92672">.</span>append(i <span style="color:#f92672">*</span> <span style="color:#ae81ff">1.0</span>)

Y <span style="color:#f92672">=</span> [<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> X]

xs <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(X, dtype<span style="color:#f92672">=</span>float)
ys <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(Y, dtype<span style="color:#f92672">=</span>float)

model<span style="color:#f92672">.</span>fit(xs, ys, epochs<span style="color:#f92672">=</span><span style="color:#ae81ff">2500</span>)

<span style="color:#75715e"># 使用模型</span>
<span style="color:#66d9ef">print</span>(model<span style="color:#f92672">.</span>predict([<span style="color:#ae81ff">0.0</span>]))
</code></pre></div><h3 id="手写数字识别代码">手写数字识别代码</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> tensorflow.examples.tutorials.mnist <span style="color:#f92672">import</span> input_data

minist <span style="color:#f92672">=</span> input_data<span style="color:#f92672">.</span>read_data_sets(<span style="color:#e6db74">&#39;/home/fffzlfk/Python/data&#39;</span>, one_hot<span style="color:#f92672">=</span>True)

learning_rate <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.01</span>
batch_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">125</span>
n_epochs <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>


<span style="color:#f92672">import</span> tensorflow <span style="color:#f92672">as</span> tf

X <span style="color:#f92672">=</span> tf<span style="color:#f92672">.</span>placeholder(tf<span style="color:#f92672">.</span>float32, [batch_size, <span style="color:#ae81ff">784</span>])
Y <span style="color:#f92672">=</span> tf<span style="color:#f92672">.</span>placeholder(tf<span style="color:#f92672">.</span>int32, [batch_size, <span style="color:#ae81ff">10</span>])

<span style="color:#66d9ef">with</span> tf<span style="color:#f92672">.</span>name_scope(<span style="color:#e6db74">&#39;Wx_b&#39;</span>) <span style="color:#66d9ef">as</span> scope:
    w <span style="color:#f92672">=</span> tf<span style="color:#f92672">.</span>Variable(tf<span style="color:#f92672">.</span>random_normal(
        shape<span style="color:#f92672">=</span>[<span style="color:#ae81ff">784</span>, <span style="color:#ae81ff">10</span>], stddev<span style="color:#f92672">=</span><span style="color:#ae81ff">0.01</span>), name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;weights&#39;</span>)
    b <span style="color:#f92672">=</span> tf<span style="color:#f92672">.</span>Variable(tf<span style="color:#f92672">.</span>zeros([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">10</span>]), name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;bits&#39;</span>)
    logits <span style="color:#f92672">=</span> tf<span style="color:#f92672">.</span>matmul(X, w) <span style="color:#f92672">+</span> b


<span style="color:#66d9ef">with</span> tf<span style="color:#f92672">.</span>name_scope(<span style="color:#e6db74">&#39;cost&#39;</span>) <span style="color:#66d9ef">as</span> scope:
    entropy <span style="color:#f92672">=</span> tf<span style="color:#f92672">.</span>nn<span style="color:#f92672">.</span>softmax_cross_entropy_with_logits(
        logits<span style="color:#f92672">=</span>logits, labels<span style="color:#f92672">=</span>Y, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;loss&#39;</span>)
    loss <span style="color:#f92672">=</span> tf<span style="color:#f92672">.</span>reduce_mean(entropy)
    tf<span style="color:#f92672">.</span>summary<span style="color:#f92672">.</span>scalar(<span style="color:#e6db74">&#39;loss&#39;</span>, loss)


<span style="color:#66d9ef">with</span> tf<span style="color:#f92672">.</span>name_scope(<span style="color:#e6db74">&#39;train&#39;</span>) <span style="color:#66d9ef">as</span> scope:
    optimizer <span style="color:#f92672">=</span> tf<span style="color:#f92672">.</span>train<span style="color:#f92672">.</span>GradientDescentOptimizer(learning_rate)<span style="color:#f92672">.</span>minimize(loss)


summary <span style="color:#f92672">=</span> tf<span style="color:#f92672">.</span>summary<span style="color:#f92672">.</span>merge_all()

<span style="color:#66d9ef">with</span> tf<span style="color:#f92672">.</span>Session() <span style="color:#66d9ef">as</span> sess:
    writer <span style="color:#f92672">=</span> tf<span style="color:#f92672">.</span>summary<span style="color:#f92672">.</span>FileWriter(
        <span style="color:#e6db74">&#39;/home/fffzlfk/Python/data/graphs&#39;</span>, sess<span style="color:#f92672">.</span>graph)
    sess<span style="color:#f92672">.</span>run(tf<span style="color:#f92672">.</span>global_variables_initializer())
    n_batches <span style="color:#f92672">=</span> int(minist<span style="color:#f92672">.</span>train<span style="color:#f92672">.</span>num_examples <span style="color:#f92672">/</span> batch_size)

    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n_epochs):
        total_loss <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n_batches):
            X_batch, Y_batch <span style="color:#f92672">=</span> minist<span style="color:#f92672">.</span>train<span style="color:#f92672">.</span>next_batch(batch_size)
            _, loss_batch <span style="color:#f92672">=</span> sess<span style="color:#f92672">.</span>run([optimizer, loss], feed_dict<span style="color:#f92672">=</span>{
                                     X: X_batch, Y: Y_batch})
        total_loss <span style="color:#f92672">+=</span> loss_batch
        summary_str <span style="color:#f92672">=</span> sess<span style="color:#f92672">.</span>run(summary, feed_dict<span style="color:#f92672">=</span>{X: X_batch, Y: Y_batch})
        writer<span style="color:#f92672">.</span>add_summary(summary_str, i <span style="color:#f92672">*</span> n_batches)
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Average loss epoch {0}: {1}&#39;</span><span style="color:#f92672">.</span>format(i, total_loss <span style="color:#f92672">/</span> n_batches))
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>两个有序序列的中位数</title>
            <link>https://fffzlfk.gitlab.io/2019/12/31/%D0%B5%CE%BB/</link>
            <pubDate>Tue, 31 Dec 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/12/31/%D0%B5%CE%BB/</guid>
            <description>问题描述 已知有两个等长的非降序序列S1, S2, 设计函数求S1与S2并集的中位数。有序序列A ​0 ​​ ,A ​1 ​​ ,⋯,A ​N−1 ​​ 的中位数指A ​(N−1)/2 ​​ 的值,即第⌊(N+1)/2⌋个数（A ​0 ​​ 为第1个数）。
输入格式: 输入分三行。第一行给出序列的公共长度N（0&amp;lt;N≤100000），随后每行输入一个序列的信息，即N个非降序排列的整数。数字用空格间隔。
输出格式: 在一行中输出两个输入序列的并集序列的中位数。
输入样例1: 51 3 5 7 92 3 4 5 6输出样例1: 4输入样例2: 6-100 -10 1 1 1 1-50 0 2 3 4 5输出样例2: 1代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; q; int main() { int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); int t; for (int i = 1; i &amp;lt;= 2 * n; i++) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); q.</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>已知有两个等长的非降序序列S1, S2, 设计函数求S1与S2并集的中位数。有序序列A
​0
​​ ,A
​1
​​ ,⋯,A
​N−1
​​ 的中位数指A
​(N−1)/2
​​ 的值,即第⌊(N+1)/2⌋个数（A
​0
​​ 为第1个数）。</p>
<h3 id="输入格式">输入格式:</h3>
<p>输入分三行。第一行给出序列的公共长度N（0&lt;N≤100000），随后每行输入一个序列的信息，即N个非降序排列的整数。数字用空格间隔。</p>
<h3 id="输出格式">输出格式:</h3>
<p>在一行中输出两个输入序列的并集序列的中位数。</p>
<h3 id="输入样例1">输入样例1:</h3>
<pre><code>5
1 3 5 7 9
2 3 4 5 6
</code></pre><h3 id="输出样例1">输出样例1:</h3>
<pre><code>4
</code></pre><h3 id="输入样例2">输入样例2:</h3>
<pre><code>6
-100 -10 1 1 1 1
-50 0 2 3 4 5
</code></pre><h3 id="输出样例2">输出样例2:</h3>
<pre><code>1
</code></pre><h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
priority_queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>, greater<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> q;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> n;
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">int</span> t;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> n; i<span style="color:#f92672">++</span>) {
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>t);
        q.push(t);
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>)
        q.pop();
    cout <span style="color:#f92672">&lt;&lt;</span> q.top();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>汉诺塔问题</title>
            <link>https://fffzlfk.gitlab.io/2019/12/20/%C5%B5/</link>
            <pubDate>Fri, 20 Dec 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/12/20/%C5%B5/</guid>
            <description>问题描述 借助堆栈以非递归（循环）方式求解汉诺塔的问题（n, a, b, c），即将N个盘子从起始柱（标记为“a”）通过借助柱（标记为“b”）移动到目标柱（标记为“c”），并保证每个移动符合汉诺塔问题的要求。
输入格式: 输入为一个正整数N，即起始柱上的盘数。
输出格式: 每个操作（移动）占一行，按柱1 -&amp;gt; 柱2的格式输出。
输入样例: 3输出样例: a -&amp;gt; ca -&amp;gt; bc -&amp;gt; ba -&amp;gt; cb -&amp;gt; ab -&amp;gt; ca -&amp;gt; c代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; void move(char a, char b) { printf(&amp;#34;%c -&amp;gt; %c\n&amp;#34;, a, b); } void hanoi(int n, char a, char b, char c) { if (n == 1) move(a, c); else { hanoi(n - 1, a, c, b); move(a, c); hanoi(n - 1, b, a, c); } } int main() { int n; cin &amp;gt;&amp;gt; n; hanoi(n, &amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;); return 0; } </description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>借助堆栈以非递归（循环）方式求解汉诺塔的问题（n, a, b, c），即将N个盘子从起始柱（标记为“a”）通过借助柱（标记为“b”）移动到目标柱（标记为“c”），并保证每个移动符合汉诺塔问题的要求。</p>
<h3 id="输入格式">输入格式:</h3>
<p>输入为一个正整数N，即起始柱上的盘数。</p>
<h3 id="输出格式">输出格式:</h3>
<p>每个操作（移动）占一行，按柱1 -&gt; 柱2的格式输出。</p>
<h3 id="输入样例">输入样例:</h3>
<pre><code>3
</code></pre><h3 id="输出样例">输出样例:</h3>
<pre><code>a -&gt; c
a -&gt; b
c -&gt; b
a -&gt; c
b -&gt; a
b -&gt; c
a -&gt; c
</code></pre><h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">move</span>(<span style="color:#66d9ef">char</span> a, <span style="color:#66d9ef">char</span> b) { printf(<span style="color:#e6db74">&#34;%c -&gt; %c</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, a, b); }

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hanoi</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">char</span> a, <span style="color:#66d9ef">char</span> b, <span style="color:#66d9ef">char</span> c) {
    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
        move(a, c);
    <span style="color:#66d9ef">else</span> {
        hanoi(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, a, c, b);
        move(a, c);
        hanoi(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, b, a, c);
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> n;
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    hanoi(n, <span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;c&#39;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>关键活动</title>
            <link>https://fffzlfk.gitlab.io/2019/12/19/%D8%BC/</link>
            <pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/12/19/%D8%BC/</guid>
            <description>问题描述 假定一个工程项目由一组子任务构成，子任务之间有的可以并行执行，有的必须在完成了其它一些子任务后才能执行。“任务调度”包括一组子任务、以及每个子任务可以执行所依赖的子任务集。
比如完成一个专业的所有课程学习和毕业设计可以看成一个本科生要完成的一项工程，各门课程可以看成是子任务。有些课程可以同时开设，比如英语和C程序设计，它们没有必须先修哪门的约束；有些课程则不可以同时开设，因为它们有先后的依赖关系，比如C程序设计和数据结构两门课，必须先学习前者。
但是需要注意的是，对一组子任务，并不是任意的任务调度都是一个可行的方案。比如方案中存在“子任务A依赖于子任务B，子任务B依赖于子任务C，子任务C又依赖于子任务A”，那么这三个任务哪个都不能先执行，这就是一个不可行的方案。
任务调度问题中，如果还给出了完成每个子任务需要的时间，则我们可以算出完成整个工程需要的最短时间。在这些子任务中，有些任务即使推迟几天完成，也不会影响全局的工期；但是有些任务必须准时完成，否则整个项目的工期就要因此延误，这种任务就叫“关键活动”。
请编写程序判定一个给定的工程项目的任务调度是否可行；如果该调度方案可行，则计算完成整个工程项目需要的最短时间，并输出所有的关键活动。
输入格式: 输入第1行给出两个正整数N(≤100)和M，其中N是任务交接点（即衔接相互依赖的两个子任务的节点，例如：若任务2要在任务1完成后才开始，则两任务之间必有一个交接点）的数量。交接点按1~N编号，M是子任务的数量，依次编号为1~M。随后M行，每行给出了3个正整数，分别是该任务开始和完成涉及的交接点编号以及该任务所需的时间，整数间用空格分隔。
输出格式: 如果任务调度不可行，则输出0；否则第1行输出完成整个工程项目需要的时间，第2行开始输出所有关键活动，每个关键活动占一行，按格式“V-&amp;gt;W”输出，其中V和W为该任务开始和完成涉及的交接点编号。关键活动输出的顺序规则是：任务开始的交接点编号小者优先，起点编号相同时，与输入时任务的顺序相反。
输入样例: 7 81 2 41 3 32 4 53 4 34 5 14 6 65 7 56 7 2输出样例: 171-&amp;gt;22-&amp;gt;44-&amp;gt;66-&amp;gt;7代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int n, m; struct Node { int id; int len; }; vector&amp;lt;Node&amp;gt; G[105]; int ve[105]; int vl[105]; int in[105]; stack&amp;lt;int&amp;gt; S; void read() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); int a, b, c; while (m--) { scanf(&amp;#34;%d%d%d&amp;#34;, &amp;amp;a, &amp;amp;b, &amp;amp;c); Node t; t.</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>假定一个工程项目由一组子任务构成，子任务之间有的可以并行执行，有的必须在完成了其它一些子任务后才能执行。“任务调度”包括一组子任务、以及每个子任务可以执行所依赖的子任务集。</p>
<p>比如完成一个专业的所有课程学习和毕业设计可以看成一个本科生要完成的一项工程，各门课程可以看成是子任务。有些课程可以同时开设，比如英语和C程序设计，它们没有必须先修哪门的约束；有些课程则不可以同时开设，因为它们有先后的依赖关系，比如C程序设计和数据结构两门课，必须先学习前者。</p>
<p>但是需要注意的是，对一组子任务，并不是任意的任务调度都是一个可行的方案。比如方案中存在“子任务A依赖于子任务B，子任务B依赖于子任务C，子任务C又依赖于子任务A”，那么这三个任务哪个都不能先执行，这就是一个不可行的方案。</p>
<p>任务调度问题中，如果还给出了完成每个子任务需要的时间，则我们可以算出完成整个工程需要的最短时间。在这些子任务中，有些任务即使推迟几天完成，也不会影响全局的工期；但是有些任务必须准时完成，否则整个项目的工期就要因此延误，这种任务就叫“关键活动”。</p>
<p>请编写程序判定一个给定的工程项目的任务调度是否可行；如果该调度方案可行，则计算完成整个工程项目需要的最短时间，并输出所有的关键活动。</p>
<h3 id="输入格式">输入格式:</h3>
<p>输入第1行给出两个正整数N(≤100)和M，其中N是任务交接点（即衔接相互依赖的两个子任务的节点，例如：若任务2要在任务1完成后才开始，则两任务之间必有一个交接点）的数量。交接点按1~N编号，M是子任务的数量，依次编号为1~M。随后M行，每行给出了3个正整数，分别是该任务开始和完成涉及的交接点编号以及该任务所需的时间，整数间用空格分隔。</p>
<h3 id="输出格式">输出格式:</h3>
<p>如果任务调度不可行，则输出0；否则第1行输出完成整个工程项目需要的时间，第2行开始输出所有关键活动，每个关键活动占一行，按格式“V-&gt;W”输出，其中V和W为该任务开始和完成涉及的交接点编号。关键活动输出的顺序规则是：任务开始的交接点编号小者优先，起点编号相同时，与输入时任务的顺序相反。</p>
<h3 id="输入样例">输入样例:</h3>
<pre><code>7 8
1 2 4
1 3 3
2 4 5
3 4 3
4 5 1
4 6 6
5 7 5
6 7 2
</code></pre><h3 id="输出样例">输出样例:</h3>
<pre><code>17
1-&gt;2
2-&gt;4
4-&gt;6
6-&gt;7
</code></pre><h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> n, m;

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span> {
    <span style="color:#66d9ef">int</span> id;
    <span style="color:#66d9ef">int</span> len;
};

vector<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;</span> G[<span style="color:#ae81ff">105</span>];
<span style="color:#66d9ef">int</span> ve[<span style="color:#ae81ff">105</span>];
<span style="color:#66d9ef">int</span> vl[<span style="color:#ae81ff">105</span>];
<span style="color:#66d9ef">int</span> in[<span style="color:#ae81ff">105</span>];
stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> S;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read</span>() {
    scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">int</span> a, b, c;
    <span style="color:#66d9ef">while</span> (m<span style="color:#f92672">--</span>) {
        scanf(<span style="color:#e6db74">&#34;%d%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>a, <span style="color:#f92672">&amp;</span>b, <span style="color:#f92672">&amp;</span>c);
        Node t;
        t.id <span style="color:#f92672">=</span> b;
        t.len <span style="color:#f92672">=</span> c;
        G[a].push_back(t);
        in[b]<span style="color:#f92672">++</span>;
    }
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">tp_sort</span>() {
    memset(ve, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(ve));
    queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> Q;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>in[i]) {
            Q.push(i);
        }
    }
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>Q.empty()) {
        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> Q.front();
        Q.pop();
        S.push(t);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">int</span>)G[t].size(); i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">int</span> id <span style="color:#f92672">=</span> G[t][i].id;
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">--</span>in[id] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
                Q.push(id);
            <span style="color:#66d9ef">if</span> (ve[t] <span style="color:#f92672">+</span> G[t][i].len <span style="color:#f92672">&gt;</span> ve[id])
                ve[id] <span style="color:#f92672">=</span> ve[t] <span style="color:#f92672">+</span> G[t][i].len;
        }
    }
    <span style="color:#66d9ef">return</span> ((<span style="color:#66d9ef">int</span>)S.size() <span style="color:#f92672">==</span> n) <span style="color:#f92672">?</span> true <span style="color:#f92672">:</span> false;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">get_path</span>() {
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tp_sort()) {
        puts(<span style="color:#e6db74">&#34;0&#34;</span>);
        <span style="color:#66d9ef">return</span>;
    }
    <span style="color:#66d9ef">int</span> Max <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        Max <span style="color:#f92672">=</span> max(Max, ve[i]);
    }
    fill(vl, vl <span style="color:#f92672">+</span> n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, Max);
    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, Max);
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>S.empty()) {
        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> S.top();
        S.pop();
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">int</span>)G[t].size(); i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">int</span> id <span style="color:#f92672">=</span> G[t][i].id;
            <span style="color:#66d9ef">if</span> (vl[id] <span style="color:#f92672">-</span> G[t][i].len <span style="color:#f92672">&lt;</span> vl[t])
                vl[t] <span style="color:#f92672">=</span> vl[id] <span style="color:#f92672">-</span> G[t][i].len;
        }
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> G[i].size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; j<span style="color:#f92672">--</span>) {
            <span style="color:#66d9ef">int</span> id <span style="color:#f92672">=</span> G[i][j].id;
            <span style="color:#66d9ef">int</span> e <span style="color:#f92672">=</span> ve[i];
            <span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> vl[id] <span style="color:#f92672">-</span> G[i][j].len;
            <span style="color:#66d9ef">if</span> (e <span style="color:#f92672">==</span> l) {
                printf(<span style="color:#e6db74">&#34;%d-&gt;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, id);
            }
        }
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    read();
    get_path();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>求前缀表达式的值</title>
            <link>https://fffzlfk.gitlab.io/2019/12/19/%C7%B0%CA%BD%D6%B5/</link>
            <pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/12/19/%C7%B0%CA%BD%D6%B5/</guid>
            <description>问题描述 算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。前缀表达式指二元运算符位于两个运算数之前，例如2+3*(7-4)+8/4的前缀表达式是：+ + 2 * 3 - 7 4 / 8 4。请设计程序计算前缀表达式的结果值。
输入格式: 输入在一行内给出不超过30个字符的前缀表达式，只包含+、-、*、/以及运算数，不同对象（运算数、运算符号）之间以空格分隔。
输出格式: 输出前缀表达式的运算结果，保留小数点后1位，或错误信息ERROR。
输入样例: + + 2 * 3 - 7 4 / 8 4输出样例: 13.0代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; float calculate(float x, float y, char t) { switch (t) { case &amp;#39;+&amp;#39;: return x + y; break; case &amp;#39;-&amp;#39;: return x - y; break; case &amp;#39;*&amp;#39;: return x * y; break; case &amp;#39;/&amp;#39;: if (y == 0.</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。前缀表达式指二元运算符位于两个运算数之前，例如2+3*(7-4)+8/4的前缀表达式是：+ + 2 * 3 - 7 4 / 8 4。请设计程序计算前缀表达式的结果值。</p>
<h3 id="输入格式">输入格式:</h3>
<p>输入在一行内给出不超过30个字符的前缀表达式，只包含+、-、*、/以及运算数，不同对象（运算数、运算符号）之间以空格分隔。</p>
<h3 id="输出格式">输出格式:</h3>
<p>输出前缀表达式的运算结果，保留小数点后1位，或错误信息ERROR。</p>
<h3 id="输入样例">输入样例:</h3>
<pre><code>+ + 2 * 3 - 7 4 / 8 4
</code></pre><h3 id="输出样例">输出样例:</h3>
<pre><code>13.0
</code></pre><h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">float</span> <span style="color:#a6e22e">calculate</span>(<span style="color:#66d9ef">float</span> x, <span style="color:#66d9ef">float</span> y, <span style="color:#66d9ef">char</span> t) {
    <span style="color:#66d9ef">switch</span> (t) {
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;+&#39;</span><span style="color:#f92672">:</span>
        <span style="color:#66d9ef">return</span> x <span style="color:#f92672">+</span> y;
        <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;-&#39;</span><span style="color:#f92672">:</span>
        <span style="color:#66d9ef">return</span> x <span style="color:#f92672">-</span> y;
        <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;*&#39;</span><span style="color:#f92672">:</span>
        <span style="color:#66d9ef">return</span> x <span style="color:#f92672">*</span> y;
        <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;/&#39;</span><span style="color:#f92672">:</span>
        <span style="color:#66d9ef">if</span> (y <span style="color:#f92672">==</span> <span style="color:#ae81ff">0.0</span>) {
            puts(<span style="color:#e6db74">&#34;ERROR&#34;</span>);
            exit(<span style="color:#ae81ff">0</span>);
        }
        <span style="color:#66d9ef">return</span> x <span style="color:#f92672">/</span> y;
        <span style="color:#66d9ef">break</span>;
    }
}

<span style="color:#66d9ef">float</span> <span style="color:#a6e22e">solve</span>(string str) {
    stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span> S;
    string s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> str.length() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {
        <span style="color:#66d9ef">char</span> c <span style="color:#f92672">=</span> str[i];
        <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39; &#39;</span>) {
            <span style="color:#66d9ef">if</span> (s <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;&#34;</span>) {
                reverse(s.begin(), s.end());
                S.push(stof(s));
                s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
            }
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (isdigit(c) <span style="color:#f92672">||</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;-&#39;</span> <span style="color:#f92672">&amp;&amp;</span> s <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;&#34;</span>)) {
            s <span style="color:#f92672">+=</span> c;
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">if</span> (S.empty()) {
                reverse(s.begin(), s.end());
                <span style="color:#66d9ef">return</span> stof(s);
            }
            <span style="color:#66d9ef">float</span> a <span style="color:#f92672">=</span> S.top();
            S.pop();
            <span style="color:#66d9ef">float</span> b <span style="color:#f92672">=</span> S.top();
            S.pop();
            S.push(calculate(a, b, c));
        }
    }
    <span style="color:#66d9ef">return</span> S.top();
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    string str;
    getline(cin, str);
    <span style="color:#66d9ef">if</span> (str[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;+&#39;</span>) {
        string<span style="color:#f92672">::</span>size_type it <span style="color:#f92672">=</span> str.find(<span style="color:#e6db74">&#39; &#39;</span>);
        <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">==</span> string<span style="color:#f92672">::</span>npos) {
            printf(<span style="color:#e6db74">&#34;%.1f&#34;</span>, stof(str));
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
        }
    }
    <span style="color:#66d9ef">float</span> ans <span style="color:#f92672">=</span> solve(str);
    <span style="color:#66d9ef">if</span> (ans <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0.0</span>)
        printf(<span style="color:#e6db74">&#34;%.1f</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ans);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>部分置信区间总结</title>
            <link>https://fffzlfk.gitlab.io/2019/12/09//</link>
            <pubDate>Mon, 09 Dec 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/12/09//</guid>
            <description>单正态分布均值μ
  σ2已知 $$ (\bar X-\frac{\sigma}{\sqrt{n}}z_{\frac \alpha 2},\bar X+\frac{\sigma}{\sqrt{n}}z_{\frac \alpha 2}) $$
  σ2未知，样本方差S2$$ (\bar X-\frac{S}{\sqrt n}t_\frac \alpha 2 (n-1),\bar X+\frac{S}{\sqrt n}t_\frac \alpha 2 (n-1)) $$
    单正态分布方差σ2  μ已知 $$ (\frac{\sum_{i=1}^n(X_i-\mu)^2}{\chi_{\frac \alpha 2}^2(n)},\frac{\sum_{i=1}^n(X_i-\mu)^2}{\chi_{1-\frac \alpha 2}^2(n)}) $$
  μ未知，样本方差S2已知 $$ (\frac {(n-1)S^2}{\chi _{\frac \alpha 2}^2(n-1)},\frac {(n-1)S^2}{\chi _{1-\frac \alpha 2}^2(n-1)}) $$
    双正态分布μ1-μ2  σ12, σ22已知 $$ (\bar X-\bar Y\pm\sqrt{\frac {\sigma_1^2} {n_1} +\frac {\sigma_2^2} {n_2} }z_{\frac \alpha 2}) $$</description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<ol>
<li>
<p>单正态分布均值μ</p>
<ul>
<li>
<p>σ<!-- raw HTML omitted -->2<!-- raw HTML omitted -->已知
$$
(\bar X-\frac{\sigma}{\sqrt{n}}z_{\frac \alpha 2},\bar X+\frac{\sigma}{\sqrt{n}}z_{\frac \alpha 2})
$$</p>
</li>
<li>
<p>σ<!-- raw HTML omitted -->2<!-- raw HTML omitted -->未知，样本方差S<!-- raw HTML omitted -->2<!-- raw HTML omitted -->
$$
(\bar X-\frac{S}{\sqrt n}t_\frac \alpha 2 (n-1),\bar X+\frac{S}{\sqrt n}t_\frac \alpha 2 (n-1))
$$</p>
</li>
</ul>
</li>
<li>
<p>单正态分布方差σ<!-- raw HTML omitted -->2<!-- raw HTML omitted --></p>
<ul>
<li>
<p>μ已知
$$
(\frac{\sum_{i=1}^n(X_i-\mu)^2}{\chi_{\frac \alpha 2}^2(n)},\frac{\sum_{i=1}^n(X_i-\mu)^2}{\chi_{1-\frac \alpha 2}^2(n)})
$$</p>
</li>
<li>
<p>μ未知，样本方差S<!-- raw HTML omitted -->2<!-- raw HTML omitted -->已知
$$
(\frac {(n-1)S^2}{\chi _{\frac \alpha 2}^2(n-1)},\frac {(n-1)S^2}{\chi _{1-\frac \alpha 2}^2(n-1)})
$$</p>
</li>
</ul>
</li>
<li>
<p>双正态分布μ<!-- raw HTML omitted -->1<!-- raw HTML omitted -->-μ<!-- raw HTML omitted -->2<!-- raw HTML omitted --></p>
<ul>
<li>
<p>σ<!-- raw HTML omitted -->1<!-- raw HTML omitted --><!-- raw HTML omitted -->2<!-- raw HTML omitted -->, σ<!-- raw HTML omitted -->2<!-- raw HTML omitted --><!-- raw HTML omitted -->2<!-- raw HTML omitted -->已知
$$
(\bar X-\bar Y\pm\sqrt{\frac {\sigma_1^2} {n_1} +\frac {\sigma_2^2} {n_2} }z_{\frac \alpha 2})
$$</p>
</li>
<li>
<p>σ<!-- raw HTML omitted -->1<!-- raw HTML omitted --><!-- raw HTML omitted -->2<!-- raw HTML omitted -->= σ<!-- raw HTML omitted -->2<!-- raw HTML omitted --><!-- raw HTML omitted -->2<!-- raw HTML omitted -->未知
$$
(\bar X-\bar Y\pm S_w\sqrt{\frac 1 {n_1}+\frac 1 {n_2}}t_{\frac \alpha 2}(n_1+n_2-2))
$$
其中
$$
S_w=\sqrt{\frac {(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1+n_2-2}}
$$</p>
</li>
</ul>
</li>
<li>
<p>双正态分布σ<!-- raw HTML omitted -->1<!-- raw HTML omitted --><!-- raw HTML omitted -->2<!-- raw HTML omitted --> / σ<!-- raw HTML omitted -->2<!-- raw HTML omitted --><!-- raw HTML omitted -->2<!-- raw HTML omitted --></p>
<ul>
<li>
<p>μ<!-- raw HTML omitted -->1<!-- raw HTML omitted -->，μ<!-- raw HTML omitted -->2<!-- raw HTML omitted -->已知
$$
(\frac {n_2\sum_{i=1}^{n_1}(X_i-\mu_1)^2} {n_1\sum_{i=1}^{n_1}(Y_i-\mu_2)^2}\frac 1 {F_{\frac \alpha 2}(n_1,n_2)},\frac {n_2\sum_{i=1}^{n_1}(X_i-\mu_1)^2} {n_1\sum_{i=1}^{n_1}(Y_i-\mu_2)^2}F_{\frac \alpha 2}(n_2,n_1))
$$</p>
</li>
<li>
<p>μ<!-- raw HTML omitted -->1<!-- raw HTML omitted -->，μ<!-- raw HTML omitted -->2<!-- raw HTML omitted -->未知
$$
(\frac{S_1^2}{S_2^2}\frac 1 {F_{\frac \alpha 2(n_1-1,n_2-1)}},\frac{S_1^2}{S_2^2} {F_{\frac \alpha 2(n_2-1,n_1-1)}})
$$</p>
</li>
</ul>
</li>
</ol>
<h3 id="0---1分布总体参数的置信区间">0 - 1分布总体参数的置信区间</h3>
<ul>
<li>
<p>X~B(1, p), 参数p的置信水平为1-α的置信区间
$$
(\frac 1{2a}(-b-\sqrt{ b^2-4ac}),\frac 1{2a}(-b+\sqrt{ b^2-4ac}))
$$</p>
<p>其中
$$
a = n+z_{\frac \alpha 2}^2, b= -(2n\bar X+z_{\frac \alpha 2}^2),c=n\bar X^2
$$</p>
</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>哥尼斯堡七桥问题</title>
            <link>https://fffzlfk.gitlab.io/2019/12/08/%C4%A1/</link>
            <pubDate>Sun, 08 Dec 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/12/08/%C4%A1/</guid>
            <description>问题描述 哥尼斯堡是位于普累格河上的一座城市，它包含两个岛屿及连接它们的七座桥，如下图所示。
可否走过这样的七座桥，而且每桥只走过一次？瑞士数学家欧拉(Leonhard Euler，1707—1783)最终解决了这个问题，并由此创立了拓扑学。
这个问题如今可以描述为判断欧拉回路是否存在的问题。欧拉回路是指不令笔离开纸面，可画过图中每条边仅一次，且可以回到起点的一条回路。现给定一个无向图，问是否存在欧拉回路？
输入格式: 输入第一行给出两个正整数，分别是节点数N (1≤N≤1000)和边数M；随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个节点的编号（节点从1到N编号）。
输出格式: 若欧拉回路存在则输出1，否则输出0。
样例 输入样例1: 6 101 22 33 14 55 66 41 41 63 43 6输出样例1: 1输入样例2: 5 81 21 32 32 42 55 35 43 4输出样例2: 0代码实现 使用并查集判断连通性 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int n, m; struct { int pre; int dgr = 0; } Node[1005]; int find(int i) { return Node[i].</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>哥尼斯堡是位于普累格河上的一座城市，它包含两个岛屿及连接它们的七座桥，如下图所示。</p>
<p><img src="https://images.ptausercontent.com/51" alt=""></p>
<p>可否走过这样的七座桥，而且每桥只走过一次？瑞士数学家欧拉(Leonhard Euler，1707—1783)最终解决了这个问题，并由此创立了拓扑学。</p>
<p>这个问题如今可以描述为判断欧拉回路是否存在的问题。欧拉回路是指不令笔离开纸面，可画过图中每条边仅一次，且可以回到起点的一条回路。现给定一个无向图，问是否存在欧拉回路？</p>
<h3 id="输入格式">输入格式:</h3>
<p>输入第一行给出两个正整数，分别是节点数N (1≤N≤1000)和边数M；随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个节点的编号（节点从1到N编号）。</p>
<h3 id="输出格式">输出格式:</h3>
<p>若欧拉回路存在则输出1，否则输出0。</p>
<h3 id="样例">样例</h3>
<h5 id="输入样例1">输入样例1:</h5>
<pre><code>6 10
1 2
2 3
3 1
4 5
5 6
6 4
1 4
1 6
3 4
3 6
</code></pre><h5 id="输出样例1">输出样例1:</h5>
<pre><code>1
</code></pre><h5 id="输入样例2">输入样例2:</h5>
<pre><code>5 8
1 2
1 3
2 3
2 4
2 5
5 3
5 4
3 4
</code></pre><h5 id="输出样例2">输出样例2:</h5>
<pre><code>0
</code></pre><h3 id="代码实现">代码实现</h3>
<h5 id="使用并查集判断连通性">使用并查集判断连通性</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> n, m;
<span style="color:#66d9ef">struct</span> {
    <span style="color:#66d9ef">int</span> pre;
    <span style="color:#66d9ef">int</span> dgr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
} Node[<span style="color:#ae81ff">1005</span>];

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> i) {
    <span style="color:#66d9ef">return</span> Node[i].pre <span style="color:#f92672">==</span> i <span style="color:#f92672">?</span> i : Node[i].pre <span style="color:#f92672">=</span> find(Node[i].pre);
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">link</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) {
    Node[a].dgr<span style="color:#f92672">++</span>;
    Node[b].dgr<span style="color:#f92672">++</span>;
    a <span style="color:#f92672">=</span> find(a);
    b <span style="color:#f92672">=</span> find(b);
    <span style="color:#66d9ef">if</span> (a <span style="color:#f92672">!=</span> b) {
        Node[a].pre <span style="color:#f92672">=</span> b;
    }
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">judge</span>() {
    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (Node[i].pre <span style="color:#f92672">==</span> i)
            cnt<span style="color:#f92672">++</span>;
        <span style="color:#66d9ef">if</span> (Node[i].dgr <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>)
            s<span style="color:#f92672">++</span>;
    }
    <span style="color:#66d9ef">return</span> cnt <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> s <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
        Node[i].pre <span style="color:#f92672">=</span> i;
    <span style="color:#66d9ef">int</span> a, b;
    <span style="color:#66d9ef">while</span> (m<span style="color:#f92672">--</span>) {
        scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>a, <span style="color:#f92672">&amp;</span>b);
        link(a, b);
    }
    cout <span style="color:#f92672">&lt;&lt;</span> judge();
}
</code></pre></div><h5 id="dfs判断连通性">dfs判断连通性</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> n, m;

<span style="color:#66d9ef">int</span> arcs[<span style="color:#ae81ff">1005</span>][<span style="color:#ae81ff">1005</span>];
<span style="color:#66d9ef">int</span> dgr[<span style="color:#ae81ff">1005</span>];
<span style="color:#66d9ef">int</span> link[<span style="color:#ae81ff">1005</span>];
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">islink</span>(<span style="color:#66d9ef">int</span> i) {
    link[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (arcs[i][j] <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>link[j])
            islink(j);
    }
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">judge</span>() {
    <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>link[i]) {
            <span style="color:#66d9ef">return</span> false;
        }
        <span style="color:#66d9ef">if</span> (dgr[i] <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>)
            s<span style="color:#f92672">++</span>;
    }
    <span style="color:#66d9ef">return</span> s <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>) {
        puts(<span style="color:#e6db74">&#34;1&#34;</span>);
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }
    <span style="color:#66d9ef">int</span> a, b;
    <span style="color:#66d9ef">while</span> (m<span style="color:#f92672">--</span>) {
        scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>a, <span style="color:#f92672">&amp;</span>b);
        arcs[a][b] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        arcs[b][a] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        dgr[a]<span style="color:#f92672">++</span>;
        dgr[b]<span style="color:#f92672">++</span>;
    }
    islink(<span style="color:#ae81ff">1</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> judge();
}
</code></pre></div><h5 id="运行时间对比">运行时间对比</h5>
<ol>
<li>并查集
<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li>dfs
<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></li>
</ol>
<p>时间限制: 400 ms
内存限制: 64 MB
代码长度限制: 16 KB</p>
]]></content>
        </item>
        
        <item>
            <title>堆中的路径</title>
            <link>https://fffzlfk.gitlab.io/2019/12/05/%D0%B5/</link>
            <pubDate>Thu, 05 Dec 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/12/05/%D0%B5/</guid>
            <description>问题描述 将一系列给定数字插入一个初始为空的小顶堆H[]。随后对任意给定的下标i，打印从H[i]到根结点的路径。
输入格式: 每组测试第1行包含2个正整数N和M(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的N个要被插入一个初始为空的小顶堆的整数。最后一行给出M个下标。
输出格式: 对输入中给出的每个下标i，在一行中输出从H[i]到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。
输入样例: 5 346 23 26 24 105 4 3输出样例: 24 23 1046 23 1026 10代码实现 #include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std; int n; int m; int h[1005]; int s = 0; void add(int k) { s++; int i; for (i = s; h[i / 2] &amp;gt; k; i /= 2) h[i] = h[i / 2]; h[i] = k; } int main() { cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; int t; int N = n; h[0] = -10001; //注意h[0]要很小，否则会进入死循环  while (N--) { cin &amp;gt;&amp;gt; t; add(t); } while (m--) { cin &amp;gt;&amp;gt; t; while (t !</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>将一系列给定数字插入一个初始为空的小顶堆H[]。随后对任意给定的下标i，打印从H[i]到根结点的路径。</p>
<h3 id="输入格式">输入格式:</h3>
<p>每组测试第1行包含2个正整数N和M(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的N个要被插入一个初始为空的小顶堆的整数。最后一行给出M个下标。</p>
<h3 id="输出格式">输出格式:</h3>
<p>对输入中给出的每个下标i，在一行中输出从H[i]到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。</p>
<h3 id="输入样例">输入样例:</h3>
<pre><code>5 3
46 23 26 24 10
5 4 3
</code></pre><h3 id="输出样例">输出样例:</h3>
<pre><code>24 23 10
46 23 10
26 10
</code></pre><h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> n;
<span style="color:#66d9ef">int</span> m;
<span style="color:#66d9ef">int</span> h[<span style="color:#ae81ff">1005</span>];
<span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> k) {
    s<span style="color:#f92672">++</span>;
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> s; h[i <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>] <span style="color:#f92672">&gt;</span> k; i <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>)
        h[i] <span style="color:#f92672">=</span> h[i <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>];
    h[i] <span style="color:#f92672">=</span> k;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
    <span style="color:#66d9ef">int</span> t;
    <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> n;
    h[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">10001</span>;  <span style="color:#75715e">//注意h[0]要很小，否则会进入死循环
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (N<span style="color:#f92672">--</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> t;
        add(t);
    }
    <span style="color:#66d9ef">while</span> (m<span style="color:#f92672">--</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> t;
        <span style="color:#66d9ef">while</span> (t <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) {
            printf(<span style="color:#e6db74">&#34;%d &#34;</span>, h[t]);
            t <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
        }
        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, h[t]);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>希尔排序&amp;快排&amp;堆排序</title>
            <link>https://fffzlfk.gitlab.io/2019/12/04//</link>
            <pubDate>Wed, 04 Dec 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/12/04//</guid>
            <description>希尔排序 算法描述 代码实现 #include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std; void ShellInsert(vector&amp;lt;int&amp;gt; &amp;amp;L, int dk) { for (int i = dk; i &amp;lt; L.size(); i++) { int j; int tmp; if (L[i] &amp;lt; L[i - dk]) { tmp = L[i]; // 暂存  for (j = i - dk; j &amp;gt; 0 &amp;amp;&amp;amp; L[j] &amp;gt; tmp; j -= dk) L[j + dk] = L[j]; //向后移动到插入位置  L[j + dk] = tmp; //插入  } } } void ShellSort(vector&amp;lt;int&amp;gt; &amp;amp;L, int dlta[], int t) { for (int k = 0; k &amp;lt; t; k++) ShellInsert(L, dlta[k]); } int main(int argc, char const *argv[]) { vector&amp;lt;int&amp;gt; L = {0, 3, 1, 4, 7, 4, 2, 9}; int dlta[] = {3, 2, 1}; ShellSort(L, dlta, 3); vector&amp;lt;int&amp;gt;::iterator it = L.</description>
            <content type="html"><![CDATA[<h3 id="希尔排序">希尔排序</h3>
<h5 id="算法描述">算法描述</h5>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="代码实现">代码实现</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ShellInsert</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>L, <span style="color:#66d9ef">int</span> dk) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> dk; i <span style="color:#f92672">&lt;</span> L.size(); i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">int</span> j;
        <span style="color:#66d9ef">int</span> tmp;
        <span style="color:#66d9ef">if</span> (L[i] <span style="color:#f92672">&lt;</span> L[i <span style="color:#f92672">-</span> dk]) {
            tmp <span style="color:#f92672">=</span> L[i]; <span style="color:#75715e">// 暂存
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> dk; j <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> L[j] <span style="color:#f92672">&gt;</span> tmp; j <span style="color:#f92672">-=</span> dk)
                L[j <span style="color:#f92672">+</span> dk] <span style="color:#f92672">=</span> L[j]; <span style="color:#75715e">//向后移动到插入位置
</span><span style="color:#75715e"></span>            L[j <span style="color:#f92672">+</span> dk] <span style="color:#f92672">=</span> tmp;      <span style="color:#75715e">//插入
</span><span style="color:#75715e"></span>        }
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ShellSort</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>L, <span style="color:#66d9ef">int</span> dlta[], <span style="color:#66d9ef">int</span> t) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k <span style="color:#f92672">&lt;</span> t; k<span style="color:#f92672">++</span>)
        ShellInsert(L, dlta[k]);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> L <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">9</span>};
    <span style="color:#66d9ef">int</span> dlta[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>};
    ShellSort(L, dlta, <span style="color:#ae81ff">3</span>);
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> L.begin();
    <span style="color:#66d9ef">for</span> (; it <span style="color:#f92672">!=</span> L.end(); it<span style="color:#f92672">++</span>)
        printf(<span style="color:#e6db74">&#34;%d &#34;</span>, <span style="color:#f92672">*</span>it);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="快排">快排</h3>
<h5 id="算法描述-1">算法描述</h5>
<p>方法其实很简单：分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从右往左找一个小于 6 的数，再从左往右找一个大于 6 的数，然后交换他们。这里可以用两个变量 i 和 j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵 i”和“哨兵 j”。刚开始的时候让哨兵 i 指向序列的最左边（即 i=1），指向数字 6。让哨兵 j 指向序列的最右边（即 j=10），指向数字 8。
<img src="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/3.1.png" alt=""></p>
<p>首先哨兵 j 开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵 j 先出动，这一点非常重要（请自己想一想为什么）。哨兵 j 一步一步地向左挪动（即 j&ndash;），直到找到一个小于 6 的数停下来。接下来哨兵 i 再一步一步向右挪动（即 i++），直到找到一个数大于 6 的数停下来。最后哨兵 j 停在了数字 5 面前，哨兵 i 停在了数字 7 面前。</p>
<p><img src="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/3.2.png" alt="">
<img src="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/3.3.png" alt="">
现在交换哨兵 i 和哨兵 j 所指向的元素的值。交换之后的序列如下。</p>
<pre><code>6 1 2 5 9 3 4 7 10 8
</code></pre><p><img src="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/3.4.png" alt="">
<img src="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/3.5.png" alt=""></p>
<p>到此，第一次交换结束。接下来开始哨兵 j 继续向左挪动（再友情提醒，每次必须是哨兵 j 先出发）。他发现了 4（比基准数 6 要小，满足要求）之后停了下来。哨兵 i 也继续向右挪动的，他发现了 9（比基准数 6 要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下。</p>
<pre><code>6 1 2 5 4 3 9 7 10 8
</code></pre><p>第二次交换结束，“探测”继续。哨兵 j 继续向左挪动，他发现了 3（比基准数 6 要小，满足要求）之后又停了下来。哨兵 i 继续向右移动，糟啦！此时哨兵 i 和哨兵 j 相遇了，哨兵 i 和哨兵 j 都走到 3 面前。说明此时“探测”结束。我们将基准数 6 和 3 进行交换。交换之后的序列如下。</p>
<pre><code>3 1 2 5 4 6 9 7 10 8
</code></pre><p><img src="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/3.6.png" alt=""></p>
<p><img src="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/3.7.png" alt="">
<img src="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/3.8.png" alt=""></p>
<p>到此第一轮“探测”真正结束。此时以基准数 6 为分界点，6 左边的数都小于等于 6，6 右边的数都大于等于 6。回顾一下刚才的过程，其实哨兵 j 的使命就是要找小于基准数的数，而哨兵 i 的使命就是要找大于基准数的数，直到 i 和 j 碰头为止。</p>
<h5 id="代码实现-1">代码实现</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Partition</span>(<span style="color:#66d9ef">int</span> L[], <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high) {
    L[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> L[low];
    <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;</span> high) {
        <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;</span> high <span style="color:#f92672">&amp;&amp;</span> L[high] <span style="color:#f92672">&gt;=</span> L[<span style="color:#ae81ff">0</span>])
            <span style="color:#f92672">--</span>high;
        L[low] <span style="color:#f92672">=</span> L[high];
        <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;</span> high <span style="color:#f92672">&amp;&amp;</span> L[low] <span style="color:#f92672">&lt;=</span> L[<span style="color:#ae81ff">0</span>])
            <span style="color:#f92672">++</span>low;
        L[high] <span style="color:#f92672">=</span> L[low];
    }
    L[low] <span style="color:#f92672">=</span> L[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">return</span> low;
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">QSort</span>(<span style="color:#66d9ef">int</span> L[], <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high) {
    <span style="color:#66d9ef">if</span> (low <span style="color:#f92672">&lt;</span> high) {
        <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> Partition(L, low, high);
        QSort(L, low, p <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
        QSort(L, p <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, high);
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> l[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">9</span>};
    QSort(l, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">8</span>);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">8</span>; i<span style="color:#f92672">++</span>)
        printf(<span style="color:#e6db74">&#34;%d &#34;</span>, l[i]);
}
</code></pre></div><h3 id="堆排序">堆排序</h3>
<h5 id="算法描述-2">算法描述</h5>
<p><img src="https://pic3.zhimg.com/v2-96d015c3735bf3b996043e29d4a0fc96_b.webp" alt=""></p>
<h5 id="代码实现-2">代码实现</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">heapAdjust</span>(<span style="color:#66d9ef">int</span> heap[], <span style="color:#66d9ef">int</span> s, <span style="color:#66d9ef">int</span> m) {
    <span style="color:#66d9ef">int</span> rc <span style="color:#f92672">=</span> heap[s]; <span style="color:#75715e">//使heap[s..m]成为一个大顶堆
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> s; j <span style="color:#f92672">&lt;=</span> m; j <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>) {
        <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">&lt;</span> m <span style="color:#f92672">&amp;&amp;</span> (heap[j] <span style="color:#f92672">&lt;</span> heap[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]))
            <span style="color:#f92672">++</span>j; <span style="color:#75715e">// j为较大位置
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (rc <span style="color:#f92672">&gt;=</span> heap[j])
            <span style="color:#66d9ef">break</span>;
        heap[s] <span style="color:#f92672">=</span> heap[j];
        s <span style="color:#f92672">=</span> j;
    }
    heap[s] <span style="color:#f92672">=</span> rc;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">heapSort</span>(<span style="color:#66d9ef">int</span> heap[], <span style="color:#66d9ef">int</span> n) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>)
        heapAdjust(heap, i, n); <span style="color:#75715e">//把heap[1..n]构建为大顶堆
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n; i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">--</span>) {
        swap(heap[<span style="color:#ae81ff">1</span>], heap[i]);
        heapAdjust(heap, <span style="color:#ae81ff">1</span>, i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> h[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">1</span>};
    heapSort(h, <span style="color:#ae81ff">7</span>);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">7</span>; i<span style="color:#f92672">++</span>) {
        printf(<span style="color:#e6db74">&#34;%d &#34;</span>, h[i]);
    }
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>让课代表收作业变得更简单</title>
            <link>https://fffzlfk.gitlab.io/2019/12/02/%CA%BC/</link>
            <pubDate>Mon, 02 Dec 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/12/02/%CA%BC/</guid>
            <description>前期准备  一个邮箱地址和密码 Python3环境  教程  在邮箱设置里开启pop 安装xlwt和xlrd  pip3 install xlwt pip3 install xlrd 将下面代码中的邮件地址, 口令和POP3服务器地址改为你所对应的；并指定att_file(存储路径)。  #!/usr/bin/env python3 # -*- coding: utf-8 -*- import poplib import email import datetime import time import os import xlrd import xlwt from email.parser import Parser from email.header import decode_header from email.utils import parseaddr # 输入邮件地址, 口令和POP3服务器地址: email = &amp;#39;***@163.com&amp;#39; password = &amp;#39;********&amp;#39; pop3_server = &amp;#39;pop.163.com&amp;#39; def decode_str(s): #字符编码转换 value, charset = decode_header(s)[0] if charset: value = value.</description>
            <content type="html"><![CDATA[<h3 id="前期准备">前期准备</h3>
<ol>
<li>一个邮箱地址和密码</li>
<li>Python3环境</li>
</ol>
<h3 id="教程">教程</h3>
<ol>
<li>在邮箱设置里开启pop</li>
<li>安装xlwt和xlrd</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">pip3 install xlwt
pip3 install xlrd
</code></pre></div><ol start="3">
<li>将下面代码中的邮件地址, 口令和POP3服务器地址改为你所对应的；并指定att_file(存储路径)。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#!/usr/bin/env python3</span>
<span style="color:#75715e"># -*- coding: utf-8 -*-</span>
<span style="color:#f92672">import</span> poplib
<span style="color:#f92672">import</span> email
<span style="color:#f92672">import</span> datetime
<span style="color:#f92672">import</span> time
<span style="color:#f92672">import</span> os
<span style="color:#f92672">import</span> xlrd
<span style="color:#f92672">import</span> xlwt
<span style="color:#f92672">from</span> email.parser <span style="color:#f92672">import</span> Parser
<span style="color:#f92672">from</span> email.header <span style="color:#f92672">import</span> decode_header
<span style="color:#f92672">from</span> email.utils <span style="color:#f92672">import</span> parseaddr
<span style="color:#75715e"># 输入邮件地址, 口令和POP3服务器地址:</span>
email <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;***@163.com&#39;</span>
password <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;********&#39;</span>
pop3_server <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;pop.163.com&#39;</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decode_str</span>(s): <span style="color:#75715e">#字符编码转换</span>
    value, charset <span style="color:#f92672">=</span> decode_header(s)[<span style="color:#ae81ff">0</span>]
    <span style="color:#66d9ef">if</span> charset:
        value <span style="color:#f92672">=</span> value<span style="color:#f92672">.</span>decode(charset)
    <span style="color:#66d9ef">return</span> value
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_att</span>(msg):
    <span style="color:#f92672">import</span> email
    attachment_files <span style="color:#f92672">=</span> []

    <span style="color:#66d9ef">for</span> part <span style="color:#f92672">in</span> msg<span style="color:#f92672">.</span>walk():
        file_name <span style="color:#f92672">=</span> part<span style="color:#f92672">.</span>get_filename()<span style="color:#75715e">#获取附件名称类型</span>
        contType <span style="color:#f92672">=</span> part<span style="color:#f92672">.</span>get_content_type()

        <span style="color:#66d9ef">if</span> file_name:
            h <span style="color:#f92672">=</span> email<span style="color:#f92672">.</span>header<span style="color:#f92672">.</span>Header(file_name)
            dh <span style="color:#f92672">=</span> email<span style="color:#f92672">.</span>header<span style="color:#f92672">.</span>decode_header(h)<span style="color:#75715e">#对附件名称进行解码</span>
            filename <span style="color:#f92672">=</span> dh[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>]
            <span style="color:#66d9ef">if</span> dh[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>]:
                filename <span style="color:#f92672">=</span> decode_str(str(filename,dh[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>]))<span style="color:#75715e">#将附件名称可读化</span>
                <span style="color:#66d9ef">print</span>(filename)
                <span style="color:#75715e">#filename = filename.encode(&#34;utf-8&#34;)</span>
            data <span style="color:#f92672">=</span> part<span style="color:#f92672">.</span>get_payload(decode<span style="color:#f92672">=</span>True)<span style="color:#75715e">#下载附件</span>
            att_file <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#39;/home/mail/test/&#39;</span> <span style="color:#f92672">+</span> filename, <span style="color:#e6db74">&#39;wb&#39;</span>)<span style="color:#75715e">#在指定目录下创建文件，注意二进制文件需要用wb模式打开</span>
            attachment_files<span style="color:#f92672">.</span>append(filename)
            att_file<span style="color:#f92672">.</span>write(data)<span style="color:#75715e">#保存附件</span>
            att_file<span style="color:#f92672">.</span>close()
    <span style="color:#66d9ef">return</span> attachment_files
<span style="color:#75715e"># 连接到POP3服务器,有些邮箱服务器需要ssl加密，对于不需要加密的服务器可以使用poplib.POP3()</span>
server <span style="color:#f92672">=</span> poplib<span style="color:#f92672">.</span>POP3_SSL(pop3_server)
server<span style="color:#f92672">.</span>set_debuglevel(<span style="color:#ae81ff">1</span>)
<span style="color:#75715e"># 打印POP3服务器的欢迎文字:</span>
<span style="color:#66d9ef">print</span>(server<span style="color:#f92672">.</span>getwelcome()<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;utf-8&#39;</span>))
<span style="color:#75715e"># 身份认证:</span>
server<span style="color:#f92672">.</span>user(email)
server<span style="color:#f92672">.</span>pass_(password)
<span style="color:#75715e"># 返回邮件数量和占用空间:</span>
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Messages: </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">. Size: </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> server<span style="color:#f92672">.</span>stat())
<span style="color:#75715e"># list()返回所有邮件的编号:</span>
resp, mails, octets <span style="color:#f92672">=</span> server<span style="color:#f92672">.</span>list()
<span style="color:#75715e"># 可以查看返回的列表类似[b&#39;1 82923&#39;, b&#39;2 2184&#39;, ...]</span>
<span style="color:#66d9ef">print</span>(mails)
index <span style="color:#f92672">=</span> len(mails)
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(index,<span style="color:#ae81ff">0</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
    <span style="color:#75715e">#倒序遍历邮件</span>
    resp, lines, octets <span style="color:#f92672">=</span> server<span style="color:#f92672">.</span>retr(i)
    <span style="color:#75715e"># lines存储了邮件的原始文本的每一行,</span>
    <span style="color:#75715e">#邮件的原始文本:</span>
    msg_content <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#39;</span><span style="color:#f92672">.</span>join(lines)<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;utf-8&#39;</span>)
    <span style="color:#75715e">#解析邮件:</span>
    msg <span style="color:#f92672">=</span> Parser()<span style="color:#f92672">.</span>parsestr(msg_content)
    <span style="color:#75715e">#获取邮件时间</span>
    date1 <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>strptime(msg<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#34;Date&#34;</span>)[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">24</span>],<span style="color:#e6db74">&#39;%a, </span><span style="color:#e6db74">%d</span><span style="color:#e6db74"> %b %Y %H:%M:%S&#39;</span>) <span style="color:#75715e">#格式化收件时间</span>
    date2 <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>strftime(<span style="color:#e6db74">&#34;%Y%m</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, date1)<span style="color:#75715e">#邮件时间格式转换</span>
    <span style="color:#66d9ef">if</span> (date2<span style="color:#f92672">&lt;</span><span style="color:#e6db74">&#39;20180306&#39;</span>)<span style="color:#f92672">|</span>(date2<span style="color:#f92672">&gt;</span><span style="color:#e6db74">&#39;20200314&#39;</span>):

        <span style="color:#66d9ef">continue</span>
    f_list <span style="color:#f92672">=</span> get_att(msg)<span style="color:#75715e">#获取附件</span>

    <span style="color:#75715e">#print_info(msg)</span>
server<span style="color:#f92672">.</span>quit()
</code></pre></div><ol start="4">
<li>运行此脚本。</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>二叉排序树的合并</title>
            <link>https://fffzlfk.gitlab.io/2019/12/01/%CF%B2/</link>
            <pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/12/01/%CF%B2/</guid>
            <description>问题描述 试编写程序，将两棵二叉排序树合并为一棵二叉排序树。
输入格式 按照先序序列，分两行输入两棵二叉排序树各结点（结点值大于0），其中-1表示取消建立子树结点。
输出格式 按照中序序列输出合并后的二叉排序树。
输入样例 12 8 4 -1 -1 10 -1 -1 16 13 -1 -1 18 -1 -117 6 2 -1 -1 9 -1 -1 24 19 -1 -1 26 -1 -1输出样例 2 4 6 8 9 10 12 13 16 17 18 19 24 26代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; struct TreeNode { int data; TreeNode *left; TreeNode *right; TreeNode(int n) : data(n) {} }; void createBTree(TreeNode *&amp;amp;root) { int t; scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); if (t !</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>试编写程序，将两棵二叉排序树合并为一棵二叉排序树。</p>
<h3 id="输入格式">输入格式</h3>
<p>按照先序序列，分两行输入两棵二叉排序树各结点（结点值大于0），其中-1表示取消建立子树结点。</p>
<h3 id="输出格式">输出格式</h3>
<p>按照中序序列输出合并后的二叉排序树。</p>
<h3 id="输入样例">输入样例</h3>
<pre><code>12 8 4 -1 -1 10 -1 -1 16 13 -1 -1 18 -1 -1
17 6 2 -1 -1 9 -1 -1 24 19 -1 -1 26 -1 -1
</code></pre><h3 id="输出样例">输出样例</h3>
<pre><code>2 4 6 8 9 10 12 13 16 17 18 19 24 26
</code></pre><h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TreeNode</span> {
    <span style="color:#66d9ef">int</span> data;
    TreeNode <span style="color:#f92672">*</span>left;
    TreeNode <span style="color:#f92672">*</span>right;
    TreeNode(<span style="color:#66d9ef">int</span> n) <span style="color:#f92672">:</span> data(n) {}
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">createBTree</span>(TreeNode <span style="color:#f92672">*&amp;</span>root) {
    <span style="color:#66d9ef">int</span> t;
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>t);
    <span style="color:#66d9ef">if</span> (t <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
        root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode(t);
        createBTree(root<span style="color:#f92672">-&gt;</span>left);
        createBTree(root<span style="color:#f92672">-&gt;</span>right);
    } <span style="color:#66d9ef">else</span> {
        root <span style="color:#f92672">=</span> NULL;
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">inOrder</span>(TreeNode <span style="color:#f92672">*</span>root) {
    <span style="color:#66d9ef">if</span> (root) {
        inOrder(root<span style="color:#f92672">-&gt;</span>left);
        printf(<span style="color:#e6db74">&#34;%d &#34;</span>, root<span style="color:#f92672">-&gt;</span>data);
        inOrder(root<span style="color:#f92672">-&gt;</span>right);
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">return</span>;
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(TreeNode <span style="color:#f92672">*&amp;</span>root, <span style="color:#66d9ef">int</span> d) {
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>root) {
        root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode(d);
        root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> NULL;
        root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> NULL;
        <span style="color:#66d9ef">return</span>;
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">==</span> d)
            <span style="color:#66d9ef">return</span>;
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ((root<span style="color:#f92672">-&gt;</span>data) <span style="color:#f92672">&gt;</span> d) {
            insert((root<span style="color:#f92672">-&gt;</span>left), d);
        } <span style="color:#66d9ef">else</span> {
            insert((root<span style="color:#f92672">-&gt;</span>right), d);
        }
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mergeTree</span>(TreeNode <span style="color:#f92672">*&amp;</span>a, TreeNode <span style="color:#f92672">*</span>b) {
    <span style="color:#66d9ef">if</span> (b) {
        mergeTree(a, b<span style="color:#f92672">-&gt;</span>left);
        insert(a, b<span style="color:#f92672">-&gt;</span>data);
        mergeTree(a, b<span style="color:#f92672">-&gt;</span>right);
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// int start = clock();
</span><span style="color:#75715e"></span>    TreeNode <span style="color:#f92672">*</span>a;
    TreeNode <span style="color:#f92672">*</span>b;
    createBTree(a);
    createBTree(b);
    mergeTree(a, b);
    inOrder(a);
    <span style="color:#66d9ef">int</span> end <span style="color:#f92672">=</span> clock();
    <span style="color:#75715e">// printf(&#34;\n%d\n&#34;, end - start);
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>哈希表设计</title>
            <link>https://fffzlfk.gitlab.io/2019/12/01/%CF%A3/</link>
            <pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/12/01/%CF%A3/</guid>
            <description>问题描述 针对某个集体（比如你所在的班级）中的“人名”设计一个哈希表，使得平均查找长度不超过R，完成相应的建表和查表程序。
基本要求 假设人名为中国人姓名的汉语拼音形式。待填入哈希表的人名共有30个，取平均查找长度的上限为2。哈希函数用除留余数法构造，用伪随机探测再散列发处理冲突。
代码实现 #include &amp;lt;iostream&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;using namespace std; #define M 50 struct name { char str[20]; int value; } Name[30]; struct hash { char name[20]; int key; int sum; int flag; } HashList[M]; void init() { FILE *fp; fp = fopen(&amp;#34;text.txt&amp;#34;, &amp;#34;r&amp;#34;); for (int i = 0; i &amp;lt; 30; i++) { fgets(Name[i].str, 20, fp); int j = 0; for (; Name[i].str[j] != &amp;#39;\n&amp;#39;; j++) ; Name[i].</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>针对某个集体（比如你所在的班级）中的“人名”设计一个哈希表，使得平均查找长度不超过R，完成相应的建表和查表程序。</p>
<h3 id="基本要求">基本要求</h3>
<p>假设人名为中国人姓名的汉语拼音形式。待填入哈希表的人名共有30个，取平均查找长度的上限为2。哈希函数用除留余数法构造，用伪随机探测再散列发处理冲突。</p>
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">#define M 50
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">name</span> {
    <span style="color:#66d9ef">char</span> str[<span style="color:#ae81ff">20</span>];
    <span style="color:#66d9ef">int</span> value;
} Name[<span style="color:#ae81ff">30</span>];

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">hash</span> {
    <span style="color:#66d9ef">char</span> name[<span style="color:#ae81ff">20</span>];
    <span style="color:#66d9ef">int</span> key;
    <span style="color:#66d9ef">int</span> sum;
    <span style="color:#66d9ef">int</span> flag;
} HashList[M];

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>() {
    FILE <span style="color:#f92672">*</span>fp;
    fp <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;text.txt&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">30</span>; i<span style="color:#f92672">++</span>) {
        fgets(Name[i].str, <span style="color:#ae81ff">20</span>, fp);
        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> (; Name[i].str[j] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\n&#39;</span>; j<span style="color:#f92672">++</span>)
            ;
        Name[i].str[j] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
    }
    fclose(fp);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">30</span>; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; Name[i].str[j] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\0&#39;</span>; j<span style="color:#f92672">++</span>) {
            s <span style="color:#f92672">+=</span> Name[i].str[j];
        }
        Name[i].value <span style="color:#f92672">=</span> s;
        printf(<span style="color:#e6db74">&#34;%s %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, Name[i].str, Name[i].value);
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">createHashList</span>() {
    <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> M; i<span style="color:#f92672">++</span>) {
        HashList[i].key <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        strcpy(HashList[i].name, <span style="color:#e6db74">&#34;&#34;</span>);
        HashList[i].sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        HashList[i].flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    }

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">30</span>; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">int</span> adr <span style="color:#f92672">=</span> Name[i].value <span style="color:#f92672">%</span> <span style="color:#ae81ff">47</span>;
        <span style="color:#66d9ef">int</span> next_adr <span style="color:#f92672">=</span> adr;
        <span style="color:#66d9ef">if</span> (HashList[adr].flag <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            printf(<span style="color:#e6db74">&#34;adr: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, adr);
            HashList[adr].key <span style="color:#f92672">=</span> Name[i].value;
            strcpy(HashList[adr].name, Name[i].str);
            HashList[adr].flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            HashList[adr].sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">do</span> {
                count<span style="color:#f92672">++</span>;
                next_adr <span style="color:#f92672">=</span> (next_adr <span style="color:#f92672">+</span> (Name[i].value <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">47</span>;
            } <span style="color:#66d9ef">while</span> (HashList[next_adr].flag);
            printf(<span style="color:#e6db74">&#34;adr: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, next_adr);
            HashList[next_adr].key <span style="color:#f92672">=</span> Name[i].value;
            strcpy(HashList[next_adr].name, Name[i].str);
            HashList[next_adr].flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            HashList[next_adr].sum <span style="color:#f92672">=</span> count <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        }
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">searchHash</span>() {
    <span style="color:#66d9ef">char</span> name[<span style="color:#ae81ff">20</span>];
    <span style="color:#66d9ef">int</span> value <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    puts(<span style="color:#e6db74">&#34;请输入要查找人的姓名&#34;</span>);
    cin.getline(name, <span style="color:#ae81ff">20</span>);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">int</span>)strlen(name); i<span style="color:#f92672">++</span>)
        value <span style="color:#f92672">+=</span> name[i];
    <span style="color:#66d9ef">int</span> adr <span style="color:#f92672">=</span> value <span style="color:#f92672">%</span> <span style="color:#ae81ff">47</span>;
    <span style="color:#66d9ef">int</span> next_adr <span style="color:#f92672">=</span> adr;
    <span style="color:#66d9ef">if</span> (strcmp(HashList[adr].name, name) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        printf(<span style="color:#e6db74">&#34;姓名：%s 关键字：%d 查找长度：%d&#34;</span>, HashList[adr].name,
               HashList[adr].key, HashList[adr].sum);
        <span style="color:#66d9ef">return</span>;
    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (HashList[adr].sum <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        printf(<span style="color:#e6db74">&#34;没有该人</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">do</span> {
            next_adr <span style="color:#f92672">=</span> (next_adr <span style="color:#f92672">+</span> ((value <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">%</span> <span style="color:#ae81ff">47</span>;
            <span style="color:#66d9ef">if</span> ((HashList[next_adr].flag <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>))
                <span style="color:#66d9ef">break</span>;
        } <span style="color:#66d9ef">while</span> (strcmp(HashList[next_adr].name, name) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>);
        <span style="color:#66d9ef">if</span> (HashList[next_adr].flag)
            printf(<span style="color:#e6db74">&#34;姓名：%s 关键字：%d 查找长度：%d&#34;</span>, HashList[next_adr].name,
                   HashList[next_adr].key, HashList[next_adr].sum);
        <span style="color:#66d9ef">else</span>
            printf(<span style="color:#e6db74">&#34;没有该人</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">show</span>() {
    <span style="color:#66d9ef">float</span> ave;
    puts(<span style="color:#e6db74">&#34;地址</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">关键字</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">查找长度</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">姓名&#34;</span>);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> M; i<span style="color:#f92672">++</span>) {
        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, HashList[i].key, HashList[i].sum,
               HashList[i].name);
        ave <span style="color:#f92672">+=</span> HashList[i].sum;
    }
    ave <span style="color:#f92672">/=</span> <span style="color:#ae81ff">30</span>;
    printf(<span style="color:#e6db74">&#34;平均查找长度为%.3f</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ave);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    init();
    createHashList();
    show();
    searchHash();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>六度空间</title>
            <link>https://fffzlfk.gitlab.io/2019/11/29/%C8%BF%D5%BC/</link>
            <pubDate>Fri, 29 Nov 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/11/29/%C8%BF%D5%BC/</guid>
            <description>问题描述 “六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。
“六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。
假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。
输入格式: 输入第1行给出两个正整数，分别表示社交网络图的结点数N（1&amp;lt;N≤1000​ ，表示人数）、边数M≤33×N，表示社交关系数）。随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到N编号）。
输出格式: 对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。
输入样例: 10 91 22 33 44 55 66 77 88 99 10输出样例: 1: 70.00%2: 80.00%3: 90.00%4: 100.00%5: 100.00%6: 100.00%7: 100.00%8: 90.00%9: 80.00%10: 70.00%代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int n, m; int arcs[1005][1005]; int d[1005][1005]; void read() { cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; int a, b; for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= n; j++) arcs[i][j] = 2005; } while (m--) { cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; arcs[a][b] = 1; arcs[b][a] = 1; } } void solve() { for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= n; j++) { d[i][j] = arcs[i][j]; } } for (int i = 1; i &amp;lt;= n; i++) d[i][i] = 0; for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= n; j++) { for (int k = 1; k &amp;lt;= n; k++) { d[j][k] = min(d[j][i] + d[i][k], d[j][k]); } } } } void print() { for (int i = 1; i &amp;lt;= n; i++) { double count = 0; for (int j = 1; j &amp;lt;= n; j++) { if (d[i][j] &amp;lt;= 6) count++; } printf(&amp;#34;%d: %.</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。</p>
<p><img src="https://images.ptausercontent.com/35" alt="图1 六度空间示意图"></p>
<p>“六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。</p>
<p><strong>假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。</strong></p>
<h3 id="输入格式">输入格式:</h3>
<p>输入第1行给出两个正整数，分别表示社交网络图的结点数N（1&lt;N≤1000​ ，表示人数）、边数M≤33×N，表示社交关系数）。随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到N编号）。</p>
<h3 id="输出格式">输出格式:</h3>
<p>对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。</p>
<h3 id="输入样例">输入样例:</h3>
<pre><code>10 9
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10
</code></pre><h3 id="输出样例">输出样例:</h3>
<pre><code>1: 70.00%
2: 80.00%
3: 90.00%
4: 100.00%
5: 100.00%
6: 100.00%
7: 100.00%
8: 90.00%
9: 80.00%
10: 70.00%
</code></pre><h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> n, m;
<span style="color:#66d9ef">int</span> arcs[<span style="color:#ae81ff">1005</span>][<span style="color:#ae81ff">1005</span>];
<span style="color:#66d9ef">int</span> d[<span style="color:#ae81ff">1005</span>][<span style="color:#ae81ff">1005</span>];
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
    <span style="color:#66d9ef">int</span> a, b;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>)
            arcs[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2005</span>;
    }
    <span style="color:#66d9ef">while</span> (m<span style="color:#f92672">--</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b;
        arcs[a][b] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        arcs[b][a] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>() {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>) {
            d[i][j] <span style="color:#f92672">=</span> arcs[i][j];
        }
    }

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
        d[i][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; k <span style="color:#f92672">&lt;=</span> n; k<span style="color:#f92672">++</span>) {
                d[j][k] <span style="color:#f92672">=</span> min(d[j][i] <span style="color:#f92672">+</span> d[i][k], d[j][k]);
            }
        }
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>() {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">double</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">if</span> (d[i][j] <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">6</span>)
                count<span style="color:#f92672">++</span>;
        }
        printf(<span style="color:#e6db74">&#34;%d: %.2f%</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, <span style="color:#ae81ff">100.0</span> <span style="color:#f92672">*</span> count <span style="color:#f92672">/</span> n);
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    read();
    solve();
    print();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><a href="https://pintia.cn/problem-sets/15/problems/715">题目链接</a></p>
]]></content>
        </item>
        
        <item>
            <title>一元多项式的乘法和加法运算</title>
            <link>https://fffzlfk.gitlab.io/2019/11/28/%D2%BB%D4%AB%CA%BD%C4%B3%CD%BC%D3%B7/</link>
            <pubDate>Thu, 28 Nov 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/11/28/%D2%BB%D4%AB%CA%BD%C4%B3%CD%BC%D3%B7/</guid>
            <description>问题描述 设计函数分别求两个一元多项式的乘积与和。
输入格式: 输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。
输出格式: 输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出0 0。
输入样例: 4 3 4 -5 2 6 1 -2 03 5 20 -7 4 3 1输出样例: 15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 15 20 -4 4 -5 2 9 1 -2 0代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int m, n; int A[1005]; int B[1005]; int C[2005]; void read() { int t1, t2; cin &amp;gt;&amp;gt; m; while (m--) { cin &amp;gt;&amp;gt; t1 &amp;gt;&amp;gt; t2; A[t2] += t1; } cin &amp;gt;&amp;gt; n; while (n--) { cin &amp;gt;&amp;gt; t1 &amp;gt;&amp;gt; t2; B[t2] += t1; } } void mul() { bool zero = 1; int flag = 1; for (int i = 1004; i &amp;gt;= 0; i--) { for (int j = 1004; j &amp;gt;= 0; j--) { C[i + j] += A[i] * B[j]; } } for (int i = 2004; i &amp;gt;= 0; i--) { if (C[i]) { zero = 0; printf(flag ?</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p><strong>设计函数分别求两个一元多项式的乘积与和。</strong></p>
<h3 id="输入格式">输入格式:</h3>
<p>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p>
<h3 id="输出格式">输出格式:</h3>
<p>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出0 0。</p>
<h3 id="输入样例">输入样例:</h3>
<pre><code>4 3 4 -5 2  6 1  -2 0
3 5 20  -7 4  3 1
</code></pre><h3 id="输出样例">输出样例:</h3>
<pre><code>15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1
5 20 -4 4 -5 2 9 1 -2 0
</code></pre><h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> m, n;
<span style="color:#66d9ef">int</span> A[<span style="color:#ae81ff">1005</span>];
<span style="color:#66d9ef">int</span> B[<span style="color:#ae81ff">1005</span>];
<span style="color:#66d9ef">int</span> C[<span style="color:#ae81ff">2005</span>];
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read</span>() {
    <span style="color:#66d9ef">int</span> t1, t2;
    cin <span style="color:#f92672">&gt;&gt;</span> m;
    <span style="color:#66d9ef">while</span> (m<span style="color:#f92672">--</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> t1 <span style="color:#f92672">&gt;&gt;</span> t2;
        A[t2] <span style="color:#f92672">+=</span> t1;
    }
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    <span style="color:#66d9ef">while</span> (n<span style="color:#f92672">--</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> t1 <span style="color:#f92672">&gt;&gt;</span> t2;
        B[t2] <span style="color:#f92672">+=</span> t1;
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mul</span>() {
    <span style="color:#66d9ef">bool</span> zero <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">int</span> flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1004</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1004</span>; j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; j<span style="color:#f92672">--</span>) {
            C[i <span style="color:#f92672">+</span> j] <span style="color:#f92672">+=</span> A[i] <span style="color:#f92672">*</span> B[j];
        }
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2004</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {
        <span style="color:#66d9ef">if</span> (C[i]) {
            zero <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            printf(flag <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;%d %d&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34; %d %d&#34;</span>, C[i], i);
            flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        }
    }
    <span style="color:#66d9ef">if</span> (zero)
        printf(<span style="color:#e6db74">&#34;0 0&#34;</span>);
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>() {
    <span style="color:#66d9ef">bool</span> zero <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">int</span> flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1004</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {
        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> A[i] <span style="color:#f92672">+</span> B[i];
        <span style="color:#66d9ef">if</span> (t) {
            printf(flag <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;%d %d&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34; %d %d&#34;</span>, t, i);
            flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            zero <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        }
    }
    <span style="color:#66d9ef">if</span> (zero)
        printf(<span style="color:#e6db74">&#34;0 0&#34;</span>);
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    read();
    mul();
    printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    add();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><a href="https://pintia.cn/problem-sets/15/problems/710">题目链接</a></p>
]]></content>
        </item>
        
        <item>
            <title>列出可连通集</title>
            <link>https://fffzlfk.gitlab.io/2019/11/28/%D0%B3%CD%A8/</link>
            <pubDate>Thu, 28 Nov 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/11/28/%D0%B3%CD%A8/</guid>
            <description>问题描述 给定一个有N个顶点和E条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到N−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。
输入格式: 输入第1行给出2个整数N(0&amp;lt;N≤10)和E，分别是图的顶点数和边数。随后E行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。
输出格式: 按照如下的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。
输入样例: 8 60 70 12 04 12 43 5输出样例: { 0 1 4 2 7 }{ 3 5 }{ 6 }代码实现 DFS #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int N, E; bool visit[11]; bool arcs[11][11]; void read() { cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; E; int a, b; while (E--) { cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; arcs[a][b] = 1; arcs[b][a] = 1; } } void dfs(int v) { printf(&amp;#34; %d&amp;#34;, v); visit[v] = 1; for (int i = 0; i &amp;lt; N; i++) { if (!</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>给定一个有N个顶点和E条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到N−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p>
<h3 id="输入格式">输入格式:</h3>
<p>输入第1行给出2个整数N(0&lt;N≤10)和E，分别是图的顶点数和边数。随后E行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p>
<h3 id="输出格式">输出格式:</h3>
<p>按照如下的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。</p>
<h3 id="输入样例">输入样例:</h3>
<pre><code>8 6
0 7
0 1
2 0
4 1
2 4
3 5
</code></pre><h3 id="输出样例">输出样例:</h3>
<pre><code>{ 0 1 4 2 7 }
{ 3 5 }
{ 6 }
</code></pre><h3 id="代码实现">代码实现</h3>
<h5 id="dfs">DFS</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> N, E;
<span style="color:#66d9ef">bool</span> visit[<span style="color:#ae81ff">11</span>];
<span style="color:#66d9ef">bool</span> arcs[<span style="color:#ae81ff">11</span>][<span style="color:#ae81ff">11</span>];
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> N <span style="color:#f92672">&gt;&gt;</span> E;
    <span style="color:#66d9ef">int</span> a, b;
    <span style="color:#66d9ef">while</span> (E<span style="color:#f92672">--</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> a <span style="color:#f92672">&gt;&gt;</span> b;
        arcs[a][b] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        arcs[b][a] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> v) {
    printf(<span style="color:#e6db74">&#34; %d&#34;</span>, v);
    visit[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visit[i] <span style="color:#f92672">&amp;&amp;</span> arcs[v][i]) {
            dfs(i);
        }
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs_t</span>() {
    memset(visit, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(visit));
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visit[i]) {
            printf(<span style="color:#e6db74">&#34;{&#34;</span>);
            dfs(i);
            printf(<span style="color:#e6db74">&#34; }</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        }
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bfs</span>() {
    memset(visit, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(visit));
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>) {
        queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> Q;
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visit[i]) {
            printf(<span style="color:#e6db74">&#34;{&#34;</span>);
            Q.push(i);
            printf(<span style="color:#e6db74">&#34; %d&#34;</span>, i);
            visit[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>Q.empty()) {
                <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> Q.front();
                Q.pop();
                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> N; j<span style="color:#f92672">++</span>) {
                    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visit[j] <span style="color:#f92672">&amp;&amp;</span> arcs[t][j]) {
                        visit[j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
                        printf(<span style="color:#e6db74">&#34; %d&#34;</span>, j);
                        Q.push(j);
                    }
                }
            }
            printf(<span style="color:#e6db74">&#34; }</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        }
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    read();
    dfs_t();
    bfs();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h5 id="并查集">并查集</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> f[<span style="color:#ae81ff">105</span>];
<span style="color:#66d9ef">bool</span> visit[<span style="color:#ae81ff">105</span>];
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> i) { <span style="color:#66d9ef">return</span> f[i] <span style="color:#f92672">==</span> i <span style="color:#f92672">?</span> i : f[i] <span style="color:#f92672">=</span> find(f[i]); }
<span style="color:#66d9ef">int</span> n, m;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">link</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) {
    a <span style="color:#f92672">=</span> find(a);
    b <span style="color:#f92672">=</span> find(b);
    <span style="color:#66d9ef">if</span> (a <span style="color:#f92672">!=</span> b)
        f[a] <span style="color:#f92672">=</span> b;
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read</span>() {
    scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
        f[i] <span style="color:#f92672">=</span> i;
    <span style="color:#66d9ef">int</span> a, b;
    <span style="color:#66d9ef">while</span> (m<span style="color:#f92672">--</span>) {
        scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>a, <span style="color:#f92672">&amp;</span>b);
        link(a, b);
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>() {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visit[i])
            printf(<span style="color:#e6db74">&#34;{ %d&#34;</span>, i);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visit[j] <span style="color:#f92672">&amp;&amp;</span> f[i] <span style="color:#f92672">==</span> f[j]) {
                printf(<span style="color:#e6db74">&#34; %d&#34;</span>, j);
                visit[j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            }
        }
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visit[i])
            printf(<span style="color:#e6db74">&#34; }</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        visit[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    }
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    read();
    print();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>最大子列和问题</title>
            <link>https://fffzlfk.gitlab.io/2019/11/28/%D0%BA/</link>
            <pubDate>Thu, 28 Nov 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/11/28/%D0%BA/</guid>
            <description>问题描述 给定K个整数组成的序列,其中“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。
本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：
数据1：与样例等价，测试基本正确性；数据2：102个随机整数；数据3：103个随机整数；数据4：104个随机整数；数据5：105个随机整数；输入格式: 输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。
输出格式: 在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。
输入样例: 6-2 11 -4 13 -5 -2输出样例: 20解决思路 最大连续子列只可能是以0～n-1位置结尾，若前面位置的最大连续子列和max(i-1) &amp;gt; 0, 则以i位置结尾的最大连续子列和max(i)为max(i-1) + nums[i], 否则为nums[i]。
代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int n; int a[100005]; long long getMax() { long long max = a[0]; long long cur = a[0]; for (int i = 1; i &amp;lt; n; i++) { cur = (cur &amp;gt; 0 ?</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>给定K个整数组成的序列,其中“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。</p>
<p>本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：</p>
<pre><code>数据1：与样例等价，测试基本正确性；
数据2：102个随机整数；
数据3：103个随机整数；
数据4：104个随机整数；
数据5：105个随机整数；
</code></pre><h3 id="输入格式">输入格式:</h3>
<p>输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。</p>
<h3 id="输出格式">输出格式:</h3>
<p>在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。</p>
<h3 id="输入样例">输入样例:</h3>
<pre><code>6
-2 11 -4 13 -5 -2
</code></pre><h3 id="输出样例">输出样例:</h3>
<pre><code>20
</code></pre><h3 id="解决思路">解决思路</h3>
<p>最大连续子列只可能是以0～n-1位置结尾，若前面位置的最大连续子列和max(i-1) &gt; 0, 则以i位置结尾的最大连续子列和max(i)为max(i-1) + nums[i], 否则为nums[i]。</p>
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> n;
<span style="color:#66d9ef">int</span> a[<span style="color:#ae81ff">100005</span>];

<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">getMax</span>() {
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> max <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> cur <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
        cur <span style="color:#f92672">=</span> (cur <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">?</span> cur <span style="color:#f92672">+</span> a[i] <span style="color:#f92672">:</span> a[i]);
        <span style="color:#66d9ef">if</span> (cur <span style="color:#f92672">&gt;</span> max)
            max <span style="color:#f92672">=</span> cur;
    }
    <span style="color:#66d9ef">return</span> max;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> a[i];
    }
    cout <span style="color:#f92672">&lt;&lt;</span> getMax() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><a href="https://pintia.cn/problem-sets/15/problems/709">题目链接</a></p>
]]></content>
        </item>
        
        <item>
            <title>二叉树的遍历</title>
            <link>https://fffzlfk.gitlab.io/2019/11/26/%C4%B1/</link>
            <pubDate>Tue, 26 Nov 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/11/26/%C4%B1/</guid>
            <description>问题描述 二叉树的遍历 本题要求给定二叉树的4种遍历。
函数接口定义：
void InorderTraversal( BinTree BT ); void PreorderTraversal( BinTree BT ); void PostorderTraversal( BinTree BT ); void LevelorderTraversal( BinTree BT ); 其中BinTree结构定义如下：
typedef struct TNode *Position; typedef Position BinTree; struct TNode{ ElementType Data; BinTree Left; BinTree Right; }; 要求4个函数分别按照访问顺序打印出结点的内容，格式为一个空格跟着一个字符。
输出样例 （对于图中给出的树）：
Inorder: D B E F A G H C IPreorder: A B D F E C G H IPostorder: D E F B H G I C ALevelorder: A B C D F G I E H代码实现 void InorderTraversal(BinTree BT) { if (BT) { InorderTraversal(BT-&amp;gt;Left); printf(&amp;#34; %c&amp;#34;, BT-&amp;gt;Data); InorderTraversal(BT-&amp;gt;Right); } else { return; } } void PreorderTraversal(BinTree BT) { if (BT) { printf(&amp;#34; %c&amp;#34;, BT-&amp;gt;Data); PreorderTraversal(BT-&amp;gt;Left); PreorderTraversal(BT-&amp;gt;Right); } else { return; } } void PostorderTraversal(BinTree BT) { if (BT) { PostorderTraversal(BT-&amp;gt;Left); PostorderTraversal(BT-&amp;gt;Right); printf(&amp;#34; %c&amp;#34;, BT-&amp;gt;Data); } else { return; } } void LevelorderTraversal(BinTree BT) { BinTree Q[100]; int front = 0; int rear = 0; if (BT) { Q[++rear] = BT; } while (front !</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p><strong>二叉树的遍历</strong>
本题要求给定二叉树的4种遍历。</p>
<p>函数接口定义：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InorderTraversal</span>( BinTree BT );
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PreorderTraversal</span>( BinTree BT );
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PostorderTraversal</span>( BinTree BT );
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">LevelorderTraversal</span>( BinTree BT );
</code></pre></div><p>其中BinTree结构定义如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> TNode <span style="color:#f92672">*</span>Position;
<span style="color:#66d9ef">typedef</span> Position BinTree;
<span style="color:#66d9ef">struct</span> TNode{
    ElementType Data;
    BinTree Left;
    BinTree Right;
};
</code></pre></div><p>要求4个函数分别按照访问顺序打印出结点的内容，格式为一个空格跟着一个字符。</p>
<h3 id="输出样例">输出样例</h3>
<p>（对于图中给出的树）：</p>
<pre><code>Inorder: D B E F A G H C I
Preorder: A B D F E C G H I
Postorder: D E F B H G I C A
Levelorder: A B C D F G I E H
</code></pre><h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InorderTraversal</span>(BinTree BT) {
    <span style="color:#66d9ef">if</span> (BT) {
        InorderTraversal(BT<span style="color:#f92672">-&gt;</span>Left);
        printf(<span style="color:#e6db74">&#34; %c&#34;</span>, BT<span style="color:#f92672">-&gt;</span>Data);
        InorderTraversal(BT<span style="color:#f92672">-&gt;</span>Right);
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">return</span>;
    }
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PreorderTraversal</span>(BinTree BT) {
    <span style="color:#66d9ef">if</span> (BT) {
        printf(<span style="color:#e6db74">&#34; %c&#34;</span>, BT<span style="color:#f92672">-&gt;</span>Data);
        PreorderTraversal(BT<span style="color:#f92672">-&gt;</span>Left);
        PreorderTraversal(BT<span style="color:#f92672">-&gt;</span>Right);
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">return</span>;
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PostorderTraversal</span>(BinTree BT) {
    <span style="color:#66d9ef">if</span> (BT) {
        PostorderTraversal(BT<span style="color:#f92672">-&gt;</span>Left);
        PostorderTraversal(BT<span style="color:#f92672">-&gt;</span>Right);
        printf(<span style="color:#e6db74">&#34; %c&#34;</span>, BT<span style="color:#f92672">-&gt;</span>Data);
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">return</span>;
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">LevelorderTraversal</span>(BinTree BT) {
    BinTree Q[<span style="color:#ae81ff">100</span>];
    <span style="color:#66d9ef">int</span> front <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> rear <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">if</span> (BT) {
        Q[<span style="color:#f92672">++</span>rear] <span style="color:#f92672">=</span> BT;
    }
    <span style="color:#66d9ef">while</span> (front <span style="color:#f92672">!=</span> rear) {
        BinTree tmp <span style="color:#f92672">=</span> Q[<span style="color:#f92672">++</span>front];
        printf(<span style="color:#e6db74">&#34; %c&#34;</span>, tmp<span style="color:#f92672">-&gt;</span>Data);
        <span style="color:#66d9ef">if</span> (tmp<span style="color:#f92672">-&gt;</span>Left)
            Q[<span style="color:#f92672">++</span>rear] <span style="color:#f92672">=</span> tmp<span style="color:#f92672">-&gt;</span>Left;
        <span style="color:#66d9ef">if</span> (tmp<span style="color:#f92672">-&gt;</span>Right)
            Q[<span style="color:#f92672">++</span>rear] <span style="color:#f92672">=</span> tmp<span style="color:#f92672">-&gt;</span>Right;
    }
}
</code></pre></div><p><a href="https://pintia.cn/problem-sets/15/problems/732">题目链接</a></p>
]]></content>
        </item>
        
        <item>
            <title>二叉树前序、中序、后序遍历的相互求法</title>
            <link>https://fffzlfk.gitlab.io/2019/11/24/%D7%AA/</link>
            <pubDate>Sun, 24 Nov 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/11/24/%D7%AA/</guid>
            <description>一、已知前序、中序、求后序遍历 例如：
前序遍历: GDAFEMHZ中序遍历: ADEFGHMZ  根据前序遍历的特点，我们知道根结点为G
  观察中序遍历ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树，G右侧的HMZ必然是root的右子树。
  观察左子树ADEF，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为D。
  同样的道理，root的右子树节点HMZ中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。
  观察发现，上面的过程是递归的。先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。该步递归的过程可以简洁表达如下：
 确定根,确定左子树，确定右子树。 在左子树中递归。 在右子树中递归。 打印当前根。    核心代码
buildTreebyPre(preorder + 1, inorder, root_idx, root-&amp;gt;left); buildTreebyPre(preorder + 1 + root_idx, inorder + root_idx + 1, length - (root_idx + 1), root-&amp;gt;right); 二、已知中序、后序遍历、求前序遍历 依然是上面的题，这次我们只给出中序和后序遍历：
中序遍历: ADEFGHMZ后序遍历: AEFDHZMG  根据后序遍历的特点，我们知道后序遍历最后一个结点即为根结点，即根结点为G。
  观察中序遍历ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树，G右侧的HMZ必然是root的右子树。
  观察左子树ADEF，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为D。
  同样的道理，root的右子树节点HMZ中的根节点也可以通过前序遍历求得。在前后序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。</description>
            <content type="html"><![CDATA[<h3 id="一已知前序中序求后序遍历">一、已知前序、中序、求后序遍历</h3>
<p>例如：</p>
<pre><code>前序遍历: GDAFEMHZ
中序遍历: ADEFGHMZ
</code></pre><ol>
<li>
<p>根据前序遍历的特点，我们知道根结点为G</p>
</li>
<li>
<p>观察中序遍历ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树，G右侧的HMZ必然是root的右子树。</p>
</li>
<li>
<p>观察左子树ADEF，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为D。</p>
</li>
<li>
<p>同样的道理，root的右子树节点HMZ中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。</p>
</li>
<li>
<p>观察发现，上面的过程是递归的。先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。该步递归的过程可以简洁表达如下：</p>
<ol>
<li>确定根,确定左子树，确定右子树。</li>
<li>在左子树中递归。</li>
<li>在右子树中递归。</li>
<li>打印当前根。</li>
</ol>
</li>
</ol>
<p>核心代码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">buildTreebyPre(preorder <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, inorder, root_idx, root<span style="color:#f92672">-&gt;</span>left);
buildTreebyPre(preorder <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> root_idx, inorder <span style="color:#f92672">+</span> root_idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, length <span style="color:#f92672">-</span> (root_idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>), root<span style="color:#f92672">-&gt;</span>right);
</code></pre></div><h3 id="二已知中序后序遍历求前序遍历">二、已知中序、后序遍历、求前序遍历</h3>
<p>依然是上面的题，这次我们只给出中序和后序遍历：</p>
<pre><code>中序遍历: ADEFGHMZ
后序遍历: AEFDHZMG
</code></pre><ol>
<li>
<p>根据后序遍历的特点，我们知道后序遍历最后一个结点即为根结点，即根结点为G。</p>
</li>
<li>
<p>观察中序遍历ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树，G右侧的HMZ必然是root的右子树。</p>
</li>
<li>
<p>观察左子树ADEF，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为D。</p>
</li>
<li>
<p>同样的道理，root的右子树节点HMZ中的根节点也可以通过前序遍历求得。在前后序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。</p>
</li>
<li>
<p>观察发现，上面的过程是递归的。先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。该步递归的过程可以简洁表达如下：</p>
<ol>
<li>确定根,确定左子树，确定右子树。</li>
<li>在左子树中递归。</li>
<li>在右子树中递归。</li>
<li>打印当前根。</li>
</ol>
</li>
</ol>
<p>核心代码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">buildTreebyAft(aftorder, inorder, root_idx, root<span style="color:#f92672">-&gt;</span>left);
buildTreebyAft(aftorder <span style="color:#f92672">+</span> root_idx, inorder <span style="color:#f92672">+</span> root_idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, length <span style="color:#f92672">-</span> root_idx <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, root<span style="color:#f92672">-&gt;</span>right);
</code></pre></div><h3 id="完整代码">完整代码</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TreeNode</span> {
    <span style="color:#66d9ef">char</span> data;
    TreeNode <span style="color:#f92672">*</span>left;
    TreeNode <span style="color:#f92672">*</span>right;
    TreeNode(<span style="color:#66d9ef">char</span> e) <span style="color:#f92672">:</span> data(e) {}
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">createTree</span>(TreeNode <span style="color:#f92672">*&amp;</span>root) {
    <span style="color:#66d9ef">char</span> c <span style="color:#f92672">=</span> getchar();
    getchar();
    <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39; &#39;</span>) {
        root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode(c);
        printf(<span style="color:#e6db74">&#34;输入%c的左子树</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, c);
        createTree(root<span style="color:#f92672">-&gt;</span>left);
        printf(<span style="color:#e6db74">&#34;输入%c的右子树</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, c);
        createTree(root<span style="color:#f92672">-&gt;</span>right);
    } <span style="color:#66d9ef">else</span> {
        root <span style="color:#f92672">=</span> NULL;
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">aftOrder</span>(TreeNode <span style="color:#f92672">*</span>root) {
    <span style="color:#66d9ef">if</span> (root) {
        aftOrder(root<span style="color:#f92672">-&gt;</span>left);
        aftOrder(root<span style="color:#f92672">-&gt;</span>right);
        printf(<span style="color:#e6db74">&#34;%c</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, root<span style="color:#f92672">-&gt;</span>data);
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">return</span>;
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">preOrder</span>(TreeNode <span style="color:#f92672">*</span>root) {
    <span style="color:#66d9ef">if</span> (root) {
        printf(<span style="color:#e6db74">&#34;%c</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, root<span style="color:#f92672">-&gt;</span>data);
        preOrder(root<span style="color:#f92672">-&gt;</span>left);
        preOrder(root<span style="color:#f92672">-&gt;</span>right);
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">return</span>;
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">buildTreebyPre</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>preorder, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>inorder, <span style="color:#66d9ef">int</span> length,
                    TreeNode <span style="color:#f92672">*&amp;</span>root) {
    <span style="color:#66d9ef">if</span> (length <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        root <span style="color:#f92672">=</span> NULL;
        <span style="color:#66d9ef">return</span>;
    }
    <span style="color:#66d9ef">char</span> root_data <span style="color:#f92672">=</span> preorder[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">int</span> root_idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (; inorder[root_idx] <span style="color:#f92672">!=</span> root_data; root_idx<span style="color:#f92672">++</span>)
        ;
    root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode(root_data);
    buildTreebyPre(preorder <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, inorder, root_idx, root<span style="color:#f92672">-&gt;</span>left);
    buildTreebyPre(preorder <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> root_idx, inorder <span style="color:#f92672">+</span> root_idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>,
                   length <span style="color:#f92672">-</span> (root_idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>), root<span style="color:#f92672">-&gt;</span>right);
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">buildTreebyAft</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>aftorder, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>inorder, <span style="color:#66d9ef">int</span> length,
                    TreeNode <span style="color:#f92672">*&amp;</span>root) {
    <span style="color:#66d9ef">if</span> (length <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        root <span style="color:#f92672">=</span> NULL;
        <span style="color:#66d9ef">return</span>;
    }
    <span style="color:#66d9ef">char</span> root_data <span style="color:#f92672">=</span> aftorder[length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">int</span> root_idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (; inorder[root_idx] <span style="color:#f92672">!=</span> root_data; root_idx<span style="color:#f92672">++</span>)
        ;
    root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode(root_data);
    buildTreebyAft(aftorder, inorder, root_idx, root<span style="color:#f92672">-&gt;</span>left);
    buildTreebyAft(aftorder <span style="color:#f92672">+</span> root_idx, inorder <span style="color:#f92672">+</span> root_idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>,
                   length <span style="color:#f92672">-</span> root_idx <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, root<span style="color:#f92672">-&gt;</span>right);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    TreeNode <span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> NULL;
    buildTreebyPre(<span style="color:#e6db74">&#34;GDAFEMHZ&#34;</span>, <span style="color:#e6db74">&#34;ADEFGHMZ&#34;</span>, <span style="color:#ae81ff">8</span>, root);
    aftOrder(root);
    root <span style="color:#f92672">=</span> NULL;
    buildTreebyAft(<span style="color:#e6db74">&#34;AEFDHZMG&#34;</span>, <span style="color:#e6db74">&#34;ADEFGHMZ&#34;</span>, <span style="color:#ae81ff">8</span>, root);
    preOrder(root);
}
</code></pre></div><p>原文链接：https://blog.csdn.net/u014536527/article/details/51010702</p>
]]></content>
        </item>
        
        <item>
            <title>LeetCode-50 &amp; LeetCode-34</title>
            <link>https://fffzlfk.gitlab.io/2019/11/23/leetcode-50/</link>
            <pubDate>Sat, 23 Nov 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/11/23/leetcode-50/</guid>
            <description>LeetCode-50-Pow(x, n) 问题描述 实现 pow(x, n) ，即计算 x 的 n 次幂函数。
 示例 1:  输入: 2.00000, 10输出: 1024.00000 示例 2:  输入: 2.10000, 3输出: 9.26100 示例 3:  输入: 2.00000, -2输出: 0.25000 解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 &amp;lt; x &amp;lt; 100.0, n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。  代码实现 class Solution { public: double quickPow(double x, long long n) { if (n == 0) return 1.</description>
            <content type="html"><![CDATA[<h3 id="leetcode-50-powx-n">LeetCode-50-Pow(x, n)</h3>
<h4 id="问题描述">问题描述</h4>
<p><strong>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</strong></p>
<ul>
<li>示例 1:</li>
</ul>
<pre><code>输入: 2.00000, 10
输出: 1024.00000
</code></pre><ul>
<li>示例 2:</li>
</ul>
<pre><code>输入: 2.10000, 3
输出: 9.26100
</code></pre><ul>
<li>示例 3:</li>
</ul>
<pre><code>输入: 2.00000, -2
输出: 0.25000
</code></pre><ul>
<li>解释: 2-2 = 1/22 = 1/4 = 0.25</li>
<li>说明:
-100.0 &lt; x &lt; 100.0, n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</li>
</ul>
<h4 id="代码实现">代码实现</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">double</span> quickPow(<span style="color:#66d9ef">double</span> x, <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> n) {
        <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1.0</span>;
        <span style="color:#66d9ef">double</span> half <span style="color:#f92672">=</span> quickPow(x, n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>);
        <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
            <span style="color:#66d9ef">return</span> half <span style="color:#f92672">*</span> half;
        <span style="color:#66d9ef">else</span>
            <span style="color:#66d9ef">return</span> half <span style="color:#f92672">*</span> half <span style="color:#f92672">*</span> x;
    }

    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">myPow</span>(<span style="color:#66d9ef">double</span> x, <span style="color:#66d9ef">int</span> n) {
        <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> N <span style="color:#f92672">=</span> n;
        <span style="color:#66d9ef">if</span> (N <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
            x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> x;
            N <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>N;
        }
        <span style="color:#66d9ef">return</span> quickPow(x, n);
    }
};
</code></pre></div><h3 id="leetcode-34-在排序数组中查找元素的第一个和最后一个位置">LeetCode-34-在排序数组中查找元素的第一个和最后一个位置</h3>
<h4 id="问题描述-1">问题描述</h4>
<p><strong>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</strong></p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
<ul>
<li>示例 1:</li>
</ul>
<pre><code>输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
</code></pre><ul>
<li>示例 2:</li>
</ul>
<pre><code>输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
</code></pre><h4 id="代码实现-1">代码实现</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> search_left(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nums, <span style="color:#66d9ef">int</span> target) {
        <span style="color:#75715e">// 寻找左边界
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>nums.size())
            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> nums.size();
        <span style="color:#66d9ef">int</span> mid;
        <span style="color:#66d9ef">while</span> (left <span style="color:#f92672">&lt;</span> right) {
            mid <span style="color:#f92672">=</span> left <span style="color:#f92672">+</span> (right <span style="color:#f92672">-</span> left) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
            <span style="color:#66d9ef">if</span> (nums[mid] <span style="color:#f92672">==</span> target) {
                right <span style="color:#f92672">=</span> mid;
            } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (nums[mid] <span style="color:#f92672">&lt;</span> target) {
                left <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            } <span style="color:#66d9ef">else</span> {
                right <span style="color:#f92672">=</span> mid;
            }
        }
        <span style="color:#66d9ef">if</span> (left <span style="color:#f92672">==</span> nums.size()) <span style="color:#75715e">// target比所有数大
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">return</span> nums[left] <span style="color:#f92672">==</span> target <span style="color:#f92672">?</span> left : <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }

    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">search_right</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nums, <span style="color:#66d9ef">int</span> target) {
        <span style="color:#75715e">//寻找右边界
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>nums.size())
            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> nums.size();
        <span style="color:#66d9ef">int</span> mid;
        <span style="color:#66d9ef">while</span> (left <span style="color:#f92672">&lt;</span> right) {
            mid <span style="color:#f92672">=</span> left <span style="color:#f92672">+</span> (right <span style="color:#f92672">-</span> left) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
            <span style="color:#66d9ef">if</span> (nums[mid] <span style="color:#f92672">==</span> target) {
                left <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (nums[mid] <span style="color:#f92672">&gt;</span> target) {
                right <span style="color:#f92672">=</span> mid;
            } <span style="color:#66d9ef">else</span> {
                left <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            }
        }
        <span style="color:#66d9ef">if</span> (right <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#75715e">// target比所有数小
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">return</span> nums[right <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> target <span style="color:#f92672">?</span> right <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> searchRange(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>nums, <span style="color:#66d9ef">int</span> target) {
        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> ans;
        ans.push_back(search_left(nums, target));
        ans.push_back(search_right(nums, target));
        <span style="color:#66d9ef">return</span> ans;
    }
};
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>POJ-2387-Til_the_Cows_Come_Home</title>
            <link>https://fffzlfk.gitlab.io/2019/11/22/poj2387/</link>
            <pubDate>Fri, 22 Nov 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/11/22/poj2387/</guid>
            <description>问题描述 贝西（Bessie）在野外，想回到谷仓以尽可能多地睡觉，直到农夫约翰（John Farmer）叫醒她早上进行挤奶。贝西需要美睡，所以她想尽快回来。
农夫约翰的田地里有N（2 &amp;lt;= N &amp;lt;= 1000）个地标，唯一编号为1..N。地标1是谷仓；Bessie整日站立的苹果树丛是地标N。奶牛使用地标之间长度各异的T（1 &amp;lt;= T &amp;lt;= 2000）双向奶牛场在田间旅行。贝西对自己的导航能力不抱有信心，因此，从开始到结束，她始终保持在步道上。
给定地标之间的路径，确定Bessie返回谷仓必须行走的最小距离。可以保证存在这样的路经。
大意 题目会给你n个点，m条边，然后给你每条边又哪两个点相连，并且其中的路程是多少。我们需要找到最短路径的总路程。
样例输入 5 51 2 202 3 303 4 204 5 201 5 100样例输出 90代码实现 #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std; #define Max 0xfffffff #define N 1005 int arcs[N][N]; int visit[N]; int f[N]; int n, t; void shortestPath() { int i, j, k, min; memset(visit, 0, sizeof(visit)); for (i = 1; i &amp;lt;= n; i++) f[i] = arcs[1][i]; f[1] = 0; for (i = 1; i &amp;lt; n; i++) { min = Max; for (j = 1; j &amp;lt;= n; j++) { if (!</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>贝西（Bessie）在野外，想回到谷仓以尽可能多地睡觉，直到农夫约翰（John Farmer）叫醒她早上进行挤奶。贝西需要美睡，所以她想尽快回来。</p>
<p>农夫约翰的田地里有N（2 &lt;= N &lt;= 1000）个地标，唯一编号为1..N。地标1是谷仓；Bessie整日站立的苹果树丛是地标N。奶牛使用地标之间长度各异的T（1 &lt;= T &lt;= 2000）双向奶牛场在田间旅行。贝西对自己的导航能力不抱有信心，因此，从开始到结束，她始终保持在步道上。</p>
<p>给定地标之间的路径，确定Bessie返回谷仓必须行走的最小距离。可以保证存在这样的路经。</p>
<h6 id="大意">大意</h6>
<p>题目会给你n个点，m条边，然后给你每条边又哪两个点相连，并且其中的路程是多少。我们需要找到最短路径的总路程。</p>
<h3 id="样例输入">样例输入</h3>
<pre><code>5 5
1 2 20
2 3 30
3 4 20
4 5 20
1 5 100
</code></pre><h3 id="样例输出">样例输出</h3>
<pre><code>90
</code></pre><h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">#define Max 0xfffffff
</span><span style="color:#75715e">#define N 1005
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> arcs[N][N];
<span style="color:#66d9ef">int</span> visit[N];
<span style="color:#66d9ef">int</span> f[N];
<span style="color:#66d9ef">int</span> n, t;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">shortestPath</span>() {
  <span style="color:#66d9ef">int</span> i, j, k, min;
  memset(visit, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(visit));
  <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
    f[i] <span style="color:#f92672">=</span> arcs[<span style="color:#ae81ff">1</span>][i];
  f[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
    min <span style="color:#f92672">=</span> Max;
    <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visit[j] <span style="color:#f92672">&amp;&amp;</span> f[j] <span style="color:#f92672">&lt;</span> min) {
        min <span style="color:#f92672">=</span> f[j];
        k <span style="color:#f92672">=</span> j;
      }
    }
    <span style="color:#66d9ef">if</span> (min <span style="color:#f92672">==</span> Max)
      <span style="color:#66d9ef">break</span>;
    visit[k] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visit[j] <span style="color:#f92672">&amp;&amp;</span> f[j] <span style="color:#f92672">&gt;</span> f[k] <span style="color:#f92672">+</span> arcs[k][j]) {
        f[j] <span style="color:#f92672">=</span> f[k] <span style="color:#f92672">+</span> arcs[k][j];
      }
    }
  }
  cout <span style="color:#f92672">&lt;&lt;</span> f[n] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> i, j;
  <span style="color:#66d9ef">while</span> (scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>t, <span style="color:#f92672">&amp;</span>n) <span style="color:#f92672">!=</span> EOF) {
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>)
        arcs[i][j] <span style="color:#f92672">=</span> Max;
      arcs[i][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    }
    <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> t; j<span style="color:#f92672">++</span>) {
      <span style="color:#66d9ef">int</span> a, b, len;
      scanf(<span style="color:#e6db74">&#34;%d%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>a, <span style="color:#f92672">&amp;</span>b, <span style="color:#f92672">&amp;</span>len);
      <span style="color:#66d9ef">if</span> (arcs[a][b] <span style="color:#f92672">&gt;</span> len)
        arcs[a][b] <span style="color:#f92672">=</span> arcs[b][a] <span style="color:#f92672">=</span> len;
    }
    shortestPath();
  }
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>二分查找及二叉排序树</title>
            <link>https://fffzlfk.gitlab.io/2019/11/22/%D6%B2%D2%BD%D2%B7/</link>
            <pubDate>Fri, 22 Nov 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/11/22/%D6%B2%D2%BD%D2%B7/</guid>
            <description>问题描述  顺序表的二分查找（折半查找),同时实现寻找左边界和右边界的算法 二叉排序树的查找、删除以及添加结点  代码实现 二分查找 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int search_bi(vector&amp;lt;int&amp;gt; nums, int target) { int low = 0; int high = nums.size() - 1; int mid; while (low &amp;lt;= high) { mid = (low + high) / 2; if (nums[mid] == target) return mid; else if (nums[mid] &amp;lt; target) { low = mid + 1; } else { high = mid - 1; } } return -1; } int search_left(vector&amp;lt;int&amp;gt; nums, int target) { // 寻找左边界  if (!</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<ol>
<li>顺序表的二分查找（折半查找),同时实现寻找左边界和右边界的算法</li>
<li>二叉排序树的查找、删除以及添加结点</li>
</ol>
<h3 id="代码实现">代码实现</h3>
<h6 id="二分查找">二分查找</h6>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">search_bi</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nums, <span style="color:#66d9ef">int</span> target) {
    <span style="color:#66d9ef">int</span> low <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> high <span style="color:#f92672">=</span> nums.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">int</span> mid;
    <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;=</span> high) {
        mid <span style="color:#f92672">=</span> (low <span style="color:#f92672">+</span> high) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">if</span> (nums[mid] <span style="color:#f92672">==</span> target)
            <span style="color:#66d9ef">return</span> mid;
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (nums[mid] <span style="color:#f92672">&lt;</span> target) {
            low <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        } <span style="color:#66d9ef">else</span> {
            high <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">search_left</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nums, <span style="color:#66d9ef">int</span> target) {
    <span style="color:#75715e">// 寻找左边界
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>nums.size())
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> nums.size();
    <span style="color:#66d9ef">int</span> mid;
    <span style="color:#66d9ef">while</span> (left <span style="color:#f92672">&lt;</span> right) {
        mid <span style="color:#f92672">=</span> left <span style="color:#f92672">+</span> (right <span style="color:#f92672">-</span> left) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">if</span> (nums[mid] <span style="color:#f92672">==</span> target) {
            right <span style="color:#f92672">=</span> mid;
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (nums[mid] <span style="color:#f92672">&lt;</span> target) {
            left <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        } <span style="color:#66d9ef">else</span> {
            right <span style="color:#f92672">=</span> mid;
        }
    }
    <span style="color:#66d9ef">if</span> (left <span style="color:#f92672">==</span> nums.size()) <span style="color:#75715e">// target比所有数大
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">return</span> nums[left] <span style="color:#f92672">==</span> target <span style="color:#f92672">?</span> left : <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">search_right</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nums, <span style="color:#66d9ef">int</span> target) {
    <span style="color:#75715e">//寻找右边界
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>nums.size())
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> nums.size();
    <span style="color:#66d9ef">int</span> mid;
    <span style="color:#66d9ef">while</span> (left <span style="color:#f92672">&lt;</span> right) {
        mid <span style="color:#f92672">=</span> left <span style="color:#f92672">+</span> (right <span style="color:#f92672">-</span> left) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">if</span> (nums[mid] <span style="color:#f92672">==</span> target) {
            left <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (nums[mid] <span style="color:#f92672">&gt;</span> target) {
            right <span style="color:#f92672">=</span> mid;
        } <span style="color:#66d9ef">else</span> {
            left <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        }
    }
    <span style="color:#66d9ef">if</span> (right <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#75715e">// target比所有数小
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">return</span> nums[right <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> target <span style="color:#f92672">?</span> right <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v;
    <span style="color:#66d9ef">int</span> n, t;
    cin <span style="color:#f92672">&gt;&gt;</span> n;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
        cin <span style="color:#f92672">&gt;&gt;</span> t;
        v.push_back(t);
    }
    cout <span style="color:#f92672">&lt;&lt;</span> search_bi(v, <span style="color:#ae81ff">4</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> search_left(v, <span style="color:#ae81ff">3</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> search_right(v, <span style="color:#ae81ff">5</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h6 id="二叉排序树">二叉排序树</h6>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span> {
    <span style="color:#66d9ef">int</span> data;
    Node <span style="color:#f92672">*</span>left;
    Node <span style="color:#f92672">*</span>right;
} <span style="color:#f92672">*</span> BiTree;
ifstream <span style="color:#a6e22e">in</span>(<span style="color:#e6db74">&#34;datain.txt&#34;</span>);

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">CreateBiTree</span>(BiTree <span style="color:#f92672">&amp;</span>T) {
    <span style="color:#66d9ef">int</span> c; <span style="color:#75715e">//输入-1表示NULL
</span><span style="color:#75715e"></span>    in <span style="color:#f92672">&gt;&gt;</span> c;
    <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
        T <span style="color:#f92672">=</span> (Node <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
        T<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> c;
        printf(<span style="color:#e6db74">&#34;请输入%d的左孩子</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, c);
        CreateBiTree(T<span style="color:#f92672">-&gt;</span>left);
        printf(<span style="color:#e6db74">&#34;请输入%d的右孩子</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, c);
        CreateBiTree(T<span style="color:#f92672">-&gt;</span>right);
    } <span style="color:#66d9ef">else</span> {
        T <span style="color:#f92672">=</span> NULL;
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Traverse</span>(BiTree T) {
    <span style="color:#66d9ef">if</span> (T) {
        Traverse(T<span style="color:#f92672">-&gt;</span>left);
        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, T<span style="color:#f92672">-&gt;</span>data);
        Traverse(T<span style="color:#f92672">-&gt;</span>right);
    } <span style="color:#66d9ef">else</span>
        <span style="color:#66d9ef">return</span>;
}

BiTree <span style="color:#a6e22e">SearchBST</span>(BiTree T, <span style="color:#66d9ef">int</span> key) {
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>T <span style="color:#f92672">||</span> key <span style="color:#f92672">==</span> T<span style="color:#f92672">-&gt;</span>data)
        <span style="color:#66d9ef">return</span> T;
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (T<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&gt;</span> key)
        SearchBST(T<span style="color:#f92672">-&gt;</span>left, key);
    <span style="color:#66d9ef">else</span>
        SearchBST(T<span style="color:#f92672">-&gt;</span>right, key);
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">SearchBST</span>(BiTree T, <span style="color:#66d9ef">int</span> key, BiTree f, BiTree <span style="color:#f92672">&amp;</span>p) {
    <span style="color:#75715e">// 查找成功，f指向T的双亲
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>T) {
        p <span style="color:#f92672">=</span> f;
        <span style="color:#66d9ef">return</span> false;
    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (T<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">==</span> key) {
        p <span style="color:#f92672">=</span> T;
        <span style="color:#66d9ef">return</span> true;
    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (T<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&gt;</span> key)
        <span style="color:#66d9ef">return</span> SearchBST(T<span style="color:#f92672">-&gt;</span>left, key, T, p);
    <span style="color:#66d9ef">else</span>
        <span style="color:#66d9ef">return</span> SearchBST(T<span style="color:#f92672">-&gt;</span>right, key, T, p);
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">InsertBST</span>(BiTree <span style="color:#f92672">&amp;</span>T, <span style="color:#66d9ef">int</span> e) {
    <span style="color:#75715e">//查找不成功，在适当位置插入
</span><span style="color:#75715e"></span>    Node <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>SearchBST(T, e, NULL, p)) {
        Node <span style="color:#f92672">*</span>node <span style="color:#f92672">=</span> (Node <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
        node<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> e;
        node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> NULL;
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>p)
            p <span style="color:#f92672">=</span> node;
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&gt;</span> e)
            p<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> node;
        <span style="color:#66d9ef">else</span>
            p<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> node;
        <span style="color:#66d9ef">return</span> true;
    }
    <span style="color:#66d9ef">return</span> false;
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Delete</span>(BiTree <span style="color:#f92672">&amp;</span>p) {
    Node <span style="color:#f92672">*</span>q <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>p<span style="color:#f92672">-&gt;</span>left) {
        q <span style="color:#f92672">=</span> p;
        p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>right;
        free(q);
    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>p<span style="color:#f92672">-&gt;</span>right) {
        q <span style="color:#f92672">=</span> p;
        p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>left;
        free(q);
    } <span style="color:#66d9ef">else</span> {
        q <span style="color:#f92672">=</span> p;
        Node <span style="color:#f92672">*</span>s <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>left;
        <span style="color:#66d9ef">while</span> (s<span style="color:#f92672">-&gt;</span>right) {
            q <span style="color:#f92672">=</span> s;
            s <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>right;
        }
        p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>data;
        <span style="color:#66d9ef">if</span> (q <span style="color:#f92672">!=</span> p)
            q<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>left;
        <span style="color:#66d9ef">else</span>
            q<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>left;
        free(s);
    }
    <span style="color:#66d9ef">return</span> true;
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">DeleteBST</span>(BiTree <span style="color:#f92672">&amp;</span>T, <span style="color:#66d9ef">int</span> key) {
    <span style="color:#75715e">// 若存在key则删除
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>T)
        <span style="color:#66d9ef">return</span> false;
    <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">if</span> (T<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">==</span> key)
            <span style="color:#66d9ef">return</span> Delete(T);
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (T<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&gt;</span> key)
            <span style="color:#66d9ef">return</span> DeleteBST(T<span style="color:#f92672">-&gt;</span>left, key);
        <span style="color:#66d9ef">else</span>
            <span style="color:#66d9ef">return</span> DeleteBST(T<span style="color:#f92672">-&gt;</span>right, key);
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    BiTree T;
    CreateBiTree(T);
    Traverse(T);
    Node <span style="color:#f92672">*</span>node <span style="color:#f92672">=</span> SearchBST(T, <span style="color:#ae81ff">37</span>);
    <span style="color:#66d9ef">if</span> (node)
        cout <span style="color:#f92672">&lt;&lt;</span> node<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; <span style="color:#75715e">//验证是否正确找到
</span><span style="color:#75715e"></span>    InsertBST(T, <span style="color:#ae81ff">38</span>);
    Traverse(T);
    DeleteBST(T, <span style="color:#ae81ff">38</span>);
    Traverse(T);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>最小生成树的求法</title>
            <link>https://fffzlfk.gitlab.io/2019/11/21/%D1%81/</link>
            <pubDate>Thu, 21 Nov 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/11/21/%D1%81/</guid>
            <description>问题描述 请对下图的无向带权图 (1)写出它的邻接矩阵，并按普里姆算法求其最小生成树； (2)写出它的邻接表，并按克鲁斯卡尔算法求其最小生成树。 问题解决 邻接矩阵 0 4 3 - - - - -4 0 5 5 9 - - -3 5 0 5 - - - 5- 5 5 0 7 6 5 4- 9 - 7 0 3 - -- - - 6 3 0 2 -- - - 5 - 2 0 6- - 5 4 - - 6 0#include &amp;lt;stdio.</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>请对下图的无向带权图
(1)写出它的邻接矩阵，并按普里姆算法求其最小生成树；
(2)写出它的邻接表，并按克鲁斯卡尔算法求其最小生成树。
<img src="https://uploadfiles.nowcoder.com/images/20180315/5994168_1521087479012_6CE28496EAA7968C3C38F82FBC2CD075" alt=""></p>
<h3 id="问题解决">问题解决</h3>
<h6 id="邻接矩阵">邻接矩阵</h6>
<pre><code>0 4 3 - - - - -
4 0 5 5 9 - - -
3 5 0 5 - - - 5
- 5 5 0 7 6 5 4
- 9 - 7 0 3 - -
- - - 6 3 0 2 -
 - - - 5 - 2 0 6
 - - 5 4 - - 6 0
</code></pre><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define MAX_VERTEX_NUM 31
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> VertexType;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> INF <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x3f3f3f</span>;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> graph {
	<span style="color:#66d9ef">int</span> arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];
	<span style="color:#66d9ef">int</span> vexnum;
	<span style="color:#66d9ef">int</span> arcnum;
} <span style="color:#f92672">*</span> Graph;

<span style="color:#66d9ef">struct</span> {
	VertexType adjvex;
	<span style="color:#66d9ef">int</span> lowcost;
} closedge[MAX_VERTEX_NUM];

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">CreateGraph</span>(Graph <span style="color:#f92672">&amp;</span>G) {
	G <span style="color:#f92672">=</span> (Graph)malloc(<span style="color:#66d9ef">sizeof</span>(graph));
	puts(<span style="color:#e6db74">&#34;请输入图的结点数&#34;</span>);
	scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>G<span style="color:#f92672">-&gt;</span>vexnum);
	puts(<span style="color:#e6db74">&#34;请输入邻接矩阵&#34;</span>);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> G<span style="color:#f92672">-&gt;</span>vexnum; i<span style="color:#f92672">++</span>) {
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> G<span style="color:#f92672">-&gt;</span>vexnum; j<span style="color:#f92672">++</span>)
			scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>G<span style="color:#f92672">-&gt;</span>arcs[i][j]);
	}
	<span style="color:#75715e">// 0 4 3 INF INF INF INF INF 4 0 5 5 9 INF INF INF 3 5 0 5 INF INF INF 5 INF 5 5 0 7 6 5 4 INF 9 INF 7 0 3 INF INF INF INF INF 6 3 0 2 INF INF INF INF 5 INF 2 0 6 INF INF 5 4 INF INF 6 0
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MiniSpanTree</span>(Graph G, <span style="color:#66d9ef">char</span> c) {
	<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> c<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">bool</span> visit[MAX_VERTEX_NUM];
	memset(visit, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(visit));
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> G<span style="color:#f92672">-&gt;</span>vexnum; i<span style="color:#f92672">++</span>) {
		<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> k)
			closedge[i] <span style="color:#f92672">=</span> {k, G<span style="color:#f92672">-&gt;</span>arcs[k][i]};
	}
	closedge[k].lowcost <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	visit[k] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> G<span style="color:#f92672">-&gt;</span>vexnum; i<span style="color:#f92672">++</span>) {
		<span style="color:#66d9ef">int</span> min <span style="color:#f92672">=</span> INF;
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> G<span style="color:#f92672">-&gt;</span>vexnum; j<span style="color:#f92672">++</span>) {
			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visit[j] <span style="color:#f92672">&amp;&amp;</span> closedge[j].lowcost <span style="color:#f92672">&lt;</span> min) {
				k <span style="color:#f92672">=</span> j;
				min <span style="color:#f92672">=</span> closedge[j].lowcost;
			}
		}
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visit[k])
			printf(<span style="color:#e6db74">&#34;%c %c</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, closedge[k].adjvex<span style="color:#f92672">+</span><span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, k<span style="color:#f92672">+</span><span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
		closedge[k].lowcost <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
		visit[k] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> G<span style="color:#f92672">-&gt;</span>vexnum; j<span style="color:#f92672">++</span>) {
			<span style="color:#66d9ef">if</span> (G<span style="color:#f92672">-&gt;</span>arcs[k][j] <span style="color:#f92672">&lt;</span> closedge[j].lowcost) {
				closedge[j] <span style="color:#f92672">=</span> {k, G<span style="color:#f92672">-&gt;</span>arcs[k][j]};
			}
		}
	}
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
	Graph G;
	CreateGraph(G);
	MiniSpanTree(G, <span style="color:#e6db74">&#39;a&#39;</span>);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p><img src="https://i.ibb.co/wpBFVRS/image-20191121104344422.png" alt=""></p>
<h6 id="邻接表">邻接表</h6>
<pre><code>   A| B C
   B| A C D E
   C| A B D H
   D| B C E F G H
   E| B D F
</code></pre>]]></content>
        </item>
        
        <item>
            <title>105.从前序与中序遍历序列构造二叉树</title>
            <link>https://fffzlfk.gitlab.io/2019/11/17/leetcode-105-%C7%B0%D0%B9/</link>
            <pubDate>Sun, 17 Nov 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/11/17/leetcode-105-%C7%B0%D0%B9/</guid>
            <description>问题描述 题目链接
根据一棵树的前序遍历与中序遍历构造二叉树。
  注意: 你可以假设树中没有重复的元素。
  例如，给出
  前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树：
 3/ \9 20/ \15 7代码实现 class Solution { public: vector&amp;lt;int&amp;gt; pre_order; vector&amp;lt;int&amp;gt; in_order; map&amp;lt;int,int&amp;gt; m; int pre_idx = 0; TreeNode* help(int inleft, int inright) { if (inleft == inright) return NULL; int root_val = pre_order[pre_idx]; TreeNode *root = new TreeNode(root_val); int index = m[root_val]; pre_idx++; root-&amp;gt;left = help(inleft, index); root-&amp;gt;right = help(index + 1, inright); return root; } TreeNode* buildTree(vector&amp;lt;int&amp;gt;&amp;amp; preorder, vector&amp;lt;int&amp;gt;&amp;amp; inorder) { pre_order = preorder; in_order = inorder; for (int i = 0; i &amp;lt; (int)inorder.</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal">题目链接</a></p>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<ul>
<li>
<p>注意:
你可以假设树中没有重复的元素。</p>
</li>
<li>
<p>例如，给出</p>
</li>
</ul>
<p>前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre><h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> pre_order;
vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> in_order;
map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> m;
<span style="color:#66d9ef">int</span> pre_idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
TreeNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">help</span>(<span style="color:#66d9ef">int</span> inleft, <span style="color:#66d9ef">int</span> inright) {
	<span style="color:#66d9ef">if</span> (inleft <span style="color:#f92672">==</span> inright)
		<span style="color:#66d9ef">return</span> NULL;
	<span style="color:#66d9ef">int</span> root_val <span style="color:#f92672">=</span> pre_order[pre_idx];
	TreeNode <span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode(root_val);
	<span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> m[root_val];
	pre_idx<span style="color:#f92672">++</span>;
	root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> help(inleft, index);
	root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> help(index <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, inright);
	<span style="color:#66d9ef">return</span> root;
}

TreeNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">buildTree</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> preorder, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> inorder) {
	pre_order <span style="color:#f92672">=</span> preorder;
	in_order <span style="color:#f92672">=</span> inorder;
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">int</span>)inorder.size(); i<span style="color:#f92672">++</span>) {
		m[inorder[i]] <span style="color:#f92672">=</span> i;
	}
	<span style="color:#66d9ef">return</span> help(<span style="color:#ae81ff">0</span>,(<span style="color:#66d9ef">int</span>)preorder.size());
}
};
</code></pre></div><h3 id="执行结果">执行结果：</h3>
<ul>
<li>执行用时 :
32 ms, 在所有 cpp 提交中击败了56.63%的用户</li>
<li>内存消耗 :
19.2 MB, 在所有 cpp 提交中击败了24.87%的用户</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>98.验证二叉搜索树</title>
            <link>https://fffzlfk.gitlab.io/2019/11/17/leetcode-98-%D6%A4/</link>
            <pubDate>Sun, 17 Nov 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/11/17/leetcode-98-%D6%A4/</guid>
            <description>问题描述 给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。
示例 示例 1:  输入:   2/ \1 3 输出: true  示例 2:  输入:   5/ \1 4/ \3 6 输出: false  解释: 输入为: [5,1,4,null,null,3,6]。  根节点的值为 5 ，但是其右子节点值为 4 。
代码实现 bool helper(struct TreeNode *root, int lower, int upper) { if (!root) return true; // printf(&amp;#34;current low:%d\ncurrent up:%d\n&amp;#34;, lower, upper); 	if (lower !</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<p>节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。</p>
<h3 id="示例">示例</h3>
<h6 id="示例1">示例 1:</h6>
<ul>
<li>输入:</li>
</ul>
<pre><code>  2
 /  \
1   3
</code></pre><ul>
<li>输出: true</li>
</ul>
<h6 id="示例2">示例 2:</h6>
<ul>
<li>输入:</li>
</ul>
<pre><code>   5
  / \
 1   4
     /  \
   3    6
</code></pre><ul>
<li>输出: false</li>
</ul>
<h6 id="解释-输入为-514nullnull36">解释: 输入为: [5,1,4,null,null,3,6]。</h6>
<p>     根节点的值为 5 ，但是其右子节点值为 4 。</p>
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">helper</span>(<span style="color:#66d9ef">struct</span> TreeNode <span style="color:#f92672">*</span>root, <span style="color:#66d9ef">int</span> lower, <span style="color:#66d9ef">int</span> upper) {
	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>root)
		<span style="color:#66d9ef">return</span> true;
	<span style="color:#75715e">// printf(&#34;current low:%d\ncurrent up:%d\n&#34;, lower, upper);
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (lower <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> lower <span style="color:#f92672">&gt;=</span> root<span style="color:#f92672">-&gt;</span>val)
		<span style="color:#66d9ef">return</span> false;
	<span style="color:#66d9ef">if</span> (upper <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> upper <span style="color:#f92672">&lt;=</span> root<span style="color:#f92672">-&gt;</span>val)
		<span style="color:#66d9ef">return</span> false;
	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>helper(root<span style="color:#f92672">-&gt;</span>right, root<span style="color:#f92672">-&gt;</span>val, upper))
		<span style="color:#66d9ef">return</span> false;
	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>helper(root<span style="color:#f92672">-&gt;</span>left, lower, root<span style="color:#f92672">-&gt;</span>val))
		<span style="color:#66d9ef">return</span> false;
	<span style="color:#66d9ef">return</span> true;
}
<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isValidBST</span>(<span style="color:#66d9ef">struct</span> TreeNode<span style="color:#f92672">*</span> root) {
        <span style="color:#66d9ef">return</span> helper(root,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
}
</code></pre></div><h3 id="执行结果">执行结果</h3>
<p>执行用时 :
8 ms, 在所有 c 提交中击败了94.16%的用户</p>
<p>内存消耗 :9.9 MB, 在所有 c 提交中击败了100.00%的用户</p>
]]></content>
        </item>
        
        <item>
            <title>无向图的遍历</title>
            <link>https://fffzlfk.gitlab.io/2019/11/15/%CD%BC%C4%B1/</link>
            <pubDate>Fri, 15 Nov 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/11/15/%CD%BC%C4%B1/</guid>
            <description>问题描述  分别使用邻接表和邻接矩阵存储无向图图，并设计深度优先搜索遍历算法和广度优先搜索遍历算法。 用1,2,3，&amp;hellip;，表示结点 并分别求出深度优先生成树和广度优先生成树的边集。  代码实现 邻接表 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define MAX_VERTEX_NUM 31 typedef int InfoType; typedef int VertexType; bool visited[MAX_VERTEX_NUM]; bool dfs_arc[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; bool bfs_arc[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; typedef struct ArcNode { int adjvex; ArcNode *nextarc; InfoType *info; } ArcNode; typedef struct VNode { VertexType data; ArcNode *firstarc; } VNode, AdjList[MAX_VERTEX_NUM]; typedef struct { AdjList vertices; int vexnum, arcnum; int kind; } ALGraph; //创建无向图 void Create(ALGraph &amp;amp;G) { puts(&amp;#34;输入节点数和边数&amp;#34;); scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;G.vexnum, &amp;amp;G.arcnum); for (int i = 1; i &amp;lt;= G.</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<ul>
<li>分别使用邻接表和邻接矩阵存储无向图图，并设计深度优先搜索遍历算法和广度优先搜索遍历算法。</li>
<li>用1,2,3，&hellip;，表示结点</li>
<li>并分别求出深度优先生成树和广度优先生成树的边集。</li>
</ul>
<h3 id="代码实现">代码实现</h3>
<h6 id="邻接表">邻接表</h6>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define MAX_VERTEX_NUM 31
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> InfoType;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> VertexType;
<span style="color:#66d9ef">bool</span> visited[MAX_VERTEX_NUM];
<span style="color:#66d9ef">bool</span> dfs_arc[MAX_VERTEX_NUM][MAX_VERTEX_NUM];
<span style="color:#66d9ef">bool</span> bfs_arc[MAX_VERTEX_NUM][MAX_VERTEX_NUM];
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ArcNode</span> {
	<span style="color:#66d9ef">int</span> adjvex;
	ArcNode <span style="color:#f92672">*</span>nextarc;
	InfoType <span style="color:#f92672">*</span>info;
} ArcNode;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">VNode</span> {
	VertexType data;
	ArcNode <span style="color:#f92672">*</span>firstarc;
} VNode, AdjList[MAX_VERTEX_NUM];

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
	AdjList vertices;
	<span style="color:#66d9ef">int</span> vexnum, arcnum;
	<span style="color:#66d9ef">int</span> kind;
} ALGraph;
<span style="color:#75715e">//创建无向图
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Create</span>(ALGraph <span style="color:#f92672">&amp;</span>G) {
	puts(<span style="color:#e6db74">&#34;输入节点数和边数&#34;</span>);
	scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>G.vexnum, <span style="color:#f92672">&amp;</span>G.arcnum);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> G.vexnum; i<span style="color:#f92672">++</span>) {
		G.vertices[i].data <span style="color:#f92672">=</span> i;
		G.vertices[i].firstarc <span style="color:#f92672">=</span> NULL;
	}
	puts(<span style="color:#e6db74">&#34;依次输入弧&#34;</span>);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> G.arcnum; i<span style="color:#f92672">++</span>) {
		<span style="color:#66d9ef">int</span> v1, v2;
		scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>v1, <span style="color:#f92672">&amp;</span>v2);
		ArcNode <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> (ArcNode<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(ArcNode));
		p<span style="color:#f92672">-&gt;</span>adjvex <span style="color:#f92672">=</span> v2;
		p<span style="color:#f92672">-&gt;</span>nextarc <span style="color:#f92672">=</span> G.vertices[v1].firstarc;
		G.vertices[v1].firstarc <span style="color:#f92672">=</span> p;
		p <span style="color:#f92672">=</span> (ArcNode<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(ArcNode));
		p<span style="color:#f92672">-&gt;</span>adjvex <span style="color:#f92672">=</span> v1;
		p<span style="color:#f92672">-&gt;</span>nextarc <span style="color:#f92672">=</span> G.vertices[v2].firstarc;
		G.vertices[v2].firstarc <span style="color:#f92672">=</span> p;
	}
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(ALGraph <span style="color:#f92672">*</span>G, <span style="color:#66d9ef">int</span> v) {
	ArcNode <span style="color:#f92672">*</span>p;
	visited[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
	printf(<span style="color:#e6db74">&#34;当前DFS节点为%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, G<span style="color:#f92672">-&gt;</span>vertices[v].data);
	p <span style="color:#f92672">=</span> G<span style="color:#f92672">-&gt;</span>vertices[v].firstarc;
	<span style="color:#66d9ef">while</span> (p) {
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visited[p<span style="color:#f92672">-&gt;</span>adjvex]) {
			dfs_arc[v][p<span style="color:#f92672">-&gt;</span>adjvex] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
			dfs_arc[p<span style="color:#f92672">-&gt;</span>adjvex][v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
			DFS(G, p<span style="color:#f92672">-&gt;</span>adjvex);
		}
		p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>nextarc;
	}
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS_traverse</span>(ALGraph <span style="color:#f92672">*</span>G) {
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; k <span style="color:#f92672">&lt;=</span> G<span style="color:#f92672">-&gt;</span>vexnum; k<span style="color:#f92672">++</span>)
		visited[k] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	puts(<span style="color:#e6db74">&#34;DFS&#34;</span>);
	<span style="color:#66d9ef">int</span> v;
	puts(<span style="color:#e6db74">&#34;请输入DFS起点&#34;</span>);
	scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>v);
	DFS(G, v);
	puts(<span style="color:#e6db74">&#34;DFS生成树边集:&#34;</span>);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> G<span style="color:#f92672">-&gt;</span>vexnum; i<span style="color:#f92672">++</span>) {
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i; j <span style="color:#f92672">&lt;=</span> G<span style="color:#f92672">-&gt;</span>vexnum; j<span style="color:#f92672">++</span>) {
			<span style="color:#66d9ef">if</span> (dfs_arc[i][j])
				printf(<span style="color:#e6db74">&#34;%d %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, j);
		}
	}
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">BFS_traverse</span>(ALGraph <span style="color:#f92672">*</span>G) {
	puts(<span style="color:#e6db74">&#34;BFS&#34;</span>);
	<span style="color:#66d9ef">int</span> Q[MAX_VERTEX_NUM];
	<span style="color:#66d9ef">int</span> front <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">int</span> rear <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; k <span style="color:#f92672">&lt;=</span> G<span style="color:#f92672">-&gt;</span>vexnum; k<span style="color:#f92672">++</span>)
		visited[k] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">int</span> v;
	puts(<span style="color:#e6db74">&#34;请输入BFS起点&#34;</span>);
	scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>v);
	printf(<span style="color:#e6db74">&#34;当前BFS节点为%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, v);
	visited[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
	Q[<span style="color:#f92672">++</span>rear] <span style="color:#f92672">=</span> v;
	<span style="color:#66d9ef">while</span> (front <span style="color:#f92672">!=</span> rear) {
		<span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> Q[<span style="color:#f92672">++</span>front];
		ArcNode <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> G<span style="color:#f92672">-&gt;</span>vertices[w].firstarc;
		<span style="color:#66d9ef">while</span> (p) {
			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visited[p<span style="color:#f92672">-&gt;</span>adjvex]) {
				printf(<span style="color:#e6db74">&#34;当前BFS节点为%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, p<span style="color:#f92672">-&gt;</span>adjvex);
				visited[p<span style="color:#f92672">-&gt;</span>adjvex] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
				Q[<span style="color:#f92672">++</span>rear] <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>adjvex;
				bfs_arc[w][p<span style="color:#f92672">-&gt;</span>adjvex] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
				bfs_arc[p<span style="color:#f92672">-&gt;</span>adjvex][w] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
			}
			p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>nextarc;
		}
	}

	puts(<span style="color:#e6db74">&#34;BFS生成树边集：&#34;</span>);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> G<span style="color:#f92672">-&gt;</span>vexnum; i<span style="color:#f92672">++</span>) {
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i; j <span style="color:#f92672">&lt;=</span> G<span style="color:#f92672">-&gt;</span>vexnum; j<span style="color:#f92672">++</span>) {
			<span style="color:#66d9ef">if</span> (bfs_arc[i][j])
				printf(<span style="color:#e6db74">&#34;%d %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, j);
		}
	}
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
	ALGraph G;
	Create(G);
	DFS_traverse(<span style="color:#f92672">&amp;</span>G);
	BFS_traverse(<span style="color:#f92672">&amp;</span>G);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h6 id="邻接矩阵">邻接矩阵</h6>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAX <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>;
<span style="color:#66d9ef">int</span> arc[MAX][MAX];
<span style="color:#66d9ef">bool</span> visit[MAX];
<span style="color:#66d9ef">bool</span> dfs_arc[MAX][MAX];
<span style="color:#66d9ef">bool</span> bfs_arc[MAX][MAX];
<span style="color:#66d9ef">int</span> n;
<span style="color:#66d9ef">int</span> m;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> v) {
	<span style="color:#66d9ef">if</span> (v <span style="color:#f92672">&lt;=</span> n)
		printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, v);
	visit[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
		<span style="color:#66d9ef">if</span> (arc[v][i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> visit[i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
			dfs_arc[v][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
			dfs_arc[i][v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
			dfs(i);
		}
	}
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs_traverse</span>() {
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
		visit[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">int</span> v;
	puts(<span style="color:#e6db74">&#34;请输入DFS起点&#34;</span>);
	scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>v);
	dfs(v);
	puts(<span style="color:#e6db74">&#34;DFS生成树边集为&#34;</span>);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>) {
			<span style="color:#66d9ef">if</span> (dfs_arc[i][j])
				printf(<span style="color:#e6db74">&#34;%d %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, j);
		}
	}
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bfs_traverse</span>() {
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
		visit[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> Q;
	<span style="color:#66d9ef">int</span> v;
	puts(<span style="color:#e6db74">&#34;请输入BFS起点&#34;</span>);
	cin <span style="color:#f92672">&gt;&gt;</span> v;
	Q.push(v);
	printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, v);
	visit[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>Q.empty()) {
		v <span style="color:#f92672">=</span> Q.front();
		Q.pop();
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
			<span style="color:#66d9ef">if</span> (arc[v][i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>visit[i]) {
				printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i);
				bfs_arc[v][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
				bfs_arc[i][v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
                Q.push(i);
			}
		}
	}
	puts(<span style="color:#e6db74">&#34;BFS生成树边集为&#34;</span>);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>) {
			<span style="color:#66d9ef">if</span> (bfs_arc[i][j])
				printf(<span style="color:#e6db74">&#34;%d %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, j);
		}
	}
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
	puts(<span style="color:#e6db74">&#34;输入节点数和边数&#34;</span>);
	cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
	<span style="color:#66d9ef">int</span> v1, v2;
	puts(<span style="color:#e6db74">&#34;依次输入各边&#34;</span>);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>) {
		cin <span style="color:#f92672">&gt;&gt;</span> v1 <span style="color:#f92672">&gt;&gt;</span> v2;
		arc[v1][v2] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
		arc[v2][v1] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
	}
	dfs_traverse();
	bfs_traverse();
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>求元素子树深度</title>
            <link>https://fffzlfk.gitlab.io/2019/11/13/%D4%AB/</link>
            <pubDate>Wed, 13 Nov 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/11/13/%D4%AB/</guid>
            <description>问题描述 请设计递归算法求以元素为x根节点的子树深度
代码实现 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define OK 1 #define ERROR 0 typedef char ElemType; typedef int Status; typedef struct Node { ElemType data; Node *left; Node *right; } * BTree; Status createBTree(BTree &amp;amp;T) { ElemType c; scanf(&amp;#34;%c&amp;#34;, &amp;amp;c); getchar(); if (c == &amp;#39; &amp;#39;) T = NULL; else { if (!(T = (Node*)malloc(sizeof(Node)))) return ERROR; T-&amp;gt;data = c; printf(&amp;#34;请输入%c的左孩子\n&amp;#34;, c); createBTree(T-&amp;gt;left); printf(&amp;#34;请输入%c的右孩子\n&amp;#34;, c); createBTree(T-&amp;gt;right); } } int getDepth(BTree T) { if (T == NULL) return 0; else { return getDepth(T-&amp;gt;left) &amp;gt; getDepth(T-&amp;gt;right) ?</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>请设计递归算法求以元素为x根节点的子树深度</p>
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define OK 1
</span><span style="color:#75715e">#define ERROR 0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">char</span> ElemType;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Node {
	ElemType data;
	Node <span style="color:#f92672">*</span>left;
	Node <span style="color:#f92672">*</span>right;
} <span style="color:#f92672">*</span> BTree;

Status <span style="color:#a6e22e">createBTree</span>(BTree <span style="color:#f92672">&amp;</span>T) {
	ElemType c;
	scanf(<span style="color:#e6db74">&#34;%c&#34;</span>, <span style="color:#f92672">&amp;</span>c);
	getchar();
	<span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39; &#39;</span>) T <span style="color:#f92672">=</span> NULL;
	<span style="color:#66d9ef">else</span> {
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(T <span style="color:#f92672">=</span> (Node<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(Node))))
			<span style="color:#66d9ef">return</span> ERROR;
		T<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> c;
		printf(<span style="color:#e6db74">&#34;请输入%c的左孩子</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, c);
		createBTree(T<span style="color:#f92672">-&gt;</span>left);
		printf(<span style="color:#e6db74">&#34;请输入%c的右孩子</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, c);
		createBTree(T<span style="color:#f92672">-&gt;</span>right);
	}
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getDepth</span>(BTree T) {
	<span style="color:#66d9ef">if</span> (T <span style="color:#f92672">==</span> NULL)
		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">else</span> {
		<span style="color:#66d9ef">return</span> getDepth(T<span style="color:#f92672">-&gt;</span>left) <span style="color:#f92672">&gt;</span> getDepth(T<span style="color:#f92672">-&gt;</span>right) <span style="color:#f92672">?</span> getDepth(T<span style="color:#f92672">-&gt;</span>left) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> getDepth(T<span style="color:#f92672">-&gt;</span>right) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
	}
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getChildDepth</span>(BTree T, ElemType e) {
	<span style="color:#66d9ef">if</span> (T) {
		<span style="color:#66d9ef">if</span> (T<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">==</span> e) {
			<span style="color:#66d9ef">return</span> getDepth(T);
		}
		<span style="color:#66d9ef">else</span> {
			<span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> getChildDepth(T<span style="color:#f92672">-&gt;</span>left, e);
			<span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> getChildDepth(T<span style="color:#f92672">-&gt;</span>right, e);
			<span style="color:#66d9ef">return</span> m <span style="color:#f92672">&gt;=</span> n <span style="color:#f92672">?</span> m : n;
		}
	} <span style="color:#66d9ef">else</span>
		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">preOrder</span>(BTree T) {
	<span style="color:#66d9ef">if</span> (T <span style="color:#f92672">!=</span> NULL)
		printf(<span style="color:#e6db74">&#34;%c</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, T<span style="color:#f92672">-&gt;</span>data);
	<span style="color:#66d9ef">else</span>
		<span style="color:#66d9ef">return</span>;
	preOrder(T<span style="color:#f92672">-&gt;</span>left);
	preOrder(T<span style="color:#f92672">-&gt;</span>right);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
	BTree T;
	createBTree(T);
	printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, getChildDepth(T, <span style="color:#e6db74">&#39;3&#39;</span>));
	preOrder(T);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>哈夫曼编码及译码器</title>
            <link>https://fffzlfk.gitlab.io/2019/11/10/%EB%BC%B0/</link>
            <pubDate>Sun, 10 Nov 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/11/10/%EB%BC%B0/</guid>
            <description>问题描述 利用哈夫曼编码进行通信可以大大提高信道利用率,缩短信息传输时间,降低传输成本。但是,这要求在发送端通过一个编码系统对待传数据预先码,在接收端将传来的数据进行译码(复原)。对于双工信道(即可以双向传输信息的信道),每端需要一个完编/译码系统。试为这样的信息收发站写一个哈夫曼码的编/译码系统。
基本要求 一个完整的系统应具有以下功能:
 I :初始化(Initialization)。从终端读人字符集大小n,以及n个字符和n个权值,建立哈夫曼树,并将它存于文件 hfmTree 中。 E :编码(Encoding)。利用以建好的哈夫曼树(如不在内存,则从文件 hfmTree 中读人),对文件 ToBeTran 中的正文进行编码,然后将结果存人文件 CodeFile 中。 D :译 码(Decoding)。利用已建好的哈夫曼树将文件 CodeFile 中的代码进行译码,结果存人文件 TextFile 中。 P :印代码文件(Print)。将文件 CodeFile 以紧凑格式显示在终端上,每行50个代码。同时将此字符形式的编码文件写人文件 CodePrin。 T :打印哈夫曼树(Tree printing)。将已在内存中的哈夫曼树以直观的方式(树或凹人表形式)显示在终端上,同时将此字符形式的哈夫曼树写人文件 TreePrint 中。  代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;#define INT_MAX 2147483647 #define OK 1 #define ERROR 0 typedef char ElemType; typedef int Status; typedef struct { char c; int weight; int parent; int left; int right; char *code; } HNode; HNode *T; int n; Status select(HNode *T, int pos, int *s1, int *s2) { int m1, m2; m1 = m2 = INT_MAX; for (int j = 1; j &amp;lt;= pos; j++) { if (T[j].</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>利用哈夫曼编码进行通信可以大大提高信道利用率,缩短信息传输时间,降低传输成本。但是,这要求在发送端通过一个编码系统对待传数据预先码,在接收端将传来的数据进行译码(复原)。对于双工信道(即可以双向传输信息的信道),每端需要一个完编/译码系统。试为这样的信息收发站写一个哈夫曼码的编/译码系统。</p>
<h3 id="基本要求">基本要求</h3>
<p>一个完整的系统应具有以下功能:</p>
<ol>
<li>I :初始化(Initialization)。从终端读人字符集大小n,以及n个字符和n个权值,建立哈夫曼树,并将它存于文件 hfmTree 中。</li>
<li>E :编码(Encoding)。利用以建好的哈夫曼树(如不在内存,则从文件 hfmTree 中读人),对文件 ToBeTran 中的正文进行编码,然后将结果存人文件 CodeFile 中。</li>
<li>D :译 码(Decoding)。利用已建好的哈夫曼树将文件 CodeFile 中的代码进行译码,结果存人文件 TextFile 中。</li>
<li>P :印代码文件(Print)。将文件 CodeFile 以紧凑格式显示在终端上,每行50个代码。同时将此字符形式的编码文件写人文件 CodePrin。</li>
<li>T :打印哈夫曼树(Tree printing)。将已在内存中的哈夫曼树以直观的方式(树或凹人表形式)显示在终端上,同时将此字符形式的哈夫曼树写人文件 TreePrint 中。</li>
</ol>
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#define INT_MAX 2147483647
</span><span style="color:#75715e">#define OK 1
</span><span style="color:#75715e">#define ERROR 0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">char</span> ElemType;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#66d9ef">char</span> c;
    <span style="color:#66d9ef">int</span> weight;
    <span style="color:#66d9ef">int</span> parent;
    <span style="color:#66d9ef">int</span> left;
    <span style="color:#66d9ef">int</span> right;
    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>code;
} HNode;
HNode <span style="color:#f92672">*</span>T;
<span style="color:#66d9ef">int</span> n;
Status <span style="color:#a6e22e">select</span>(HNode <span style="color:#f92672">*</span>T, <span style="color:#66d9ef">int</span> pos, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>s1, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>s2) {
    <span style="color:#66d9ef">int</span> m1, m2;
    m1 <span style="color:#f92672">=</span> m2 <span style="color:#f92672">=</span> INT_MAX;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> pos; j<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (T[j].weight <span style="color:#f92672">&lt;</span> m1 <span style="color:#f92672">&amp;&amp;</span> T[j].parent <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            m2 <span style="color:#f92672">=</span> m1;
            <span style="color:#f92672">*</span>s2 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>s1;
            <span style="color:#f92672">*</span>s1 <span style="color:#f92672">=</span> j;
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (T[j].weight <span style="color:#f92672">&lt;</span> m2 <span style="color:#f92672">&amp;&amp;</span> T[j].parent <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            m2 <span style="color:#f92672">=</span> T[j].weight;
            <span style="color:#f92672">*</span>s2 <span style="color:#f92672">=</span> j;
        }
    }
}

Status <span style="color:#a6e22e">Initialization</span>() {
    FILE <span style="color:#f92672">*</span>fp <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;hfmTree.txt&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>);
    puts(<span style="color:#e6db74">&#34;请输入n&#34;</span>);
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
    fprintf(fp, <span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, n);
    T <span style="color:#f92672">=</span> new HNode[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> n];
    puts(<span style="color:#e6db74">&#34;请输入n个字符及其权值&#34;</span>);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        getchar();
        T[i].c <span style="color:#f92672">=</span> getchar();
        scanf(<span style="color:#e6db74">&#34; %d&#34;</span>, <span style="color:#f92672">&amp;</span>T[i].weight);
        T[i].parent <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        T[i].left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        T[i].right <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        T[i].code <span style="color:#f92672">=</span> NULL;
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> n; i<span style="color:#f92672">++</span>) {
        T[i].c <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;^&#39;</span>;
        T[i].weight <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        T[i].parent <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        T[i].left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        T[i].right <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        T[i].code <span style="color:#f92672">=</span> NULL;
    }
    <span style="color:#66d9ef">int</span> s1, s2;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> n; i<span style="color:#f92672">++</span>) {
        select(T, i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>s1, <span style="color:#f92672">&amp;</span>s2);
        T[i].weight <span style="color:#f92672">=</span> T[s1].weight <span style="color:#f92672">+</span> T[s2].weight;
        T[s1].parent <span style="color:#f92672">=</span> T[s2].parent <span style="color:#f92672">=</span> i;
        T[i].left <span style="color:#f92672">=</span> s1;
        T[i].right <span style="color:#f92672">=</span> s2;
    }

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> n; i<span style="color:#f92672">++</span>) {
        fprintf(fp, <span style="color:#e6db74">&#34;%c %d %d %d %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, T[i].c, T[i].weight, T[i].parent,
                T[i].left, T[i].right);
    }
    fclose(fp);
    <span style="color:#66d9ef">return</span> OK;
}

Status <span style="color:#a6e22e">Encoding</span>() {
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>T) {
        FILE <span style="color:#f92672">*</span>fp <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;hfmTree.txt&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>);
        fscanf(fp, <span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> n; i<span style="color:#f92672">++</span>) {
            fscanf(fp, <span style="color:#e6db74">&#34;%c %d %d %d %d&#34;</span>, <span style="color:#f92672">&amp;</span>T[i].c, <span style="color:#f92672">&amp;</span>T[i].weight, <span style="color:#f92672">&amp;</span>T[i].parent,
                   <span style="color:#f92672">&amp;</span>T[i].left, <span style="color:#f92672">&amp;</span>T[i].right);
        }
    }
    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>cd;
    cd <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">char</span>) <span style="color:#f92672">*</span> n);
    cd[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">int</span> start <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> i;
        <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> T[i].parent;
        <span style="color:#66d9ef">while</span> (p) {
            <span style="color:#f92672">--</span>start;
            <span style="color:#66d9ef">if</span> (T[p].left <span style="color:#f92672">==</span> c)
                cd[start] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;0&#39;</span>;
            <span style="color:#66d9ef">else</span>
                cd[start] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;1&#39;</span>;
            c <span style="color:#f92672">=</span> p;
            p <span style="color:#f92672">=</span> T[p].parent;
        }
        T[i].code <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)malloc((n <span style="color:#f92672">-</span> start) <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">char</span>));
        strcpy(T[i].code, <span style="color:#f92672">&amp;</span>cd[start]);
    }
    free(cd);
    FILE <span style="color:#f92672">*</span>pf <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;ToBeTran.txt&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>);
    FILE <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;CodeFile.txt&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>);
    <span style="color:#66d9ef">char</span> t;
    <span style="color:#66d9ef">while</span> (fscanf(pf, <span style="color:#e6db74">&#34;%c&#34;</span>, <span style="color:#f92672">&amp;</span>t) <span style="color:#f92672">!=</span> EOF) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">if</span> (t <span style="color:#f92672">==</span> T[i].c) {
                fprintf(p, <span style="color:#e6db74">&#34;%s&#34;</span>, T[i].code);
                <span style="color:#66d9ef">break</span>;
            }
        }
    }
    fclose(pf);
    fclose(p);
    <span style="color:#66d9ef">return</span> OK;
}

Status <span style="color:#a6e22e">Decoding</span>() {
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>T) {
        FILE <span style="color:#f92672">*</span>fp <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;hfmTree.txt&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>);
        fscanf(fp, <span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> n; i<span style="color:#f92672">++</span>) {
            fscanf(fp, <span style="color:#e6db74">&#34;%c %d %d %d %d&#34;</span>, <span style="color:#f92672">&amp;</span>T[i].c, <span style="color:#f92672">&amp;</span>T[i].weight, <span style="color:#f92672">&amp;</span>T[i].parent,
                   <span style="color:#f92672">&amp;</span>T[i].left, <span style="color:#f92672">&amp;</span>T[i].right);
        }
    }
    FILE <span style="color:#f92672">*</span>fp <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;CodeFile.txt&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>);
    FILE <span style="color:#f92672">*</span>fp1 <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;TextFile.txt&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>);
    <span style="color:#66d9ef">char</span> t;
    <span style="color:#66d9ef">while</span> (fscanf(fp, <span style="color:#e6db74">&#34;%c&#34;</span>, <span style="color:#f92672">&amp;</span>t) <span style="color:#f92672">!=</span> EOF) {
        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">while</span> ((T[i].left <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> T[i].right <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)) {
            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
                fscanf(fp, <span style="color:#e6db74">&#34;%c&#34;</span>, <span style="color:#f92672">&amp;</span>t);
            <span style="color:#66d9ef">if</span> (t <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span>) {
                i <span style="color:#f92672">=</span> T[i].left;
            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (t <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span>)
                i <span style="color:#f92672">=</span> T[i].right;
        }

        <span style="color:#66d9ef">if</span> (T[i].left <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> T[i].right <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            fprintf(fp1, <span style="color:#e6db74">&#34;%c&#34;</span>, T[i].c);
        }
    }
    fclose(fp);
    fclose(fp1);
    <span style="color:#66d9ef">return</span> OK;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Print</span>() {
    FILE <span style="color:#f92672">*</span>fp <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;CodeFile.txt&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>);
    FILE <span style="color:#f92672">*</span>fp1 <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;CodePrin.txt&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>);
    <span style="color:#66d9ef">char</span> t;
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> (fscanf(fp, <span style="color:#e6db74">&#34;%c&#34;</span>, <span style="color:#f92672">&amp;</span>t) <span style="color:#f92672">!=</span> EOF) {
        <span style="color:#f92672">++</span>i;
        printf(<span style="color:#e6db74">&#34;%c&#34;</span>, t);
        fprintf(fp1, <span style="color:#e6db74">&#34;%c&#34;</span>, t);
        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">%</span> <span style="color:#ae81ff">50</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
            fprintf(fp1, <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        }
    }
    printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    fclose(fp);
    fclose(fp1);
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Tree_printing</span>() {
    FILE <span style="color:#f92672">*</span>fp <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;TreePrint.txt&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> n; i<span style="color:#f92672">++</span>) {
        printf(<span style="color:#e6db74">&#34;T[i].c:%c</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">T[i].weight:%d</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">T[i].parent:%d</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">T[i].left:%d</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">T[i].&#34;</span>
               <span style="color:#e6db74">&#34;right:%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
               T[i].c, T[i].weight, T[i].parent, T[i].left, T[i].right);
        fprintf(fp,
                <span style="color:#e6db74">&#34;T[i].c:%c</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">T[i].weight:%d</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">T[i].parent:%d</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">T[i].left:%d</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">T[i].&#34;</span>
                <span style="color:#e6db74">&#34;right:%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
                T[i].c, T[i].weight, T[i].parent, T[i].left, T[i].right);
    }
    fclose(fp);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
  <span style="color:#66d9ef">int</span> n;
  <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
    printf(<span style="color:#e6db74">&#34;输入0结束程序</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">输入1初始化</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">输入2进行编码</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">输入3进行译码</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">输入4打印代码文件</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">输入5打印哈夫曼树</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
      <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
    Initialization();
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>)
    Encoding();
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>)
    Decoding();
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>)
    Print();
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">5</span>)
    Tree_printing();
  }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>哈夫曼树和哈夫曼编码</title>
            <link>https://fffzlfk.gitlab.io/2019/11/07//</link>
            <pubDate>Thu, 07 Nov 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/11/07//</guid>
            <description>概念解释 Huffman树是一种特殊结构的二叉树，由Huffman树设计的二进制前缀编码，也称为Huffman编码在通信领域有着广泛的应用。
  路径长度 路径长度指的是路径上分支的数目，在上图中，路径长度为2。
  节点的权 节点的权指的是为树中的每一个节点赋予的一个非负的值，如上图中每一个节点中的值。
  节点的带权路径长度 节点的带权路径长度指的是从根节点到该节点之间的路径长度与该节点权的乘积：如对于1节点的带权路径长度为：2。
  树的带权路径长度 树的带权路径长度指的是所有叶子节点的带权路径长度之和。
   有了如上的概念，对于Huffman树，其定义为： 给定nn权值作为nn个叶子节点，构造一棵二叉树，若这棵二叉树的带权路径长度达到最小，则称这样的二叉树为最优二叉树，也称为Huffman树。
 解决方法 重复以下的步骤：
 按照权值对每一个节点排序：D-F-T-E-R-A 选择权值最小的两个节点，此处为D和F生成新的节点，节点的权重这两个节点的权重之和，为2 直到只剩最后的根节点  代码实现 readfile #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; const int MAXSIZE = 1000; int read_file(FILE *fn, map&amp;lt;char, int&amp;gt; &amp;amp;word) { if (fn == NULL) return -1; char line[MAXSIZE]; while (fgets(line, 1024, fn)) { fprintf(stderr, &amp;#34;%s\n&amp;#34;, line); char *p = line; while (*p !</description>
            <content type="html"><![CDATA[<h3 id="概念解释">概念解释</h3>
<p>Huffman树是一种特殊结构的二叉树，由Huffman树设计的二进制前缀编码，也称为Huffman编码在通信领域有着广泛的应用。</p>
<ol>
<li>
<p>路径长度
路径长度指的是路径上分支的数目，在上图中，路径长度为2。</p>
</li>
<li>
<p>节点的权
节点的权指的是为树中的每一个节点赋予的一个非负的值，如上图中每一个节点中的值。</p>
</li>
<li>
<p>节点的带权路径长度
节点的带权路径长度指的是从根节点到该节点之间的路径长度与该节点权的乘积：如对于1节点的带权路径长度为：2。</p>
</li>
<li>
<p>树的带权路径长度
树的带权路径长度指的是所有叶子节点的带权路径长度之和。</p>
</li>
</ol>
<blockquote>
<p>有了如上的概念，对于Huffman树，其定义为：
给定nn权值作为nn个叶子节点，构造一棵二叉树，若这棵二叉树的带权路径长度达到最小，则称这样的二叉树为最优二叉树，也称为Huffman树。</p>
</blockquote>
<h3 id="解决方法">解决方法</h3>
<p>重复以下的步骤：</p>
<ol>
<li>按照权值对每一个节点排序：D-F-T-E-R-A</li>
<li>选择权值最小的两个节点，此处为D和F生成新的节点，节点的权重这两个节点的权重之和，为2</li>
<li>直到只剩最后的根节点</li>
</ol>
<h3 id="代码实现">代码实现</h3>
<h6 id="readfile">readfile</h6>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;map&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXSIZE <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000</span>;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">read_file</span>(FILE <span style="color:#f92672">*</span>fn, map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>word) {
	<span style="color:#66d9ef">if</span> (fn <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">char</span> line[MAXSIZE];
	<span style="color:#66d9ef">while</span> (fgets(line, <span style="color:#ae81ff">1024</span>, fn)) {
		fprintf(stderr, <span style="color:#e6db74">&#34;%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, line);
		<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> line;
		<span style="color:#66d9ef">while</span> (<span style="color:#f92672">*</span>p <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\0&#39;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\n&#39;</span>) {
			<span style="color:#66d9ef">if</span> (word.find(<span style="color:#f92672">*</span>p) <span style="color:#f92672">==</span> word.end()) {
				word[<span style="color:#f92672">*</span>p] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
			} <span style="color:#66d9ef">else</span> {
				word[<span style="color:#f92672">*</span>p]<span style="color:#f92672">++</span>;
			}
			p<span style="color:#f92672">++</span>;
		}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h5 id="核心代码">核心代码</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;readfile.cc&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">#define LEN 500
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">HuffmanNode</span> {
	<span style="color:#66d9ef">char</span> c;
	<span style="color:#66d9ef">int</span> weight;
	<span style="color:#66d9ef">char</span> huffman_code[LEN];
	HuffmanNode <span style="color:#f92672">*</span>left;
	HuffmanNode <span style="color:#f92672">*</span>right;
};

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">sort_by_weight</span>(HuffmanNode <span style="color:#f92672">*</span>n1, HuffmanNode <span style="color:#f92672">*</span>n2) {
	<span style="color:#66d9ef">return</span> n1<span style="color:#f92672">-&gt;</span>weight <span style="color:#f92672">&lt;</span> n2<span style="color:#f92672">-&gt;</span>weight;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">huffman_tree_create</span>(HuffmanNode <span style="color:#f92672">*&amp;</span>root, map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>word) {
	<span style="color:#66d9ef">char</span> line[MAXSIZE];
	vector<span style="color:#f92672">&lt;</span>HuffmanNode<span style="color:#f92672">*&gt;</span> huffman_tree;
	map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it;
	<span style="color:#66d9ef">for</span> (it <span style="color:#f92672">=</span> word.begin(); it <span style="color:#f92672">!=</span> word.end(); it<span style="color:#f92672">++</span>) {
		HuffmanNode <span style="color:#f92672">*</span>node <span style="color:#f92672">=</span> (HuffmanNode<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(HuffmanNode));
		node<span style="color:#f92672">-&gt;</span>c <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>first;
		node<span style="color:#f92672">-&gt;</span>weight <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>second;
		node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> NULL;
		node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> NULL;
		huffman_tree.push_back(node);
	}

	<span style="color:#66d9ef">while</span> (huffman_tree.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
		sort(huffman_tree.begin(), huffman_tree.end(), sort_by_weight);
		<span style="color:#66d9ef">if</span> (huffman_tree.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
			root <span style="color:#f92672">=</span> huffman_tree[<span style="color:#ae81ff">0</span>];
			huffman_tree.erase(huffman_tree.begin());
		} <span style="color:#66d9ef">else</span> {
			HuffmanNode <span style="color:#f92672">*</span>n1 <span style="color:#f92672">=</span> huffman_tree[<span style="color:#ae81ff">0</span>];
			HuffmanNode <span style="color:#f92672">*</span>n2 <span style="color:#f92672">=</span> huffman_tree[<span style="color:#ae81ff">1</span>];
			huffman_tree.erase(huffman_tree.begin(), huffman_tree.begin() <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>);
			HuffmanNode <span style="color:#f92672">*</span>n3 <span style="color:#f92672">=</span> (HuffmanNode<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(HuffmanNode));
			n3<span style="color:#f92672">-&gt;</span>weight <span style="color:#f92672">=</span> n1<span style="color:#f92672">-&gt;</span>weight <span style="color:#f92672">+</span> n2<span style="color:#f92672">-&gt;</span>weight;
			(n1<span style="color:#f92672">-&gt;</span>weight <span style="color:#f92672">&lt;</span> n2<span style="color:#f92672">-&gt;</span>weight) <span style="color:#f92672">?</span> (n3<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> n1, n3<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> n2) <span style="color:#f92672">:</span> (n3<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> n2, n3<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> n1);
			huffman_tree.push_back(n3);
		}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">traverse</span>(HuffmanNode <span style="color:#f92672">*</span>node) {
	<span style="color:#66d9ef">if</span> (node <span style="color:#f92672">!=</span> NULL) {
		printf(<span style="color:#e6db74">&#34;%c</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, node<span style="color:#f92672">-&gt;</span>c, node<span style="color:#f92672">-&gt;</span>weight);
		traverse(node<span style="color:#f92672">-&gt;</span>left);
		traverse(node<span style="color:#f92672">-&gt;</span>right);
	}
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">huffman_coding</span>(HuffmanNode <span style="color:#f92672">*&amp;</span>node) {
	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>node) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
	HuffmanNode <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> node;
	queue<span style="color:#f92672">&lt;</span>HuffmanNode<span style="color:#f92672">*&gt;</span> q;
	q.push(p);
	<span style="color:#66d9ef">while</span> (q.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
		p <span style="color:#f92672">=</span> q.front();
		q.pop();
		<span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">!=</span> NULL) {
			q.push(p<span style="color:#f92672">-&gt;</span>left);
			strcpy((p<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>huffman_code, p<span style="color:#f92672">-&gt;</span>huffman_code);
			<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>pp <span style="color:#f92672">=</span> (p<span style="color:#f92672">-&gt;</span>left)<span style="color:#f92672">-&gt;</span>huffman_code;
			<span style="color:#66d9ef">while</span> (<span style="color:#f92672">*</span>pp <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\0&#39;</span>) {
				pp<span style="color:#f92672">++</span>;
			}
			<span style="color:#f92672">*</span>pp <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;0&#39;</span>;
			<span style="color:#f92672">*++</span>pp <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
		}
		<span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">!=</span> NULL) {
			q.push(p<span style="color:#f92672">-&gt;</span>right);
			strcpy((p<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>huffman_code, p<span style="color:#f92672">-&gt;</span>huffman_code);
			<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>pp <span style="color:#f92672">=</span> (p<span style="color:#f92672">-&gt;</span>right)<span style="color:#f92672">-&gt;</span>huffman_code;
			<span style="color:#66d9ef">while</span> (<span style="color:#f92672">*</span>pp <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\0&#39;</span>) {
				pp<span style="color:#f92672">++</span>;
			}
			<span style="color:#f92672">*</span>pp <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;1&#39;</span>;
			<span style="color:#f92672">*++</span>pp <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
		}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print_leaf</span>(HuffmanNode <span style="color:#f92672">*</span>node){
	<span style="color:#66d9ef">if</span> (node <span style="color:#f92672">!=</span> NULL) {
		print_leaf(node<span style="color:#f92672">-&gt;</span>left);
		<span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> NULL <span style="color:#f92672">&amp;&amp;</span> node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">==</span> NULL)
			printf(<span style="color:#e6db74">&#34;%c  %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, node<span style="color:#f92672">-&gt;</span>c, node<span style="color:#f92672">-&gt;</span>huffman_code);
		print_leaf(node<span style="color:#f92672">-&gt;</span>right);
	}
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
	FILE <span style="color:#f92672">*</span>fn <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;huffman.txt&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>);
	map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> word;
	HuffmanNode <span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> NULL;
	read_file(fn, word);
	fclose(fn);
	huffman_tree_create(root, word);
	<span style="color:#75715e">// traverse(root);
</span><span style="color:#75715e"></span>	huffman_coding(root);
	print_leaf(root);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>约瑟夫环问题</title>
            <link>https://fffzlfk.gitlab.io/2019/11/06/%D5%AC%C9%AA/</link>
            <pubDate>Wed, 06 Nov 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/11/06/%D5%AC%C9%AA/</guid>
            <description>问题描述 编号为1, 2, 3,&amp;hellip;,n的n个人围成一圈，每个人持有一个密码（正整数），从初始m为上限从1开始报数，报到m为止，报m的出列，将他的密码作为下一个m值，如此下去，求出出列顺序。
解决思路 很容易想到用循环链表来解决该问题
测试样例 样例输入 7 203 1 7 2 4 8 4样例输出 6147235代码实现 Clang #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; typedef struct Node { int data; int id; Node *next; } * LinkList; void Create(LinkList &amp;amp;L, int n) { L = (Node*)malloc(sizeof(Node)); Node *node, *end; end = L; for (int i = 0; i &amp;lt; n; i++) { node = (Node*)malloc(sizeof(Node)); scanf(&amp;#34;%d&amp;#34;, &amp;amp;node-&amp;gt;data); node-&amp;gt;id = i + 1; end-&amp;gt;next = node; end = node; } end-&amp;gt;next = L-&amp;gt;next; } int solve(LinkList &amp;amp;L, int m) { if (m &amp;lt; 1) return -1; int t = m; Node *last = L-&amp;gt;next; Node *cur = L-&amp;gt;next; while (cur-&amp;gt;next !</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>编号为1, 2, 3,&hellip;,n的n个人围成一圈，每个人持有一个密码（正整数），从初始m为上限从1开始报数，报到m为止，报m的出列，将他的密码作为下一个m值，如此下去，求出出列顺序。</p>
<h3 id="解决思路">解决思路</h3>
<p>很容易想到用循环链表来解决该问题</p>
<h3 id="测试样例">测试样例</h3>
<h5 id="样例输入">样例输入</h5>
<pre><code>7 20
3 1 7 2 4 8 4
</code></pre><h5 id="样例输出">样例输出</h5>
<pre><code>6
1
4
7
2
3
5
</code></pre><h3 id="代码实现">代码实现</h3>
<h5 id="clang">Clang</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Node {
	<span style="color:#66d9ef">int</span> data;
	<span style="color:#66d9ef">int</span> id;
	Node <span style="color:#f92672">*</span>next;
} <span style="color:#f92672">*</span> LinkList;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Create</span>(LinkList <span style="color:#f92672">&amp;</span>L, <span style="color:#66d9ef">int</span> n) {
	L <span style="color:#f92672">=</span> (Node<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
	Node <span style="color:#f92672">*</span>node, <span style="color:#f92672">*</span>end;
	end <span style="color:#f92672">=</span> L;
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
		node <span style="color:#f92672">=</span> (Node<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
		scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>node<span style="color:#f92672">-&gt;</span>data);
		node<span style="color:#f92672">-&gt;</span>id <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
		end<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> node;
		end <span style="color:#f92672">=</span> node;
	}
	end<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>next;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">solve</span>(LinkList <span style="color:#f92672">&amp;</span>L, <span style="color:#66d9ef">int</span> m) {
	<span style="color:#66d9ef">if</span> (m <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> m;
	Node <span style="color:#f92672">*</span>last <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>next;
	Node <span style="color:#f92672">*</span>cur <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>next;
	<span style="color:#66d9ef">while</span> (cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> cur) {
		<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
		<span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> t <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
			last <span style="color:#f92672">=</span> cur;
			cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
			i<span style="color:#f92672">++</span>;
		}
		Node <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> cur;
		t <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>data;
		printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, cur<span style="color:#f92672">-&gt;</span>id);
		last<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
		cur <span style="color:#f92672">=</span> last<span style="color:#f92672">-&gt;</span>next;
		free(p);
	}
	<span style="color:#66d9ef">return</span> cur<span style="color:#f92672">-&gt;</span>id;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
	LinkList L;
	<span style="color:#66d9ef">int</span> n, m;
	scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
	Create(L, n);
	printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,solve(L, m));
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h5 id="c">C++</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> n, m;
<span style="color:#66d9ef">int</span> pw[<span style="color:#ae81ff">100</span>];
list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> l;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read</span>() {
    scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>pw[i]);
        l.push_back(i);
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(<span style="color:#66d9ef">int</span> m) {
    list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> l.begin();
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>l.empty()) {
        m <span style="color:#f92672">%=</span> (<span style="color:#66d9ef">int</span>)l.size();
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>) {
            it<span style="color:#f92672">++</span>;
            <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">==</span> l.end())
                it <span style="color:#f92672">=</span> l.begin();
        }
        m <span style="color:#f92672">=</span> pw[<span style="color:#f92672">*</span>it];
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
        it <span style="color:#f92672">=</span> l.erase(it);
        <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">==</span> l.end())
            it <span style="color:#f92672">=</span> l.begin();
    }
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    read();
    solve(m);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>魔王语言解释</title>
            <link>https://fffzlfk.gitlab.io/2019/11/06/%C4%A7%D5%AD/</link>
            <pubDate>Wed, 06 Nov 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/11/06/%C4%A7%D5%AD/</guid>
            <description>问题描述 有一个魔王总是使用自己的一种非常精练而抽象的语言讲话，没人能听的懂。但他的语言是可以逐步解释成人能懂得语言的，因为他的语言是由以下两种形式的规则由人的语言逐 步抽象上去的：
 （1）α-&amp;gt;β1β2&amp;hellip;βn （2）(θδ1δ2&amp;hellip;δn)-&amp;gt;θδnθδn-1&amp;hellip;θδ1θ   在这两种形式中，从左到右均表示解释；从右到左表示抽象。试写一个魔王解释系统，把他的话解释成人能听懂得话。
 基本要求 用下述两条具体规则和上述规则实现。设大写字母表示魔王语言的词汇；小写字母表示人的语言词汇；希腊字母（a,b1,s,y1等）表示可以用大写或小写字母代换的变量。魔王语言可含人的词汇。
 (1) B-&amp;gt;tAdA (2) A-&amp;gt;sae  测试数据 B（ehnxgz）B 解释成tsaedsaeezegexeneietsaedsae 若将小写字母与汉字建立下表所示的对应关系，则魔王说的话是“天上一个鹅地上一个鹅鹅追鹅赶鹅下鹅蛋鹅恨鹅天上一个鹅地上一个鹅。” t d s a e z g x n i
天 地 上 一个 鹅 追 赶 下 蛋 恨
代码实现 C++ #include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;using namespace std; void solve(char c, stack&amp;lt;char&amp;gt; &amp;amp;S, string &amp;amp;str) { if (c &amp;gt;= &amp;#39;a&amp;#39; &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;z&amp;#39;) { printf(&amp;#34;%c&amp;#34;, c); str += c; } else if (c == &amp;#39;A&amp;#39;) { printf(&amp;#34;sae&amp;#34;); str += &amp;#34;sae&amp;#34;; } else if (c == &amp;#39;B&amp;#39;) { printf(&amp;#34;tsaedsae&amp;#34;); str += &amp;#34;tsaedsae&amp;#34;; } else if (c == &amp;#39;(&amp;#39;) { stack&amp;lt;char&amp;gt; SS; S.</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>有一个魔王总是使用自己的一种非常精练而抽象的语言讲话，没人能听的懂。但他的语言是可以逐步解释成人能懂得语言的，因为他的语言是由以下两种形式的规则由人的语言逐 步抽象上去的：</p>
<ul>
<li>（1）α-&gt;β1β2&hellip;βn</li>
<li>（2）(θδ1δ2&hellip;δn)-&gt;θδnθδn-1&hellip;θδ1θ</li>
</ul>
<blockquote>
<p>在这两种形式中，从左到右均表示解释；从右到左表示抽象。试写一个魔王解释系统，把他的话解释成人能听懂得话。</p>
</blockquote>
<h3 id="基本要求">基本要求</h3>
<p>用下述两条具体规则和上述规则实现。设大写字母表示魔王语言的词汇；小写字母表示人的语言词汇；希腊字母（a,b1,s,y1等）表示可以用大写或小写字母代换的变量。魔王语言可含人的词汇。</p>
<ul>
<li>(1)   B-&gt;tAdA</li>
<li>(2)   A-&gt;sae</li>
</ul>
<h3 id="测试数据">测试数据</h3>
<p>B（ehnxgz）B 解释成tsaedsaeezegexeneietsaedsae
若将小写字母与汉字建立下表所示的对应关系，则魔王说的话是“天上一个鹅地上一个鹅鹅追鹅赶鹅下鹅蛋鹅恨鹅天上一个鹅地上一个鹅。” 
t  d  s  a   e z  g  x  n i<br>
天 地 上 一个 鹅 追 赶 下 蛋 恨</p>
<h3 id="代码实现">代码实现</h3>
<h4 id="c">C++</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;map&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(<span style="color:#66d9ef">char</span> c, stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>S, string <span style="color:#f92672">&amp;</span>str) {
	<span style="color:#66d9ef">if</span> (c <span style="color:#f92672">&gt;=</span> <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#f92672">&amp;&amp;</span> c <span style="color:#f92672">&lt;=</span> <span style="color:#e6db74">&#39;z&#39;</span>) {
		printf(<span style="color:#e6db74">&#34;%c&#34;</span>, c);
		str <span style="color:#f92672">+=</span> c;
	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;A&#39;</span>) {
		printf(<span style="color:#e6db74">&#34;sae&#34;</span>);
		str <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;sae&#34;</span>;
	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;B&#39;</span>) {
		printf(<span style="color:#e6db74">&#34;tsaedsae&#34;</span>);
		str <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;tsaedsae&#34;</span>;
	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span>) {
		stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> SS;
		S.pop();
		<span style="color:#66d9ef">char</span> t <span style="color:#f92672">=</span> S.top();
		S.pop();
		<span style="color:#66d9ef">while</span> (S.top() <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;)&#39;</span>) {
			SS.push(S.top());
			S.pop();
		}
		<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>SS.empty()) {
			printf(<span style="color:#e6db74">&#34;%c&#34;</span>, t);
			str <span style="color:#f92672">+=</span> t;
			solve(SS.top(), S, str);
			SS.pop();
		}
		printf(<span style="color:#e6db74">&#34;%c&#34;</span>, t);
		str <span style="color:#f92672">+=</span> t;
	}
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">translate</span>(string s) {
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">int</span>)s.length(); i<span style="color:#f92672">++</span>) {
		<span style="color:#66d9ef">switch</span> (s[i]) {
		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;t&#39;</span><span style="color:#f92672">:</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;天&#34;</span>; <span style="color:#66d9ef">break</span>;
		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;d&#39;</span><span style="color:#f92672">:</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;地&#34;</span>; <span style="color:#66d9ef">break</span>;
		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;s&#39;</span><span style="color:#f92672">:</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;上&#34;</span>; <span style="color:#66d9ef">break</span>;
		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">:</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;一只&#34;</span>; <span style="color:#66d9ef">break</span>;
		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;e&#39;</span><span style="color:#f92672">:</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;鹅&#34;</span>; <span style="color:#66d9ef">break</span>;
		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;z&#39;</span><span style="color:#f92672">:</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;追&#34;</span>; <span style="color:#66d9ef">break</span>;
		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;g&#39;</span><span style="color:#f92672">:</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;赶&#34;</span>; <span style="color:#66d9ef">break</span>;
		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;x&#39;</span><span style="color:#f92672">:</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;下&#34;</span>; <span style="color:#66d9ef">break</span>;
		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;n&#39;</span><span style="color:#f92672">:</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;蛋&#34;</span>; <span style="color:#66d9ef">break</span>;
		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;h&#39;</span><span style="color:#f92672">:</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;恨&#34;</span>; <span style="color:#66d9ef">break</span>;
		}
	}
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
	string s;
	cin <span style="color:#f92672">&gt;&gt;</span> s;
	reverse(s.begin(), s.end());
	stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> S;
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">int</span>)s.length(); i<span style="color:#f92672">++</span>) {
		S.push(s[i]);
	}
	string str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>S.empty()) {
		solve(S.top(), S, str);
		S.pop();
	}
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
	translate(str);
}
</code></pre></div><h4 id="c-1">C</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define TRUE 1
</span><span style="color:#75715e">#define FALSE 0
</span><span style="color:#75715e">#define OK 1
</span><span style="color:#75715e">#define ERROR 0
</span><span style="color:#75715e">#define INFEASIBLE -1
</span><span style="color:#75715e">#define OVERFLOW -2
</span><span style="color:#75715e">#define MAXSIZE 100
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">char</span> ElemType;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
	ElemType elem[MAXSIZE];
	<span style="color:#66d9ef">int</span> top;
} Stack;

Status <span style="color:#a6e22e">InitStack</span>(Stack <span style="color:#f92672">&amp;</span>S) {
	S.top <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">return</span> OK;
}

Status <span style="color:#a6e22e">Push</span>(Stack <span style="color:#f92672">&amp;</span>S, ElemType e) {
	<span style="color:#66d9ef">if</span> (S.top <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">100</span>)
		<span style="color:#66d9ef">return</span> ERROR;
	S.elem[<span style="color:#f92672">++</span>S.top] <span style="color:#f92672">=</span> e;
	<span style="color:#66d9ef">return</span> OK;
}

Status <span style="color:#a6e22e">Pop</span>(Stack <span style="color:#f92672">&amp;</span>S, ElemType <span style="color:#f92672">*</span>e) {
	<span style="color:#66d9ef">if</span> (S.top <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> ERROR;
	<span style="color:#f92672">*</span>e <span style="color:#f92672">=</span> S.elem[S.top<span style="color:#f92672">--</span>];
	<span style="color:#66d9ef">return</span> OK;
}

Status <span style="color:#a6e22e">IsEmpty</span>(Stack S) {
	<span style="color:#66d9ef">return</span> S.top <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(<span style="color:#66d9ef">char</span> c, Stack <span style="color:#f92672">&amp;</span>S) {
	<span style="color:#66d9ef">if</span> (c <span style="color:#f92672">&gt;=</span> <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#f92672">&amp;&amp;</span> c <span style="color:#f92672">&lt;=</span> <span style="color:#e6db74">&#39;z&#39;</span>) {
		printf(<span style="color:#e6db74">&#34;%c&#34;</span>, c);
	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;A&#39;</span>) {
		printf(<span style="color:#e6db74">&#34;sae&#34;</span>);
	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;B&#39;</span>) {
		printf(<span style="color:#e6db74">&#34;tsaedsae&#34;</span>);
	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span>) {
		Stack SS;
		InitStack(SS);
		<span style="color:#66d9ef">char</span> t;
		<span style="color:#66d9ef">char</span> tmp;
		Pop(S, <span style="color:#f92672">&amp;</span>tmp);
		Pop(S, <span style="color:#f92672">&amp;</span>t);
		<span style="color:#66d9ef">while</span> (S.elem[S.top] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;)&#39;</span>) {
			Push(SS, S.elem[S.top]);
			Pop(S, <span style="color:#f92672">&amp;</span>tmp);
		}
		<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>IsEmpty(SS)) {
			printf(<span style="color:#e6db74">&#34;%c&#34;</span>, t);
			solve(SS.elem[SS.top], S);
			Pop(SS, <span style="color:#f92672">&amp;</span>tmp);
		}
		printf(<span style="color:#e6db74">&#34;%c&#34;</span>, t);
	}
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
	Stack S, S1;
	InitStack(S);
	InitStack(S1);
	<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>s;
	scanf(<span style="color:#e6db74">&#34;%s&#34;</span>, s);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">int</span>)strlen(s); i<span style="color:#f92672">++</span>) {
		Push(S, s[i]);
	}
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">int</span>)strlen(s); i<span style="color:#f92672">++</span>) {
		<span style="color:#66d9ef">char</span> tmp;
		Pop(S, <span style="color:#f92672">&amp;</span>tmp);
		Push(S1, tmp);
	}
	<span style="color:#66d9ef">char</span> t;
	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>IsEmpty(S1)) {
		solve(S1.elem[S1.top], S1);
		Pop(S1, <span style="color:#f92672">&amp;</span>t);
	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>二叉树的创建和遍历</title>
            <link>https://fffzlfk.gitlab.io/2019/10/30/%C4%B5%CD%B1/</link>
            <pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/10/30/%C4%B5%CD%B1/</guid>
            <description>问题描述 用C语言实现二叉树的表示及非递归中序遍历算法（没啥说的直接上代码）
代码实现 #include &amp;lt;iostream&amp;gt;#include &amp;lt;stack&amp;gt; #define MAXSIZE 1000 #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2  typedef int Status; typedef char ElemType; using namespace std; typedef struct BiTNode { ElemType data; struct BiTNode *lchild, *rchild; } BiTNode, * BiTree; Status CreateBiTree(BiTree &amp;amp;T) { ElemType ch; scanf(&amp;#34;%c&amp;#34;, &amp;amp;ch); getchar(); if (ch == &amp;#39; &amp;#39;) T = NULL; else { if (!</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>用C语言实现二叉树的表示及非递归中序遍历算法（没啥说的直接上代码）</p>
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define MAXSIZE 1000
</span><span style="color:#75715e">#define TRUE 1
</span><span style="color:#75715e">#define FALSE 0
</span><span style="color:#75715e">#define OK 1
</span><span style="color:#75715e">#define ERROR 0
</span><span style="color:#75715e">#define INFEASIBLE -1
</span><span style="color:#75715e">#define OVERFLOW -2
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">char</span> ElemType;

<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BiTNode</span> {
	ElemType data;
	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BiTNode</span> <span style="color:#f92672">*</span>lchild, <span style="color:#f92672">*</span>rchild;
} BiTNode, <span style="color:#f92672">*</span> BiTree;

Status <span style="color:#a6e22e">CreateBiTree</span>(BiTree <span style="color:#f92672">&amp;</span>T) {
	ElemType ch;
	scanf(<span style="color:#e6db74">&#34;%c&#34;</span>, <span style="color:#f92672">&amp;</span>ch);
	getchar();
	<span style="color:#66d9ef">if</span> (ch <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39; &#39;</span>) T <span style="color:#f92672">=</span> NULL;
	<span style="color:#66d9ef">else</span> {
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(T <span style="color:#f92672">=</span> (BiTNode<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(BiTNode)))) exit(OVERFLOW);
		T<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> ch;
		printf(<span style="color:#e6db74">&#34;输入%c的左孩子</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, T<span style="color:#f92672">-&gt;</span>data);
		CreateBiTree(T<span style="color:#f92672">-&gt;</span>lchild);
		printf(<span style="color:#e6db74">&#34;输入%c的右孩子</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, T<span style="color:#f92672">-&gt;</span>data);
		CreateBiTree(T<span style="color:#f92672">-&gt;</span>rchild);
	}
	<span style="color:#66d9ef">return</span> OK;
}
<span style="color:#75715e">//中序遍历二叉树的非递归算法
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">InOrderTraverse</span>(BiTree T, Status (<span style="color:#f92672">*</span>Visit)(ElemType e)) {
	stack<span style="color:#f92672">&lt;</span>BiTNode<span style="color:#f92672">*&gt;</span> S;
	S.push(T);
	BiTNode <span style="color:#f92672">*</span>p;
	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>S.empty()) {
		<span style="color:#66d9ef">while</span> (p <span style="color:#f92672">=</span> S.top()) S.push(p<span style="color:#f92672">-&gt;</span>lchild);
		p <span style="color:#f92672">=</span> S.top();
		S.pop();
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>S.empty()) {
			p <span style="color:#f92672">=</span> S.top();
			S.pop();
			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>Visit(p<span style="color:#f92672">-&gt;</span>data))
				<span style="color:#66d9ef">return</span> ERROR;
			S.push(p<span style="color:#f92672">-&gt;</span>rchild);
		}
	}
	<span style="color:#66d9ef">return</span> OK;
}

Status <span style="color:#a6e22e">Visit</span>(ElemType e) {
	printf(<span style="color:#e6db74">&#34;%c</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, e);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
	BiTree T;
	CreateBiTree(T);
	InOrderTraverse(T, Visit);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>链栈</title>
            <link>https://fffzlfk.gitlab.io/2019/10/23/%D5%BB%CA%B5/</link>
            <pubDate>Wed, 23 Oct 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/10/23/%D5%BB%CA%B5/</guid>
            <description>简介 链栈一般用一个头指针结构top来表示，它指向栈顶元素，对于链表来说，top结构相当于它的头指针head。
代码实现 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; struct Node { int data; Node *next; }; typedef struct { Node *top; int count; } * Stack; void InitStack(Stack &amp;amp;s) { s-&amp;gt;top = (Node*)malloc(sizeof(Node)); if (!s-&amp;gt;top) { puts(&amp;#34;ERROR&amp;#34;); return; } s-&amp;gt;top = NULL; s-&amp;gt;count = 0; } void Push(Stack &amp;amp;s, int e) { Node *node = (Node*)malloc(sizeof(Node)); node-&amp;gt;data = e; node-&amp;gt;next = s-&amp;gt;top; s-&amp;gt;top = node; s-&amp;gt;count++; } int Pop(Stack &amp;amp;s) { if (s-&amp;gt;count == 0) { puts(&amp;#34;Empty&amp;#34;); exit(0); } Node *t = s-&amp;gt;top; s-&amp;gt;top = s-&amp;gt;top-&amp;gt;next; int e = t-&amp;gt;data; free(t); s-&amp;gt;count--; return e; } void ClearStack(Stack &amp;amp;s) { if (s-&amp;gt;count == 0) return; Node *p, *q; p = s-&amp;gt;top; while (p) { q = p; p = p-&amp;gt;next; free(q); } s-&amp;gt;count = 0; } int main(int argc, char const *argv[]) { Stack s; InitStack(s); for (int i = 0; i &amp;lt; 10; i++) Push(s, i); // ClearStack(s); 	printf(&amp;#34;%d\n&amp;#34;, Pop(s)); Push(s, 100); for (int i = 0; i &amp;lt; 11; i++) { printf(&amp;#34;%d\n&amp;#34;, Pop(s)); } return 0; } </description>
            <content type="html"><![CDATA[<h3 id="简介">简介</h3>
<p>链栈一般用一个头指针结构top来表示，它指向栈顶元素，对于链表来说，top结构相当于它的头指针head。</p>
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> Node {
	<span style="color:#66d9ef">int</span> data;
	Node <span style="color:#f92672">*</span>next;
};

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
	Node <span style="color:#f92672">*</span>top;
	<span style="color:#66d9ef">int</span> count;
} <span style="color:#f92672">*</span> Stack;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitStack</span>(Stack <span style="color:#f92672">&amp;</span>s) {
	s<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> (Node<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>s<span style="color:#f92672">-&gt;</span>top) {
		puts(<span style="color:#e6db74">&#34;ERROR&#34;</span>);
		<span style="color:#66d9ef">return</span>;
	}
	s<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> NULL;
	s<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Push</span>(Stack <span style="color:#f92672">&amp;</span>s, <span style="color:#66d9ef">int</span> e) {
	Node <span style="color:#f92672">*</span>node <span style="color:#f92672">=</span> (Node<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
	node<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> e;
	node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>top;
	s<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> node;
	s<span style="color:#f92672">-&gt;</span>count<span style="color:#f92672">++</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Pop</span>(Stack <span style="color:#f92672">&amp;</span>s) {
	<span style="color:#66d9ef">if</span> (s<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
		puts(<span style="color:#e6db74">&#34;Empty&#34;</span>);
		exit(<span style="color:#ae81ff">0</span>);
	}
	Node <span style="color:#f92672">*</span>t <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>top;
	s<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>top<span style="color:#f92672">-&gt;</span>next;
	<span style="color:#66d9ef">int</span> e <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>data;
	free(t);
	s<span style="color:#f92672">-&gt;</span>count<span style="color:#f92672">--</span>;
	<span style="color:#66d9ef">return</span> e;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ClearStack</span>(Stack <span style="color:#f92672">&amp;</span>s) {
	<span style="color:#66d9ef">if</span> (s<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span>;
	Node <span style="color:#f92672">*</span>p, <span style="color:#f92672">*</span>q;
	p <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>top;
	<span style="color:#66d9ef">while</span> (p) {
		q <span style="color:#f92672">=</span> p;
		p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
		free(q);
	}
	s<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
	Stack s;
	InitStack(s);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>)
		Push(s, i);
	<span style="color:#75715e">// ClearStack(s);
</span><span style="color:#75715e"></span>	printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, Pop(s));
	Push(s, <span style="color:#ae81ff">100</span>);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">11</span>; i<span style="color:#f92672">++</span>) {
		printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, Pop(s));
	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>删除子串</title>
            <link>https://fffzlfk.gitlab.io/2019/10/21/%C9%BE%D3%B5/</link>
            <pubDate>Mon, 21 Oct 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/10/21/%C9%BE%D3%B5/</guid>
            <description>问题描述 删除s中所有与t相同的子串
 如 s = &amp;ldquo;abcdabcdabcd&amp;rdquo;, t = &amp;ldquo;cd&amp;rdquo;, 则操作后s = &amp;ldquo;ababab&amp;rdquo;
 代码实现 #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std; int* GetNext(string p) { int pLen = p.length(); int *next = new int[pLen]; next[0] = -1; int j = 0; int k = -1; while (j &amp;lt; pLen - 1) { if (k == -1 || p[j] == p[k]) { j++; k++; next[j] = k; } else { j = next[j]; } } return next; } void solve(string &amp;amp;s, string p) { int* next =GetNext(p); int sLen = s.</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>删除s中所有与t相同的子串</p>
<blockquote>
<p>如 s = &ldquo;abcdabcdabcd&rdquo;, t = &ldquo;cd&rdquo;, 则操作后s = &ldquo;ababab&rdquo;</p>
</blockquote>
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">GetNext</span>(string p) {
  <span style="color:#66d9ef">int</span> pLen <span style="color:#f92672">=</span> p.length();
  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>next <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[pLen];
  next[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
  <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
  <span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&lt;</span> pLen <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
    <span style="color:#66d9ef">if</span> (k <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> p[j] <span style="color:#f92672">==</span> p[k]) {
      j<span style="color:#f92672">++</span>;
      k<span style="color:#f92672">++</span>;
      next[j] <span style="color:#f92672">=</span> k;
    } <span style="color:#66d9ef">else</span> {
      j <span style="color:#f92672">=</span> next[j];
    }
  }
  <span style="color:#66d9ef">return</span> next;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(string <span style="color:#f92672">&amp;</span>s, string p) {
  <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> next <span style="color:#f92672">=</span>GetNext(p);
  <span style="color:#66d9ef">int</span> sLen <span style="color:#f92672">=</span> s.length();
  <span style="color:#66d9ef">int</span> pLen <span style="color:#f92672">=</span> p.length();
  <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> sLen <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;</span> pLen) {
    <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> s[i] <span style="color:#f92672">==</span> p[j]) {
      i<span style="color:#f92672">++</span>;
      j<span style="color:#f92672">++</span>;
    } <span style="color:#66d9ef">else</span> {
      j <span style="color:#f92672">=</span> next[j];
    }
  }
  <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> pLen) {
    s.erase(i<span style="color:#f92672">-</span>j, j);
    solve(s, p);
  } <span style="color:#66d9ef">else</span> {
    <span style="color:#66d9ef">return</span>;
  }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
  string s, p;
  cin <span style="color:#f92672">&gt;&gt;</span> s <span style="color:#f92672">&gt;&gt;</span> p;
  solve(s, p);
  cout <span style="color:#f92672">&lt;&lt;</span> s <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>求最长重复子串及其位置</title>
            <link>https://fffzlfk.gitlab.io/2019/10/19/%D8%B8%D3%B5%CE%BB/</link>
            <pubDate>Sat, 19 Oct 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/10/19/%D8%B8%D3%B5%CE%BB/</guid>
            <description>问题描述 给出一个线性排列的串s，求出s中出现的第一个最长重复子串及其位置；并分析时间复杂度。
 例如 s = &amp;ldquo;abcdbcd&amp;rdquo;，它的第一个出现的最长重复子串及其位置分别为：&amp;ldquo;bcd，1&amp;rdquo;。
 代码实现 #include &amp;lt;iostream&amp;gt;using namespace std; int* GetNext(string p) { int pLen = p.length(); int* next = new int[pLen]; next[0] = -1; int j = 0; int k = -1; while (j &amp;lt; pLen - 1) { if (k == -1 || p[k] == p[j]) { k++; j++; if (p[k] != p[j]) { next[j] = k; } else { next[j] = next[k]; } } else { k = next[k]; } } return next; } int KmpSearch(string s, string p) { int *next = GetNext(p); int sLen = s.</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>给出一个线性排列的串s，求出s中出现的第一个最长重复子串及其位置；并分析时间复杂度。</p>
<blockquote>
<p>例如 s = &ldquo;abcdbcd&rdquo;，它的第一个出现的最长重复子串及其位置分别为：&ldquo;bcd，1&rdquo;。</p>
</blockquote>
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">GetNext</span>(string p) {
	<span style="color:#66d9ef">int</span> pLen <span style="color:#f92672">=</span> p.length();
	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> next <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[pLen];
	next[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&lt;</span> pLen <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
		<span style="color:#66d9ef">if</span> (k <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> p[k] <span style="color:#f92672">==</span> p[j]) {
			k<span style="color:#f92672">++</span>;
			j<span style="color:#f92672">++</span>;
			<span style="color:#66d9ef">if</span> (p[k] <span style="color:#f92672">!=</span> p[j]) {
				next[j] <span style="color:#f92672">=</span> k;
			} <span style="color:#66d9ef">else</span> {
				next[j] <span style="color:#f92672">=</span> next[k];
			}
		} <span style="color:#66d9ef">else</span> {
			k <span style="color:#f92672">=</span> next[k];
		}
	}
	<span style="color:#66d9ef">return</span> next;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">KmpSearch</span>(string s, string p) {
	<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>next <span style="color:#f92672">=</span> GetNext(p);
	<span style="color:#66d9ef">int</span> sLen <span style="color:#f92672">=</span> s.length();
	<span style="color:#66d9ef">int</span> pLen <span style="color:#f92672">=</span> p.length();
	<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> sLen <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;</span> pLen) {
		<span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> s[i] <span style="color:#f92672">==</span> p[j]) {
			i<span style="color:#f92672">++</span>;
			j<span style="color:#f92672">++</span>;
		} <span style="color:#66d9ef">else</span> {
			j <span style="color:#f92672">=</span> next[j];
		}
	}
	<span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> pLen)
		<span style="color:#66d9ef">return</span> i <span style="color:#f92672">-</span> pLen;
	<span style="color:#66d9ef">else</span>
		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(string s, string <span style="color:#f92672">&amp;</span>p, <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>pos) {
	<span style="color:#66d9ef">int</span> sLen <span style="color:#f92672">=</span> s.length();
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> sLen <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>; i<span style="color:#f92672">++</span>) {
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> sLen <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&gt;=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; j<span style="color:#f92672">--</span>) {
			string prep <span style="color:#f92672">=</span> s.substr(i, j <span style="color:#f92672">-</span> i);
			string end <span style="color:#f92672">=</span> s.substr(j, sLen <span style="color:#f92672">-</span> j);
			<span style="color:#66d9ef">if</span> (KmpSearch(end, prep) <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
				p <span style="color:#f92672">=</span> prep;
				pos <span style="color:#f92672">=</span> i;
				<span style="color:#66d9ef">return</span>;
			}
		}
	}
	pos <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[])
{
	string s;
	cin <span style="color:#f92672">&gt;&gt;</span> s;
	string p;
	<span style="color:#66d9ef">int</span> pos;
	solve(s, p, pos);
	<span style="color:#66d9ef">if</span> (pos <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
		cout <span style="color:#f92672">&lt;&lt;</span> p <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">&lt;&lt;</span> pos <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
	} <span style="color:#66d9ef">else</span> {
		cout <span style="color:#f92672">&lt;&lt;</span> pos <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="时间复杂度分析">时间复杂度分析</h3>
<p>主要算法复杂度为O(n^2), 而其中的kmp算法时间复杂度为O(n),则整个算法复杂度为O(n^3)。</p>
]]></content>
        </item>
        
        <item>
            <title>KMP算法</title>
            <link>https://fffzlfk.gitlab.io/2019/10/13/kmp%E3%B7%A8/</link>
            <pubDate>Sun, 13 Oct 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/10/13/kmp%E3%B7%A8/</guid>
            <description>KMP算法描述  算法流程   设文本串匹配到i，模式串匹配到j
  若j == -1或者匹配成功(s[i] == p[j])，则i++，j++； 若j != -1且匹配不成功，则j = next[j]（相当于模式串p相对于文本串s向右移动(j - next[j])位）。  得到next数组   next数组表示当前字符之前的字符串中，有多大长度的相同前缀后缀
 对于P的前j+1个序列字符：
 若p[k] == p[j]，则next[j + 1 ] = next [j] + 1 = k + 1； 若p[k ] ≠ p[j]，如果此时p[ next[k] ] == p[j ]，则next[ j + 1 ] = next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。  代码实现 C语言 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt; #define MAXN 100  int* GetNext(char* p) { int pLen = strlen(p); int j = 0; int k = -1; int* next = new int[strlen(p)]; next[0] = -1; while (j &amp;lt; pLen - 1) { if (k == -1 || p[j] == p[k]) { j++; k++; if (p[j] !</description>
            <content type="html"><![CDATA[<h3 id="kmp算法描述">KMP算法描述</h3>
<ol>
<li>算法流程</li>
</ol>
<blockquote>
<p>设文本串匹配到i，模式串匹配到j</p>
</blockquote>
<ul>
<li>若j == -1或者匹配成功(s[i] == p[j])，则i++，j++；</li>
<li>若j != -1且匹配不成功，则j = next[j]（相当于模式串p相对于文本串s向右移动(j - next[j])位）。</li>
</ul>
<ol start="2">
<li>得到next数组</li>
</ol>
<blockquote>
<p>next数组表示当前字符之前的字符串中，有多大长度的相同前缀后缀</p>
</blockquote>
<p>对于P的前j+1个序列字符：</p>
<ul>
<li>若p[k] == p[j]，则next[j + 1 ] = next [j] + 1 = k + 1；</li>
<li>若p[k ] ≠ p[j]，如果此时p[ next[k] ] == p[j ]，则next[ j + 1 ] =  next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。</li>
</ul>
<h3 id="代码实现">代码实现</h3>
<h4 id="c语言">C语言</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define MAXN 100
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">GetNext</span>(<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> p) {
	<span style="color:#66d9ef">int</span> pLen <span style="color:#f92672">=</span> strlen(p);
	<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> next <span style="color:#f92672">=</span> new <span style="color:#66d9ef">int</span>[strlen(p)];
	next[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&lt;</span> pLen <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
		<span style="color:#66d9ef">if</span> (k <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> p[j] <span style="color:#f92672">==</span> p[k]) {
			j<span style="color:#f92672">++</span>;
			k<span style="color:#f92672">++</span>;
			<span style="color:#66d9ef">if</span> (p[j] <span style="color:#f92672">!=</span> p[k]) {
				next[j] <span style="color:#f92672">=</span> k;
			} <span style="color:#66d9ef">else</span> {
				next[j] <span style="color:#f92672">=</span> next[k];
			}
		} <span style="color:#66d9ef">else</span> {
			k <span style="color:#f92672">=</span> next[k];
		}
	}
	<span style="color:#66d9ef">return</span> next;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">KmpSearch</span>(<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> s, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> p, <span style="color:#66d9ef">int</span> next[]) {
	<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">int</span> pLen <span style="color:#f92672">=</span> strlen(p);
	<span style="color:#66d9ef">int</span> sLen <span style="color:#f92672">=</span> strlen(s);
	<span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> sLen <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;</span> pLen) {
		<span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> s[i] <span style="color:#f92672">==</span> p[j]) {
			i<span style="color:#f92672">++</span>;
			j<span style="color:#f92672">++</span>;
		} <span style="color:#66d9ef">else</span> {
			j <span style="color:#f92672">=</span> next[j];
		}
	}
	<span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> pLen)
		<span style="color:#66d9ef">return</span> i <span style="color:#f92672">-</span> j;
	<span style="color:#66d9ef">else</span>
		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[])
{
	<span style="color:#66d9ef">char</span> s[<span style="color:#ae81ff">10</span>];
	<span style="color:#66d9ef">char</span> p[<span style="color:#ae81ff">10</span>];
	<span style="color:#66d9ef">while</span> (scanf(<span style="color:#e6db74">&#34;%s%s&#34;</span>, s, p) <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) {
		printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, KmpSearch(s, p, GetNext(p)));
	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="java">Java</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Kmp</span> <span style="color:#f92672">{</span>
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">getNext</span><span style="color:#f92672">(</span>String p<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
		<span style="color:#66d9ef">int</span> next<span style="color:#f92672">[]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">()];</span>
		next<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
		<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
		<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
		<span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>j <span style="color:#f92672">&lt;</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">()</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
			<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>k <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>1 <span style="color:#f92672">||</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>j<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>k<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
				j<span style="color:#f92672">++;</span>
				k<span style="color:#f92672">++;</span>
				<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>j<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>k<span style="color:#f92672">))</span>
					next<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> k<span style="color:#f92672">;</span>
				<span style="color:#66d9ef">else</span>
					next<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> next<span style="color:#f92672">[</span>k<span style="color:#f92672">];</span>
			<span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
				k <span style="color:#f92672">=</span> next<span style="color:#f92672">[</span>k<span style="color:#f92672">];</span>
			<span style="color:#f92672">}</span>
		<span style="color:#f92672">}</span>
		<span style="color:#66d9ef">return</span> next<span style="color:#f92672">;</span>
	<span style="color:#f92672">}</span>

	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">kmpSearch</span><span style="color:#f92672">(</span>String s<span style="color:#f92672">,</span> String p<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">[]</span>next<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
		<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
		<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
		<span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&lt;</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">()</span> <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
			<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>j <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>1 <span style="color:#f92672">||</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>j<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
				i<span style="color:#f92672">++;</span>
				j<span style="color:#f92672">++;</span>
			<span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
				j <span style="color:#f92672">=</span> next<span style="color:#f92672">[</span>j<span style="color:#f92672">];</span>
			<span style="color:#f92672">}</span>
		<span style="color:#f92672">}</span>
		<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>j <span style="color:#f92672">==</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">())</span>
			<span style="color:#66d9ef">return</span> i <span style="color:#f92672">-</span> j<span style="color:#f92672">;</span>
		<span style="color:#66d9ef">else</span>
			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
	<span style="color:#f92672">}</span>

	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
		String s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;abacababc&#34;</span><span style="color:#f92672">;</span>
		String p <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;abab&#34;</span><span style="color:#f92672">;</span>
		System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>kmpSearch<span style="color:#f92672">(</span>s<span style="color:#f92672">,</span> p<span style="color:#f92672">,</span> getNext<span style="color:#f92672">(</span>p<span style="color:#f92672">)));</span>
	<span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>循环队列</title>
            <link>https://fffzlfk.gitlab.io/2019/10/10/%D1%AD/</link>
            <pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/10/10/%D1%AD/</guid>
            <description>问题描述 如果希望循环队列的每一个元素都能用到，需设置一个标志域tag，用tag的0或1来区分是否满队列。试写出这种结构的算法，并从时间和空间分析这两种这两种方法的适用范围。
带标志域（tag）的算法实现 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2  typedef int Status; typedef int ElemType; #define MAXSIZE 100 typedef struct { ElemType *base; int front; int rear; int tag; } SqQueue; Status InitQueue(SqQueue &amp;amp;Q) { Q.base = (ElemType*) malloc(MAXSIZE * sizeof(ElemType)); if (!Q.base) exit(OVERFLOW); Q.front = Q.rear = 0; Q.tag = 0; return OK; } int QueueLength(SqQueue Q) { return (Q.</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>如果希望循环队列的每一个元素都能用到，需设置一个标志域tag，用tag的0或1来区分是否满队列。试写出这种结构的算法，并从时间和空间分析这两种这两种方法的适用范围。</p>
<h3 id="带标志域tag的算法实现">带标志域（tag）的算法实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define TRUE 1
</span><span style="color:#75715e">#define FALSE 0
</span><span style="color:#75715e">#define OK 1
</span><span style="color:#75715e">#define ERROR 0
</span><span style="color:#75715e">#define INFEASIBLE -1
</span><span style="color:#75715e">#define OVERFLOW -2
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> ElemType;
<span style="color:#75715e">#define MAXSIZE 100
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
	ElemType <span style="color:#f92672">*</span>base;
	<span style="color:#66d9ef">int</span> front;
	<span style="color:#66d9ef">int</span> rear;
	<span style="color:#66d9ef">int</span> tag;
} SqQueue;

Status <span style="color:#a6e22e">InitQueue</span>(SqQueue <span style="color:#f92672">&amp;</span>Q) {
	Q.base <span style="color:#f92672">=</span> (ElemType<span style="color:#f92672">*</span>) malloc(MAXSIZE <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(ElemType));
	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>Q.base) exit(OVERFLOW);
	Q.front <span style="color:#f92672">=</span> Q.rear <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	Q.tag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">return</span> OK;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">QueueLength</span>(SqQueue Q) {
	<span style="color:#66d9ef">return</span> (Q.rear <span style="color:#f92672">-</span> Q.front <span style="color:#f92672">+</span> MAXSIZE) <span style="color:#f92672">%</span> MAXSIZE;
}

Status <span style="color:#a6e22e">EnQueue</span>(SqQueue <span style="color:#f92672">&amp;</span>Q, ElemType e) {
	<span style="color:#66d9ef">if</span> (Q.rear <span style="color:#f92672">==</span> Q.front <span style="color:#f92672">&amp;&amp;</span> Q.tag <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
		puts(<span style="color:#e6db74">&#34;队列已满&#34;</span>);
		<span style="color:#66d9ef">return</span> ERROR;
	}
	Q.tag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
	Q.base[Q.rear] <span style="color:#f92672">=</span> e;
	Q.rear <span style="color:#f92672">=</span> (Q.rear <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> MAXSIZE;
	<span style="color:#66d9ef">return</span> OK;
}

Status <span style="color:#a6e22e">Dequeue</span>(SqQueue <span style="color:#f92672">&amp;</span>Q, ElemType <span style="color:#f92672">&amp;</span>e) {
	<span style="color:#66d9ef">if</span> (Q.rear <span style="color:#f92672">==</span> Q.front <span style="color:#f92672">&amp;&amp;</span> Q.tag <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
		puts(<span style="color:#e6db74">&#34;队列为空&#34;</span>);
		<span style="color:#66d9ef">return</span> ERROR;
	}
	Q.tag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	e <span style="color:#f92672">=</span> Q.base[Q.front];
	Q.front <span style="color:#f92672">=</span> (Q.front <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> MAXSIZE;
	<span style="color:#66d9ef">return</span> OK;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[])
{
	SqQueue q;
	InitQueue(q);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>)
		EnQueue(q, i);
	printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, QueueLength(q));
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">100</span>; i<span style="color:#f92672">++</span>) {
		ElemType t;
		Dequeue(q, t);
		printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, t);
	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="分析讨论">分析讨论</h3>
<ol>
<li>时间：使用标志域需要在每次出入队的时候对tag进行赋值；</li>
<li>空间：使用标志域需要给每一个元素开辟另外的内存。
综合上述两点，当循环队列容量较小而每一个元素所占空间较多时，使用设标志域的方法可以充分使用内存；而当循环队列容量较大且每个元素所占空间较少时，使用少用一个元素空间的方法相比设标志域的方法可以节省内存。</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>括号匹配</title>
            <link>https://fffzlfk.gitlab.io/2019/10/09/%C6%A5/</link>
            <pubDate>Wed, 09 Oct 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/10/09/%C6%A5/</guid>
            <description>问题描述 假设一个算术表达式中可以包含三种括号：圆括号&#39;(&amp;lsquo;和&amp;rsquo;)&#39;、方括号&#39;[&amp;lsquo;和 &amp;lsquo;]&amp;lsquo;以及花括号&amp;rsquo;{&amp;lsquo;和&amp;rsquo;}&#39;。编写判别所给表达式中所含括号是否正确。
解决方法 可用“期待匹配消解”的思想来设计算法，对表达式中每一个左括号都期待一个相应的右括号与之匹配，且自左至右按表达式中出现的先后论，越迟的左括号期待匹配的渴望程度越高。
代码实现 #include &amp;lt;iostream&amp;gt;#include &amp;lt;stack&amp;gt; using namespace std; bool is_march(string str) { stack&amp;lt;char&amp;gt; s; for (int i = 0; i &amp;lt; (int)str.length(); i++) { switch (str[i]) { case &amp;#39;(&amp;#39;: case &amp;#39;[&amp;#39;: case &amp;#39;{&amp;#39;: s.push(str[i]); break; case &amp;#39;)&amp;#39;: if (s.empty() || s.top() != &amp;#39;(&amp;#39;) return false; else s.pop(); break; case &amp;#39;]&amp;#39;: if (s.empty() || s.top() != &amp;#39;[&amp;#39;) return false; else s.pop(); break; case &amp;#39;}&amp;#39;: if (s.empty() || s.</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>假设一个算术表达式中可以包含三种括号：圆括号'(&lsquo;和&rsquo;)'、方括号'[&lsquo;和 &lsquo;]&lsquo;以及花括号&rsquo;{&lsquo;和&rsquo;}'。编写判别所给表达式中所含括号是否正确。</p>
<h3 id="解决方法">解决方法</h3>
<p>可用“期待匹配消解”的思想来设计算法，对表达式中每一个左括号都期待一个相应的右括号与之匹配，且自左至右按表达式中出现的先后论，越迟的左括号期待匹配的渴望程度越高。</p>
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">is_march</span>(string str) {
	stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> s;
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">int</span>)str.length(); i<span style="color:#f92672">++</span>) {
		<span style="color:#66d9ef">switch</span> (str[i]) {
		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;(&#39;</span><span style="color:#f92672">:</span>
		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;[&#39;</span><span style="color:#f92672">:</span>
		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;{&#39;</span><span style="color:#f92672">:</span> s.push(str[i]); <span style="color:#66d9ef">break</span>;
		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;)&#39;</span><span style="color:#f92672">:</span>
			<span style="color:#66d9ef">if</span> (s.empty() <span style="color:#f92672">||</span> s.top() <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;(&#39;</span>)
				<span style="color:#66d9ef">return</span> false;
			<span style="color:#66d9ef">else</span>
				s.pop();
			<span style="color:#66d9ef">break</span>;
		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;]&#39;</span><span style="color:#f92672">:</span>
			<span style="color:#66d9ef">if</span> (s.empty() <span style="color:#f92672">||</span> s.top() <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;[&#39;</span>)
				<span style="color:#66d9ef">return</span> false;
			<span style="color:#66d9ef">else</span>
				s.pop();
			<span style="color:#66d9ef">break</span>;
		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;}&#39;</span><span style="color:#f92672">:</span>
			<span style="color:#66d9ef">if</span> (s.empty() <span style="color:#f92672">||</span> s.top() <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;{&#39;</span>)
				<span style="color:#66d9ef">return</span> false;
			<span style="color:#66d9ef">else</span>
				s.pop();
			<span style="color:#66d9ef">break</span>;
		}
	}
	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>s.empty()) <span style="color:#66d9ef">return</span> false;
	<span style="color:#66d9ef">return</span> true;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[])
{
	string s;
	<span style="color:#66d9ef">while</span> (cin <span style="color:#f92672">&gt;&gt;</span> s) {
		<span style="color:#66d9ef">if</span> (is_march(s))
			puts(<span style="color:#e6db74">&#34;YES&#34;</span>);
		<span style="color:#66d9ef">else</span>
			puts(<span style="color:#e6db74">&#34;NO&#34;</span>);
	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="参考">参考</h3>
<p>参考《数据结构（C语言版）》&ndash;严蔚敏</p>
]]></content>
        </item>
        
        <item>
            <title>表达式求值</title>
            <link>https://fffzlfk.gitlab.io/2019/09/29/%CA%BD%D6%B5/</link>
            <pubDate>Sun, 29 Sep 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/09/29/%CA%BD%D6%B5/</guid>
            <description>问题描述 表达式求值是一个基本问题，是栈的一个应用。如计算： 输入&#39;#&amp;lsquo;代表结束。
算法基本思想 使用两个工作栈，一个存运算符(optr)，另一个存操作数或运算结果(opnd)。
 首先将&amp;rsquo;#&amp;lsquo;push到optr； 依次读入每个字符，若是操作数则进opnd（注意多位数情况），若为运算符则于比较optr栈顶运算符比较优先级完成相应操作。  代码实现 #include &amp;lt;iostream&amp;gt;#include &amp;lt;stack&amp;gt; using namespace std; int prec(char a, char b) { if (a == &amp;#39;+&amp;#39; || a == &amp;#39;-&amp;#39;) { if (b == &amp;#39;+&amp;#39; || b == &amp;#39;-&amp;#39; || b == &amp;#39;)&amp;#39; || b == &amp;#39;#&amp;#39;) return 1; else return -1; } else if (a == &amp;#39;*&amp;#39; || a == &amp;#39;/&amp;#39;) { if (b == &amp;#39;(&amp;#39;) return -1; else return 1; } else if (a == &amp;#39;(&amp;#39; || a == &amp;#39;#&amp;#39;) { if (a == &amp;#39;(&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;)&amp;#39;) return 0; else if (a == &amp;#39;(&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;#&amp;#39;) return -2; else if (a == &amp;#39;#&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;)&amp;#39;) return -2; else if (a == &amp;#39;#&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;#&amp;#39;) return 0; else return -1; } else if (a == &amp;#39;)&amp;#39;) { if (b == &amp;#39;(&amp;#39;) return -2; else return 1; } return -2; } int Operate(int a, int b, char c) { if (c == &amp;#39;+&amp;#39;) return a + b; else if (c == &amp;#39;-&amp;#39;) return a - b; else if (c == &amp;#39;*&amp;#39;) return a * b; else if (c == &amp;#39;/&amp;#39;) return a / b; else exit(0); } int EvaluateExpression(string s) { stack&amp;lt;char&amp;gt; optr; stack&amp;lt;int&amp;gt; opnd; optr.</description>
            <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>表达式求值是一个基本问题，是栈的一个应用。如计算：
<img src="http://latex.codecogs.com/gif.latex?%5C%7B12*(7-3)#=?%7D" alt="">
输入'#&lsquo;代表结束。</p>
<h3 id="算法基本思想">算法基本思想</h3>
<p>使用两个工作栈，一个存运算符(optr)，另一个存操作数或运算结果(opnd)。</p>
<ol>
<li>首先将&rsquo;#&lsquo;push到optr；</li>
<li>依次读入每个字符，若是操作数则进opnd（注意多位数情况），若为运算符则于比较optr栈顶运算符比较优先级完成相应操作。</li>
</ol>
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">prec</span>(<span style="color:#66d9ef">char</span> a, <span style="color:#66d9ef">char</span> b) {
	<span style="color:#66d9ef">if</span> (a <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#f92672">||</span> a <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;-&#39;</span>) {
		<span style="color:#66d9ef">if</span> (b <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#f92672">||</span> b <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;-&#39;</span> <span style="color:#f92672">||</span> b <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;)&#39;</span> <span style="color:#f92672">||</span> b <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;#&#39;</span>)
			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (a <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;*&#39;</span> <span style="color:#f92672">||</span> a <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;/&#39;</span>) {
		<span style="color:#66d9ef">if</span> (b <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (a <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span> <span style="color:#f92672">||</span> a <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;#&#39;</span>) {
		<span style="color:#66d9ef">if</span> (a <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span> <span style="color:#f92672">&amp;&amp;</span> b <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;)&#39;</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (a <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span> <span style="color:#f92672">&amp;&amp;</span> b <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;#&#39;</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>;
		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (a <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;#&#39;</span> <span style="color:#f92672">&amp;&amp;</span> b <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;)&#39;</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>;
		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (a <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;#&#39;</span> <span style="color:#f92672">&amp;&amp;</span> b <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;#&#39;</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (a <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;)&#39;</span>) {
		<span style="color:#66d9ef">if</span> (b <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>;
		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
	}
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Operate</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b, <span style="color:#66d9ef">char</span> c) {
	<span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;+&#39;</span>) <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b;
	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;-&#39;</span>) <span style="color:#66d9ef">return</span> a <span style="color:#f92672">-</span> b;
	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;*&#39;</span>) <span style="color:#66d9ef">return</span> a <span style="color:#f92672">*</span> b;
	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;/&#39;</span>) <span style="color:#66d9ef">return</span> a <span style="color:#f92672">/</span> b;
	<span style="color:#66d9ef">else</span> exit(<span style="color:#ae81ff">0</span>);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">EvaluateExpression</span>(string s) {
	stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> optr;
	stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> opnd;
	optr.push(<span style="color:#e6db74">&#39;#&#39;</span>);
	<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">while</span> (s[i] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;#&#39;</span> <span style="color:#f92672">||</span> optr.top() <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;#&#39;</span>) {
		<span style="color:#66d9ef">if</span> (isdigit(s[i])) {
			<span style="color:#66d9ef">while</span> (isdigit(s[i])) {
				num <span style="color:#f92672">=</span> num <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">+</span> (s[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>);
				i<span style="color:#f92672">++</span>;
			}
			opnd.push(num);
		} <span style="color:#66d9ef">else</span> {
			num <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
			<span style="color:#66d9ef">switch</span> (prec(optr.top(), s[i])) {
			<span style="color:#66d9ef">case</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span> optr.push(s[i]); i<span style="color:#f92672">++</span>; <span style="color:#66d9ef">break</span>;
			<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">:</span> optr.pop(); i<span style="color:#f92672">++</span>; <span style="color:#66d9ef">break</span>;
			<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">char</span> t <span style="color:#f92672">=</span> optr.top();
				optr.pop();
				<span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> opnd.top();
				opnd.pop();
				<span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> opnd.top();
				opnd.pop();
				opnd.push(Operate(a, b, t));
				<span style="color:#66d9ef">break</span>;
			<span style="color:#66d9ef">case</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span><span style="color:#f92672">:</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ERROR&#34;</span>; exit(<span style="color:#ae81ff">0</span>);
			}
		}

	}
	<span style="color:#66d9ef">return</span> opnd.top();
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[])
{
	string s;
	cin <span style="color:#f92672">&gt;&gt;</span> s;
	cout <span style="color:#f92672">&lt;&lt;</span> EvaluateExpression(s) <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><blockquote>
<p>参考《数据结构（C语言版）》&ndash;严蔚敏</p>
</blockquote>
]]></content>
        </item>
        
        <item>
            <title>数据结构课后作业</title>
            <link>https://fffzlfk.gitlab.io/2019/09/28/chp1%CE%BA%D2%B5/</link>
            <pubDate>Sat, 28 Sep 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/09/28/chp1%CE%BA%D2%B5/</guid>
            <description>请参考《数据结构题集（C语言版）》严慧敏版
 2.11 typedef int Status; typedef int ElemType; typedef struct { ElemType *elem; int length; int listsize; } SqList; Status InitList_Sq(SqList &amp;amp;L) { //构造一个空线性表 	L.elem = (ElemType*)malloc(LIST_INIT_SIZE * sizeof(ElemType)); if (!L.elem) exit(OVERFLOW); L.length = 0; L.listsize = LIST_INIT_SIZE; return OK; } Status ListInsert_Sq(SqList &amp;amp;L, int i, ElemType e) { //在顺序线性表L中的第i个位置之前插入新的元素e 	if (i &amp;lt; 1 || i &amp;gt; L.length + 1) return ERROR; if (L.length &amp;gt; L.listsize) { ElemType *newbase = (ElemType*) realloc(L.</description>
            <content type="html"><![CDATA[<blockquote>
<p>请参考《数据结构题集（C语言版）》严慧敏版</p>
</blockquote>
<h3 id="211">2.11</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> ElemType;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
	ElemType <span style="color:#f92672">*</span>elem;
	<span style="color:#66d9ef">int</span> length;
	<span style="color:#66d9ef">int</span> listsize;
} SqList;

Status <span style="color:#a6e22e">InitList_Sq</span>(SqList <span style="color:#f92672">&amp;</span>L) {
	<span style="color:#75715e">//构造一个空线性表
</span><span style="color:#75715e"></span>	L.elem <span style="color:#f92672">=</span> (ElemType<span style="color:#f92672">*</span>)malloc(LIST_INIT_SIZE <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(ElemType));
	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>L.elem) exit(OVERFLOW);
	L.length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	L.listsize <span style="color:#f92672">=</span> LIST_INIT_SIZE;
	<span style="color:#66d9ef">return</span> OK;
}

Status <span style="color:#a6e22e">ListInsert_Sq</span>(SqList <span style="color:#f92672">&amp;</span>L, <span style="color:#66d9ef">int</span> i, ElemType e) {
	<span style="color:#75715e">//在顺序线性表L中的第i个位置之前插入新的元素e
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> i <span style="color:#f92672">&gt;</span> L.length <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> ERROR;
	<span style="color:#66d9ef">if</span> (L.length <span style="color:#f92672">&gt;</span> L.listsize) {
		ElemType <span style="color:#f92672">*</span>newbase <span style="color:#f92672">=</span> (ElemType<span style="color:#f92672">*</span>) realloc(L.elem, (L.listsize <span style="color:#f92672">+</span> LISTINCREMENT) <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span> (ElemType));
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>newbase) exit(OVERFLOW);
		L.elem <span style="color:#f92672">=</span> newbase;
		L.listsize <span style="color:#f92672">+=</span> LISTINCREMENT;
	}
	ElemType <span style="color:#f92672">*</span>q <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>(L.elem[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]);
	<span style="color:#66d9ef">for</span> (ElemType <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>(L.elem[L.length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]); p <span style="color:#f92672">&gt;=</span> q; <span style="color:#f92672">--</span>p)
		<span style="color:#f92672">*</span>(p <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>p;
	<span style="color:#f92672">*</span>q <span style="color:#f92672">=</span> e;
	L.length<span style="color:#f92672">++</span>;
	<span style="color:#66d9ef">return</span> OK;
}

Status <span style="color:#a6e22e">InsertOrderList</span>(SqList <span style="color:#f92672">&amp;</span>L, ElemType x) {
	<span style="color:#66d9ef">if</span> (L.length <span style="color:#f92672">==</span> L.listsize) {
		<span style="color:#66d9ef">return</span> OVERFLOW;
	}
	<span style="color:#66d9ef">else</span> {
		<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> L.length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
		<span style="color:#66d9ef">for</span> (; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> x <span style="color:#f92672">&lt;</span> L.elem[i]; i<span style="color:#f92672">--</span>);
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> L.length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&gt;=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; j<span style="color:#f92672">--</span>) {
			L.elem[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> L.elem[j];
		}
		L.elem[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> x;
		L.length<span style="color:#f92672">++</span>;
		<span style="color:#66d9ef">return</span> OK;
	}
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ShowSqList</span>(SqList L) {
	putchar(<span style="color:#e6db74">&#39;[&#39;</span>);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> L.length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) {
		printf(<span style="color:#e6db74">&#34;%d,&#34;</span>, <span style="color:#f92672">*</span>(L.elem <span style="color:#f92672">+</span> i));
	}
	printf(<span style="color:#e6db74">&#34;%d]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">*</span>(L.elem <span style="color:#f92672">+</span> L.length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	SqList l;
	InitList_Sq(l);
	ListInsert_Sq(l, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);
	ListInsert_Sq(l, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>);
	ListInsert_Sq(l, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>);
	ShowSqList(l);
	InsertOrderList(l, <span style="color:#ae81ff">3</span>);
	ShowSqList(l);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="214">2.14</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define TRUE 1 
</span><span style="color:#75715e">#define FALSE 0 
</span><span style="color:#75715e">#define OK 1 
</span><span style="color:#75715e">#define ERROR 0 
</span><span style="color:#75715e">#define INFEASIBLE -1 
</span><span style="color:#75715e">#define OVERFLOW -2
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> ElemType;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {
    ElemType data;
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span><span style="color:#f92672">*</span> next;
} <span style="color:#f92672">*</span>LinkList;

Status <span style="color:#a6e22e">CreateLinkList</span>(LinkList <span style="color:#f92672">&amp;</span>L, <span style="color:#66d9ef">int</span> n) {
    LinkList head <span style="color:#f92672">=</span> (LinkList)malloc(<span style="color:#66d9ef">sizeof</span>(LinkList));
    LinkList end;
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>head) exit(OVERFLOW);
    end <span style="color:#f92672">=</span> head;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
        node<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> (node<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(node));
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>data);
        end<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p;
        end <span style="color:#f92672">=</span> p;
    }
    end<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
    L <span style="color:#f92672">=</span> head;
    <span style="color:#66d9ef">return</span> OK;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Length</span>(LinkList L) {
    <span style="color:#66d9ef">int</span> length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> (L<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
        L <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>next;
        length<span style="color:#f92672">++</span>;
    }
    <span style="color:#66d9ef">return</span> length;
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Show</span>(LinkList L) {
    <span style="color:#66d9ef">while</span> (L<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
        L <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>next;
        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, L<span style="color:#f92672">-&gt;</span>data);
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    LinkList L;
    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
    CreateLinkList(L, <span style="color:#ae81ff">5</span>);
    Show(L);
    printf(<span style="color:#e6db74">&#34;%d&#34;</span>, Length(L));
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="219">2.19</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define TRUE 1 
</span><span style="color:#75715e">#define FALSE 0 
</span><span style="color:#75715e">#define OK 1 
</span><span style="color:#75715e">#define ERROR 0 
</span><span style="color:#75715e">#define INFEASIBLE -1 
</span><span style="color:#75715e">#define OVERFLOW -2
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> ElemType;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {
    ElemType data;
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span><span style="color:#f92672">*</span> next;
} <span style="color:#f92672">*</span>LinkList;

Status <span style="color:#a6e22e">CreateLinkList</span>(LinkList <span style="color:#f92672">&amp;</span>L, <span style="color:#66d9ef">int</span> n) {
    LinkList head <span style="color:#f92672">=</span> (LinkList)malloc(<span style="color:#66d9ef">sizeof</span>(LinkList));
    LinkList end;
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>head) exit(OVERFLOW);
    end <span style="color:#f92672">=</span> head;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
        node<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> (node<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(node));
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>data);
        end<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p;
        end <span style="color:#f92672">=</span> p;
    }
    end<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
    L <span style="color:#f92672">=</span> head;
    <span style="color:#66d9ef">return</span> OK;
}

Status <span style="color:#a6e22e">Delete</span>(LinkList <span style="color:#f92672">&amp;</span>L, ElemType mink, ElemType maxk) {
    node <span style="color:#f92672">*</span>p, <span style="color:#f92672">*</span>p1 <span style="color:#f92672">=</span> L;
    <span style="color:#66d9ef">while</span> (p1<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
        <span style="color:#66d9ef">if</span> (p1<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&gt;</span> mink <span style="color:#f92672">&amp;&amp;</span> p1<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;</span> maxk) {
            p <span style="color:#f92672">=</span> p1<span style="color:#f92672">-&gt;</span>next;
            p1<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p1<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
            free(p);
        }
        <span style="color:#66d9ef">else</span> p1 <span style="color:#f92672">=</span> p1<span style="color:#f92672">-&gt;</span>next;
    }
    <span style="color:#66d9ef">return</span> OK;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Show</span>(LinkList L) {
    <span style="color:#66d9ef">while</span> (L<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
        L <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>next;
        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, L<span style="color:#f92672">-&gt;</span>data);
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[])
{
    LinkList L;
    <span style="color:#66d9ef">int</span> n;
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
    CreateLinkList(L, n);
    Show(L);
    Delete(L, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>);
    Show(L);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="倒置链表">倒置链表</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define TRUE 1 
</span><span style="color:#75715e">#define FALSE 0 
</span><span style="color:#75715e">#define OK 1 
</span><span style="color:#75715e">#define ERROR 0 
</span><span style="color:#75715e">#define INFEASIBLE -1 
</span><span style="color:#75715e">#define OVERFLOW -2
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> ElemType;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {
    ElemType data;
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span><span style="color:#f92672">*</span> next;
} <span style="color:#f92672">*</span>LinkList;

Status <span style="color:#a6e22e">CreateLinkList</span>(LinkList <span style="color:#f92672">&amp;</span>L, <span style="color:#66d9ef">int</span> n) {
    LinkList head <span style="color:#f92672">=</span> (LinkList)malloc(<span style="color:#66d9ef">sizeof</span>(LinkList));
    LinkList end;
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>head) exit(OVERFLOW);
    end <span style="color:#f92672">=</span> head;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
        node<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> (node<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(node));
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>data);
        end<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p;
        end <span style="color:#f92672">=</span> p;
    }
    end<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
    L <span style="color:#f92672">=</span> head;
    <span style="color:#66d9ef">return</span> OK;
}

Status <span style="color:#a6e22e">ReverseLinkList</span>(LinkList <span style="color:#f92672">&amp;</span>L) { 
    <span style="color:#66d9ef">if</span> (L <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> L<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">==</span> NULL)
        <span style="color:#66d9ef">return</span> OK;
    node <span style="color:#f92672">*</span>prev <span style="color:#f92672">=</span> L;
    node <span style="color:#f92672">*</span>cur <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>next;
    node <span style="color:#f92672">*</span>tmp <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
    <span style="color:#66d9ef">while</span> (tmp) {
        tmp <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>next;
        cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> prev;
        prev <span style="color:#f92672">=</span> cur;
        cur <span style="color:#f92672">=</span> tmp;
    }
    L<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
    L<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> prev;
    <span style="color:#66d9ef">return</span> OK;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Show</span>(LinkList L) {
    <span style="color:#66d9ef">while</span> (L<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
        L <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>next;
        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, L<span style="color:#f92672">-&gt;</span>data);
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[])
{
    LinkList L;
    <span style="color:#66d9ef">int</span> n;
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
    CreateLinkList(L, n);
    Show(L);
    ReverseLinkList(L);
    Show(L);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>用C语言实现静态链表</title>
            <link>https://fffzlfk.gitlab.io/2019/09/20/c%CA%B5%CC%AC/</link>
            <pubDate>Fri, 20 Sep 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/09/20/c%CA%B5%CC%AC/</guid>
            <description>静态链表 用数组替代指针，数组中的每一项有两个域：data &amp;amp; cur；data用来存放数据，而cur则为游标，相当于链表中的next。 代码实现 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define MAXSIZE 1000 #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2  typedef int Status; typedef int ElemType; typedef struct { ElemType data; int cur; } Component, StaticLinkList[MAXSIZE]; /*将下标为k的空闲结点回收到备用链表*/ void Free_SSL(StaticLinkList space, int k) { space[k].cur = space[0].cur; space[0].cur = k; } int ListLength(StaticLinkList L) { int j = 0; int i = L[MAXSIZE-1].</description>
            <content type="html"><![CDATA[<h3 id="静态链表">静态链表</h3>
<p>用数组替代指针，数组中的每一项有两个域：data &amp; cur；data用来存放数据，而cur则为游标，相当于链表中的next。
<!-- raw HTML omitted --></p>
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define MAXSIZE 1000
</span><span style="color:#75715e">#define TRUE       1
</span><span style="color:#75715e">#define FALSE      0
</span><span style="color:#75715e">#define OK         1
</span><span style="color:#75715e">#define ERROR      0
</span><span style="color:#75715e">#define INFEASIBLE -1
</span><span style="color:#75715e">#define OVERFLOW   -2
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> ElemType;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
	ElemType data;
	<span style="color:#66d9ef">int</span> cur;
} Component, StaticLinkList[MAXSIZE];

<span style="color:#75715e">/*将下标为k的空闲结点回收到备用链表*/</span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Free_SSL</span>(StaticLinkList space, <span style="color:#66d9ef">int</span> k) {
	space[k].cur <span style="color:#f92672">=</span> space[<span style="color:#ae81ff">0</span>].cur;
	space[<span style="color:#ae81ff">0</span>].cur <span style="color:#f92672">=</span> k;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ListLength</span>(StaticLinkList L) {
	<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> L[MAXSIZE<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>].cur;
	<span style="color:#66d9ef">while</span> (i) {
		i <span style="color:#f92672">=</span> L[i].cur;
		j<span style="color:#f92672">++</span>;
	}
	<span style="color:#66d9ef">return</span> j;
}

Status <span style="color:#a6e22e">InitList</span>(StaticLinkList space) {
	<span style="color:#66d9ef">int</span> i;
	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> MAXSIZE <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>)
		space[i].cur <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
	space[MAXSIZE<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>].cur <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">return</span> OK;
}

<span style="color:#75715e">/*若备用空间链表非空，则返回分配的结点的下标，否则返回0*/</span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Malloc_SLL</span>(StaticLinkList space) {
	<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> space[<span style="color:#ae81ff">0</span>].cur;
	<span style="color:#66d9ef">if</span> (space[<span style="color:#ae81ff">0</span>].cur)
		space[<span style="color:#ae81ff">0</span>].cur <span style="color:#f92672">=</span> space[i].cur;
	<span style="color:#66d9ef">return</span> i;
}

<span style="color:#75715e">/*在L中第i个元素之前插入新的数据元素e*/</span>
Status <span style="color:#a6e22e">ListInsert</span>(StaticLinkList L, <span style="color:#66d9ef">int</span> i, ElemType e) {
	<span style="color:#66d9ef">int</span> j, k, l;
	k <span style="color:#f92672">=</span> MAXSIZE <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> i <span style="color:#f92672">&gt;</span> ListLength(L) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">return</span> ERROR;
	j <span style="color:#f92672">=</span> Malloc_SLL(L);
	<span style="color:#66d9ef">if</span> (j) {
		L[j].data <span style="color:#f92672">=</span> e;
		<span style="color:#66d9ef">for</span> (l <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; l <span style="color:#f92672">&lt;=</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; l<span style="color:#f92672">++</span>) {
			k <span style="color:#f92672">=</span> L[k].cur;
		}
		L[j].cur <span style="color:#f92672">=</span> L[k].cur;
		L[k].cur <span style="color:#f92672">=</span> j;
		<span style="color:#66d9ef">return</span> OK;
	}
	<span style="color:#66d9ef">return</span> ERROR;
}

<span style="color:#75715e">/*删除在L中第i个元素e*/</span>
Status <span style="color:#a6e22e">ListDelete</span>(StaticLinkList L, <span style="color:#66d9ef">int</span> i) {
	<span style="color:#66d9ef">int</span> j, k;
	<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> i <span style="color:#f92672">&gt;</span> ListLength(L))
		<span style="color:#66d9ef">return</span> ERROR;
	k <span style="color:#f92672">=</span> MAXSIZE <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">for</span> ( j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; j<span style="color:#f92672">++</span>)
		k <span style="color:#f92672">=</span> L[k].cur;
	j <span style="color:#f92672">=</span> L[k].cur;
	L[k].cur <span style="color:#f92672">=</span> L[j].cur;
	Free_SSL(L, j);
	<span style="color:#66d9ef">return</span> OK;
}


<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[])
{
	StaticLinkList l;
	InitList(l);
	ListInsert(l, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">10</span>);
	printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, l[<span style="color:#ae81ff">1</span>].data);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="优缺点">优缺点</h3>
<ul>
<li>优点：增删结点时不需要移动；</li>
<li>缺点：不能动态存取。</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>简单双向循环链表的表示和实现(C语言)</title>
            <link>https://fffzlfk.gitlab.io/2019/09/15/%D1%AD%C4%B1%CA%BE%CA%B5c/</link>
            <pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/09/15/%D1%AD%C4%B1%CA%BE%CA%B5c/</guid>
            <description>双向循环链表 双向链表的每一个节点有两个指针，一个是next（下一个），一个是prep（上一个），其他和单向类似；至于循环双向链表，它的结构为： 代码实现 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2  #define LIST_INIT_SIZE 100 #define LISTINCREMENT 10  typedef int Status; typedef int ElemType; typedef struct Node { ElemType value; Node* prep; Node* next; } DbLink; DbLink* CreateDbLink(int n) { DbLink *head, *node, *end; head = (DbLink*)malloc(sizeof(DbLink)); if (!head) exit(OVERFLOW); end = head; for (int i = 0; i &amp;lt; n; i++) { node = (DbLink*)malloc(sizeof(DbLink)); if (!</description>
            <content type="html"><![CDATA[<h3 id="双向循环链表">双向循环链表</h3>
<p>双向链表的每一个节点有两个指针，一个是next（下一个），一个是prep（上一个），其他和单向类似；至于循环双向链表，它的结构为：
<!-- raw HTML omitted --></p>
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define TRUE       1
</span><span style="color:#75715e">#define FALSE      0
</span><span style="color:#75715e">#define OK         1
</span><span style="color:#75715e">#define ERROR      0
</span><span style="color:#75715e">#define INFEASIBLE -1
</span><span style="color:#75715e">#define OVERFLOW   -2
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define LIST_INIT_SIZE 100
</span><span style="color:#75715e">#define LISTINCREMENT  10
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> ElemType;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Node
{
	ElemType value;
	Node<span style="color:#f92672">*</span> prep;
	Node<span style="color:#f92672">*</span> next;
} DbLink;

DbLink<span style="color:#f92672">*</span> <span style="color:#a6e22e">CreateDbLink</span>(<span style="color:#66d9ef">int</span> n) {
	DbLink <span style="color:#f92672">*</span>head, <span style="color:#f92672">*</span>node, <span style="color:#f92672">*</span>end;
	head <span style="color:#f92672">=</span> (DbLink<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(DbLink));
	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>head) exit(OVERFLOW);
	end <span style="color:#f92672">=</span> head;
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
		node <span style="color:#f92672">=</span> (DbLink<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(DbLink));
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>node) exit(OVERFLOW);
		scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>node<span style="color:#f92672">-&gt;</span>value);
		node<span style="color:#f92672">-&gt;</span>prep <span style="color:#f92672">=</span> end;
		end<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> node;
		end <span style="color:#f92672">=</span> node;
	}
	end<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head;
	<span style="color:#66d9ef">return</span> head;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">GetLength</span>(DbLink <span style="color:#f92672">*</span>h) {
	DbLink<span style="color:#f92672">*</span> tmp <span style="color:#f92672">=</span> h;
	<span style="color:#66d9ef">int</span> length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">while</span> (h<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> tmp) {
		h <span style="color:#f92672">=</span> h<span style="color:#f92672">-&gt;</span>next;
		length<span style="color:#f92672">++</span>;
	}
	<span style="color:#66d9ef">return</span> length;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ShowDblink</span>(DbLink <span style="color:#f92672">*</span>h) {
	printf(<span style="color:#e6db74">&#34;[&#34;</span>);
	<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> GetLength(h);
	<span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> len) {
		i<span style="color:#f92672">++</span>;
		h <span style="color:#f92672">=</span> h<span style="color:#f92672">-&gt;</span>next;
		printf(i <span style="color:#f92672">==</span> len <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;%d]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;%d &#34;</span>, h<span style="color:#f92672">-&gt;</span>value);
	}
}


Status <span style="color:#a6e22e">InsertElem</span>(DbLink <span style="color:#f92672">*</span>h, <span style="color:#66d9ef">int</span> pos, ElemType v) {
	<span style="color:#66d9ef">if</span> (pos <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> pos <span style="color:#f92672">&lt;=</span> GetLength(h)) {
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> pos; i<span style="color:#f92672">++</span>)
			h <span style="color:#f92672">=</span> h<span style="color:#f92672">-&gt;</span>next;
		DbLink<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> (DbLink<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(DbLink));
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>node) exit(OVERFLOW);
		DbLink<span style="color:#f92672">*</span> tmp <span style="color:#f92672">=</span> NULL;
		node<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">=</span> v;
		tmp <span style="color:#f92672">=</span> h<span style="color:#f92672">-&gt;</span>next;
		node<span style="color:#f92672">-&gt;</span>prep <span style="color:#f92672">=</span> h;
		h<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> node;
		node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> tmp;
		<span style="color:#66d9ef">return</span> OK;
	}
	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> ERROR;

}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	DbLink<span style="color:#f92672">*</span> h <span style="color:#f92672">=</span> CreateDbLink(<span style="color:#ae81ff">5</span>);
	ShowDblink(h);
	InsertElem(h, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">10</span>);
	ShowDblink(h);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>归并两个非递减排列的线性表(C语言)</title>
            <link>https://fffzlfk.gitlab.io/2019/09/12/%E9%B2%A2%C7%B5%DD%BC%D0%B5%D5%A1c/</link>
            <pubDate>Thu, 12 Sep 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/09/12/%E9%B2%A2%C7%B5%DD%BC%D0%B5%D5%A1c/</guid>
            <description>问题 已知线性表La, Lb按非递减有序排列，现需要将La, Lb归并为一个新的非递减有序排列线性表Lc。例如
 La = (3, 5, 8, 11) Lb = (2, 6, 8, 20) 则Lc = (2, 3, 5, 6, 8, 8,11, 20)
 方法 设两个指针pa, pb分别指向La，Lb的首元素，当前应插入Lc的元素为复杂度 显然该算法为线性复杂度，即O(n)；原因是La, Lb为非递减有序排列，故lb中的每个元素不必遍历la中每个元素；而且Lc插入操作实则是通过复制完成的。
代码实现 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2  #define LIST_INIT_SIZE 100 #define LISTINCREMENT 10  typedef int Status; typedef int ElemType; typedef struct { ElemType *elem; int length; int listsize; } SqList; Status InitList_Sq(SqList &amp;amp;L) { //构造一个空线性表 	L.</description>
            <content type="html"><![CDATA[<h3 id="问题">问题</h3>
<p>已知线性表La, Lb按非递减有序排列，现需要将La, Lb归并为一个新的非递减有序排列线性表Lc。例如</p>
<blockquote>
<p>La = (3, 5, 8, 11)                           <br>
Lb = (2, 6, 8, 20)       <br>
则Lc = (2, 3, 5, 6, 8, 8,11, 20)</p>
</blockquote>
<h3 id="方法">方法</h3>
<p>设两个指针pa, pb分别指向La，Lb的首元素，当前应插入Lc的元素为<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="复杂度">复杂度</h3>
<p>显然该算法为线性复杂度，即O(n)；原因是La, Lb为非递减有序排列，故lb中的每个元素不必遍历la中每个元素；而且Lc插入操作实则是通过复制完成的。</p>
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define TRUE       1
</span><span style="color:#75715e">#define FALSE      0
</span><span style="color:#75715e">#define OK         1
</span><span style="color:#75715e">#define ERROR      0
</span><span style="color:#75715e">#define INFEASIBLE -1
</span><span style="color:#75715e">#define OVERFLOW   -2
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define LIST_INIT_SIZE 100
</span><span style="color:#75715e">#define LISTINCREMENT  10
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> ElemType;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
	ElemType <span style="color:#f92672">*</span>elem;
	<span style="color:#66d9ef">int</span> length;
	<span style="color:#66d9ef">int</span> listsize;
} SqList;

Status <span style="color:#a6e22e">InitList_Sq</span>(SqList <span style="color:#f92672">&amp;</span>L) {
	<span style="color:#75715e">//构造一个空线性表
</span><span style="color:#75715e"></span>	L.elem <span style="color:#f92672">=</span> (ElemType<span style="color:#f92672">*</span>)malloc(LIST_INIT_SIZE <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(ElemType));
	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>L.elem) exit(OVERFLOW);
	L.length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	L.listsize <span style="color:#f92672">=</span> LIST_INIT_SIZE;
	<span style="color:#66d9ef">return</span> OK;
}

Status <span style="color:#a6e22e">ListInsert_Sq</span>(SqList <span style="color:#f92672">&amp;</span>L, <span style="color:#66d9ef">int</span> i, ElemType e) {
	<span style="color:#75715e">//在顺序线性表L中的第i个位置之前插入新的元素e
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> i <span style="color:#f92672">&gt;</span> L.length <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> ERROR;
	<span style="color:#66d9ef">if</span> (L.length <span style="color:#f92672">&gt;</span> L.listsize) {
		ElemType <span style="color:#f92672">*</span>newbase <span style="color:#f92672">=</span> (ElemType<span style="color:#f92672">*</span>) realloc(L.elem, (L.listsize <span style="color:#f92672">+</span> LISTINCREMENT) <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span> (ElemType));
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>newbase) exit(OVERFLOW);
		L.elem <span style="color:#f92672">=</span> newbase;
		L.listsize <span style="color:#f92672">+=</span> LISTINCREMENT;
	}
	ElemType <span style="color:#f92672">*</span>q <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>(L.elem[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]);
	<span style="color:#66d9ef">for</span> (ElemType <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>(L.elem[L.length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]); p <span style="color:#f92672">&gt;=</span> q; <span style="color:#f92672">--</span>p)
		<span style="color:#f92672">*</span>(p <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>p;
	<span style="color:#f92672">*</span>q <span style="color:#f92672">=</span> e;
	L.length<span style="color:#f92672">++</span>;
	<span style="color:#66d9ef">return</span> OK;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MergeList_Sq</span>(SqList La, SqList Lb, SqList <span style="color:#f92672">&amp;</span>Lc) {
	<span style="color:#75715e">//La, Lb非递减排列，归并后得到非递减排列的Lc
</span><span style="color:#75715e"></span>	ElemType<span style="color:#f92672">*</span> pa <span style="color:#f92672">=</span> La.elem;
	ElemType<span style="color:#f92672">*</span> pb <span style="color:#f92672">=</span> Lb.elem;
	Lc.listsize <span style="color:#f92672">=</span> Lc.length <span style="color:#f92672">=</span> La.length <span style="color:#f92672">+</span> Lb.length;
	ElemType<span style="color:#f92672">*</span> pc <span style="color:#f92672">=</span> Lc.elem <span style="color:#f92672">=</span> (ElemType<span style="color:#f92672">*</span>)malloc(Lc.listsize <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(ElemType));
	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>Lc.elem) exit(OVERFLOW);
	ElemType<span style="color:#f92672">*</span> pa_last <span style="color:#f92672">=</span> La.elem <span style="color:#f92672">+</span> La.length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
	ElemType<span style="color:#f92672">*</span> pb_last <span style="color:#f92672">=</span> Lb.elem <span style="color:#f92672">+</span> Lb.length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">while</span> (pa <span style="color:#f92672">&lt;=</span> pa_last <span style="color:#f92672">&amp;&amp;</span> pb <span style="color:#f92672">&lt;=</span> pb_last) {
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>pa <span style="color:#f92672">&lt;=</span> <span style="color:#f92672">*</span>pb)
			<span style="color:#f92672">*</span>pc<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>pa<span style="color:#f92672">++</span>;
		<span style="color:#66d9ef">else</span>
			<span style="color:#f92672">*</span>pc<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>pb<span style="color:#f92672">++</span>;
	}
	<span style="color:#66d9ef">while</span> (pa <span style="color:#f92672">&lt;=</span> pa_last) <span style="color:#f92672">*</span>pc<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>pa<span style="color:#f92672">++</span>;
	<span style="color:#66d9ef">while</span> (pb <span style="color:#f92672">&lt;=</span> pb_last) <span style="color:#f92672">*</span>pc<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>pb<span style="color:#f92672">++</span>;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ShowList_Sq</span>(SqList L) {
	printf(<span style="color:#e6db74">&#34;[&#34;</span>);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> L.length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) {
		printf(<span style="color:#e6db74">&#34;%d &#34;</span>, <span style="color:#f92672">*</span>(L.elem <span style="color:#f92672">+</span> i));
	}
	printf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">*</span>(L.elem <span style="color:#f92672">+</span> L.length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
	printf(<span style="color:#e6db74">&#34;]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	SqList la, lb, lc;
	InitList_Sq(la);
	InitList_Sq(lb);
	InitList_Sq(lc);
	ListInsert_Sq(la, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>);
	ListInsert_Sq(la, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>);
	printf(<span style="color:#e6db74">&#34;la:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
	ShowList_Sq(la);
	ListInsert_Sq(lb, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);
	ListInsert_Sq(lb, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>);
	ListInsert_Sq(lb, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>);
	printf(<span style="color:#e6db74">&#34;lb:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
	ShowList_Sq(lb);
	MergeList_Sq(la, lb, lc);
	printf(<span style="color:#e6db74">&#34;lc:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
	ShowList_Sq(lc);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>求两个简单链表的并集</title>
            <link>https://fffzlfk.gitlab.io/2019/09/07/%C4%BE/</link>
            <pubDate>Sat, 07 Sep 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/09/07/%C4%BE/</guid>
            <description>问题： 给出两个单向链表，求出它们的并集 例如：
 a = [1, 2, 3], b = [2, 3, 4]; 实现InterSect(a, b), 使得a = [1, 2, 3, 4]
 代码实现 #include &amp;lt;stdio.h&amp;gt; typedef struct node { int value; node *next; } LinkList; LinkList* InitList(int n) { LinkList *head, *node, *end; head = new LinkList; end = head; while (n--) { node = new LinkList; scanf(&amp;#34;%d&amp;#34;, &amp;amp;node-&amp;gt;value); end-&amp;gt;next = node; end = node; } end-&amp;gt;next = NULL; return head; } void ShowList(LinkList *h) { while (h-&amp;gt;next !</description>
            <content type="html"><![CDATA[<h3 id="问题">问题：</h3>
<p>给出两个单向链表，求出它们的并集
例如：</p>
<blockquote>
<p>a = [1, 2, 3], b = [2, 3, 4]; 实现InterSect(a, b), 使得a = [1, 2, 3, 4]</p>
</blockquote>
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> node {
	<span style="color:#66d9ef">int</span> value;
	node <span style="color:#f92672">*</span>next;
} LinkList;

LinkList<span style="color:#f92672">*</span> <span style="color:#a6e22e">InitList</span>(<span style="color:#66d9ef">int</span> n) {
	LinkList <span style="color:#f92672">*</span>head, <span style="color:#f92672">*</span>node, <span style="color:#f92672">*</span>end;
	head <span style="color:#f92672">=</span> new LinkList;
	end <span style="color:#f92672">=</span> head;
	<span style="color:#66d9ef">while</span> (n<span style="color:#f92672">--</span>) {
		node <span style="color:#f92672">=</span> new LinkList;
		scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>node<span style="color:#f92672">-&gt;</span>value);
		end<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> node;
		end <span style="color:#f92672">=</span> node;
	}
	end<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
	<span style="color:#66d9ef">return</span> head;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ShowList</span>(LinkList <span style="color:#f92672">*</span>h) {
	<span style="color:#66d9ef">while</span> (h<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
		h <span style="color:#f92672">=</span> h<span style="color:#f92672">-&gt;</span>next;
		printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, h<span style="color:#f92672">-&gt;</span>value);
	}
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Insert</span>(LinkList <span style="color:#f92672">*</span>h, <span style="color:#66d9ef">int</span> v) {
	LinkList <span style="color:#f92672">*</span>node <span style="color:#f92672">=</span> new LinkList;
	<span style="color:#66d9ef">while</span> (h<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL)
		h <span style="color:#f92672">=</span> h<span style="color:#f92672">-&gt;</span>next;
	node<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">=</span> v;
	h<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> node;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InterSect</span>(LinkList <span style="color:#f92672">*</span>a, LinkList <span style="color:#f92672">*</span>b) {
	<span style="color:#66d9ef">while</span> (b<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
		LinkList <span style="color:#f92672">*</span>A <span style="color:#f92672">=</span> a;
		b <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>next;
		<span style="color:#66d9ef">int</span> flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
		<span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
		<span style="color:#66d9ef">while</span> (A<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
			A <span style="color:#f92672">=</span> A<span style="color:#f92672">-&gt;</span>next;
			<span style="color:#66d9ef">if</span> (A<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">==</span> b<span style="color:#f92672">-&gt;</span>value) {
				flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
				<span style="color:#66d9ef">break</span>;
			}
		}
		tmp <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>value;
		<span style="color:#66d9ef">if</span> (flag)
			Insert(a, tmp);
	}
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">int</span> n;
	scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
	LinkList <span style="color:#f92672">*</span>a <span style="color:#f92672">=</span> InitList(n);
	LinkList <span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> InitList(n);
	ShowList(a);
	ShowList(b);
	InterSect(a, b);
	ShowList(a);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>线性表的顺序表示和实现(C语言)</title>
            <link>https://fffzlfk.gitlab.io/2019/09/08/%D5%A1%CA%BE%CA%B5c/</link>
            <pubDate>Sat, 07 Sep 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/09/08/%D5%A1%CA%BE%CA%B5c/</guid>
            <description>线性表的顺序表示:  线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素。 数据元素的存储位置之间满足如下关系:  一般来说:   #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2
#define LIST_INIT_SIZE 100 #define LISTINCREMENT 10
typedef int Status; typedef int ElemType; typedef struct { ElemType *elem; int length; int listsize; } SqList;
Status InitList_Sq(SqList &amp;amp;L) { //构造一个空线性表 L.elem = (ElemType*)malloc(LIST_INIT_SIZE * sizeof(ElemType)); if (!L.elem) exit(OVERFLOW); L.length = 0; L.listsize = LIST_INIT_SIZE; return OK; }</description>
            <content type="html"><![CDATA[<h3 id="线性表的顺序表示">线性表的顺序表示:</h3>
<ul>
<li>线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素。</li>
<li>数据元素的存储位置之间满足如下关系:
<img src="http://latex.codecogs.com/gif.latex?%5C%7BLOC(a_%7Bi+1%7D)=LOC(a_i)%7D+l" alt=""></li>
<li>一般来说:
<img src="http://latex.codecogs.com/gif.latex?%5C%7BLOC(a_i)=LOC(a_1)+(i-1)Xl%7D" alt="">
<img src="http://img.wandouip.com/crawler/article/201978/ef79eb5bdf382d3d2e955ab5fc53680c" alt=""></li>
</ul>
<!-- raw HTML omitted -->
<p>#define TRUE       1
#define FALSE      0
#define OK         1
#define ERROR      0
#define INFEASIBLE -1
#define OVERFLOW   -2</p>
<p>#define LIST_INIT_SIZE 100
#define LISTINCREMENT  10</p>
<p>typedef int Status;
typedef int ElemType;
typedef struct {
ElemType *elem;
int length;
int listsize;
} SqList;</p>
<p>Status InitList_Sq(SqList &amp;L) {
//构造一个空线性表
L.elem = (ElemType*)malloc(LIST_INIT_SIZE * sizeof(ElemType));
if (!L.elem) exit(OVERFLOW);
L.length = 0;
L.listsize = LIST_INIT_SIZE;
return OK;
}</p>
<p>Status ListInsert_Sq(SqList &amp;L, int i, ElemType e) {
//在顺序线性表L中的第i个位置之前插入新的元素e
if (i &lt; 1 || i &gt; L.length + 1) return ERROR;
if (L.length &gt; L.listsize) {
ElemType <em>newbase = (ElemType</em>) realloc(L.elem, (L.listsize + LISTINCREMENT) * sizeof (ElemType));
if (!newbase) exit(OVERFLOW);
L.elem = newbase;
L.listsize += LISTINCREMENT;
}
ElemType *q = &amp;(L.elem[i - 1]);
for (ElemType *p = &amp;(L.elem[L.length - 1]); p &gt;= q; &ndash;p)
*(p + 1) = *p;
*q = e;
L.length++;
return OK;
}</p>
<p>Status ListDelete_Sq(SqList &amp;L, int i, ElemType &amp;e) {
//删除线性表L中第i个元素并将该元素储存在e中
if ((i &lt; 1) || (i &gt; L.length)) return ERROR;
ElemType *p = &amp;(L.elem[i - 1]);
e = *p;
ElemType *q = L.elem + L.length - 1;
for (++p; p &lt;= q; ++ p)
*(p - 1) = *p;
L.length&ndash;;
return OK;
}</p>
<p>void ShowSqList(SqList L) {
for (int i = 0; i &lt; L.length; i++) {
printf(&quot;%d\n&quot;, *(L.elem + i));
}
}</p>
<p>int main() {
SqList l;
InitList_Sq(l);
ListInsert_Sq(l, 1, 2);
ListInsert_Sq(l, 2, 3);
ListInsert_Sq(l, 3, 1);
ShowSqList(l);
ElemType tmp;
ListDelete_Sq(l, 2, tmp);
ShowSqList(l);
printf(&quot;%d\n&quot;, tmp);
return 0;
}</p>
<pre><code>### 注释:
参考《数据结构（C语言版）--严蔚敏</code></pre>]]></content>
        </item>
        
        <item>
            <title>一个用C实现的简单的单向链表</title>
            <link>https://fffzlfk.gitlab.io/2019/09/03/%D2%BBc%CA%B5%D6%B5%C4%BC%C4%B5-2019/</link>
            <pubDate>Wed, 04 Sep 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/09/03/%D2%BBc%CA%B5%D6%B5%C4%BC%C4%B5-2019/</guid>
            <description>typedef struct value { int v; struct value *next; } LinkList;
LinkList *create(int n) { LinkList *head, node, end; head = (LinkList)malloc(sizeof(LinkList)); end = head; for (int i = 0; i &amp;lt; n; i++) { node = (LinkList)malloc(sizeof(LinkList)); scanf(&amp;quot;%d&amp;quot;, &amp;amp;node-&amp;gt;v); end-&amp;gt;next = node; end = node; } end-&amp;gt;next = NULL; return head; }
void change(LinkList *list, int n) { LinkList *t = list; int i = 0; while(i &amp;lt; n &amp;amp;&amp;amp; t !</description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<p>typedef struct value {
int v;
struct value *next;
} LinkList;</p>
<p>LinkList *create(int n) {
LinkList *head, <em>node, <em>end;
head = (LinkList</em>)malloc(sizeof(LinkList));
end = head;
for (int i = 0; i &lt; n; i++) {
node = (LinkList</em>)malloc(sizeof(LinkList));
scanf(&quot;%d&quot;, &amp;node-&gt;v);
end-&gt;next = node;
end = node;
}
end-&gt;next = NULL;
return head;
}</p>
<p>void change(LinkList *list, int n) {
LinkList *t = list;
int i = 0;
while(i &lt; n &amp;&amp; t != NULL) {
t = t-&gt;next;
i++;
}
if (t != NULL) {
puts(&ldquo;输入要修改的值&rdquo;);
scanf(&quot;%d&quot;, &amp;t-&gt;v);
} else {
puts(&ldquo;结点不存在&rdquo;);
}
}</p>
<p>void delet(LinkList *list, int n) {
LinkList *t = list, *in;
int i = 0;
while(i &lt; n &amp;&amp; t != NULL) {
in = t;
t = t-&gt;next;
i++;
}
if (t != NULL) {
in-&gt;next = t -&gt;next;
free(t);
} else {
puts(&ldquo;结点不存在&rdquo;);
}
}</p>
<p>void insert(LinkList *list, int n, int value) {
LinkList *t = list, <em>in;
int i = 0;
while (i &lt; n &amp;&amp; t != NULL) {
t = t-&gt;next;
i++;
} if (t != NULL) {
in = (LinkList</em>)malloc(sizeof(LinkList));
in-&gt;v = value;
in-&gt;next = t-&gt;next;
t-&gt;next = in;
} else {
puts(&ldquo;结点不存在&rdquo;);
}
}</p>
<p>void show(LinkList *h) {
while(h-&gt;next != NULL) {
h = h-&gt;next;
printf(&quot;%d\n&quot;, h-&gt;v);
}
}</p>
<p>int main() {
int n;
scanf(&quot;%d&quot;, &amp;n);
LinkList *h = create(n);
show(h);
insert(h, 3, 9);
show(h);
return 0;
}</p>
<pre><code></code></pre>]]></content>
        </item>
        
        <item>
            <title>一个简单的位运算及其复杂度分析(Sample)</title>
            <link>https://fffzlfk.gitlab.io/2019/09/03/%D2%BB%CE%BB%E3%BC%B0%E4%B8%B4%D3%B7%C8%B7sample-2019/</link>
            <pubDate>Tue, 03 Sep 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/09/03/%D2%BB%CE%BB%E3%BC%B0%E4%B8%B4%D3%B7%C8%B7sample-2019/</guid>
            <description>代码实现： #include &amp;lt;iostream&amp;gt; using namespace std; int countOnes(unsigned int n) { int ones = 0; while(n) { ones += n &amp;amp; 1; n &amp;gt;&amp;gt;= 1; } return ones; } int main() { int n; while (cin &amp;gt;&amp;gt; n) cout &amp;lt;&amp;lt; countOnes(n) &amp;lt;&amp;lt; endl; return 0; } 时间复杂度： 总的循环次数为n展开为二进制后的位数，即无论是该循环体之前、之内还是之后,均只涉及常数次(逻辑判断、位与运算、加法、右移 等)基本操作。因此,countOnes()算法的执行时间主要由循环的次数决定,亦即:  由大O记号定义,在用函数log r n界定渐进复杂度时,常底数r的具体取值无所谓，故通常不予专门标出而笼统地记作logn，比如,尽管此处底数为常数2,却可直接记作O(logn)。此类算法称作具有“对数时间复杂度”(logarithmic-time algorithm)。</description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<h4 id="代码实现">代码实现：</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">countOnes</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> n) {
	<span style="color:#66d9ef">int</span> ones <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">while</span>(n) {
		ones <span style="color:#f92672">+=</span> n <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>;
		n <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
	}
	<span style="color:#66d9ef">return</span> ones;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">int</span> n;
	<span style="color:#66d9ef">while</span> (cin <span style="color:#f92672">&gt;&gt;</span> n)
	cout <span style="color:#f92672">&lt;&lt;</span> countOnes(n) <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="时间复杂度">时间复杂度：</h4>
<p>总的循环次数为n展开为二进制后的位数，即<a href="https://camo.githubusercontent.com/495a5da7a52dcf738f11295a5fd2026113af08ac/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f31202b206c6f675f326e"><img src="https://camo.githubusercontent.com/495a5da7a52dcf738f11295a5fd2026113af08ac/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f31202b206c6f675f326e" alt="img"></a>无论是该循环体之前、之内还是之后,均只涉及常数次(逻辑判断、位与运算、加法、右移 等)基本操作。因此,countOnes()算法的执行时间主要由循环的次数决定,亦即: <a href="https://camo.githubusercontent.com/0a83de70ba46caa59193b5a41f357c1f0d73a993/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f4f28312b5b6c6f675f326e5d293d4f285b6c6f675f326e5d293d4f286c6f675f326e29"><img src="https://camo.githubusercontent.com/0a83de70ba46caa59193b5a41f357c1f0d73a993/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f4f28312b5b6c6f675f326e5d293d4f285b6c6f675f326e5d293d4f286c6f675f326e29" alt="img"></a> 由大O记号定义,在用函数log r n界定渐进复杂度时,常底数r的具体取值无所谓，故通常不予专门标出而笼统地记作logn，比如,尽管此处底数为常数2,却可直接记作O(logn)。此类算法称作具有“对数时间复杂度”(logarithmic-time algorithm)。</p>
]]></content>
        </item>
        
        <item>
            <title>求k阶斐波那契第m项的值</title>
            <link>https://fffzlfk.gitlab.io/2019/09/03/k%EC%B3%B2m%D6%B5-2019/</link>
            <pubDate>Tue, 03 Sep 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/09/03/k%EC%B3%B2m%D6%B5-2019/</guid>
            <description>代码实现 #include &amp;lt;stdio.h&amp;gt;const int MAXN = 10000; long long fib(int k, int m) { long long a[MAXN]; for (int i = 0; i &amp;lt; k - 1; i++) { a[i] = 0; } a[k - 1] = 1; for (int i = k; i &amp;lt;= m; i++) { long long s = 0; for (int j = i - 1; j &amp;gt; i - 1 - k; j--) { s += a[j]; } a[i] = s; } return a[m]; } int main() { int k, m; while (scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;k, &amp;amp;m) == 2) { printf(&amp;#34;%lld\n&amp;#34;, fib(k, m)); } return 0; } 注释 该题目出现在数据结构（C语言版）题集中的1.</description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">10000</span>;
<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">fib</span>(<span style="color:#66d9ef">int</span> k, <span style="color:#66d9ef">int</span> m) {
	<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> a[MAXN];
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) {
		a[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	}
	a[k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> k; i <span style="color:#f92672">&lt;=</span> m; i<span style="color:#f92672">++</span>) {
		<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&gt;</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> k; j<span style="color:#f92672">--</span>) {
			s <span style="color:#f92672">+=</span> a[j];
		}
		a[i] <span style="color:#f92672">=</span> s;
	}
	<span style="color:#66d9ef">return</span> a[m];
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">int</span> k, m;
	<span style="color:#66d9ef">while</span> (scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>k, <span style="color:#f92672">&amp;</span>m) <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) {
		printf(<span style="color:#e6db74">&#34;%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, fib(k, m));
	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="注释">注释</h3>
<p>该题目出现在数据结构（C语言版）题集中的1.17</p>
]]></content>
        </item>
        
        <item>
            <title>打印沙漏 &amp; 个位数统计</title>
            <link>https://fffzlfk.gitlab.io/2019/03/23/%D3%A1%C9%B3/</link>
            <pubDate>Sat, 23 Mar 2019 00:00:00 +0000</pubDate>
            
            <guid>https://fffzlfk.gitlab.io/2019/03/23/%D3%A1%C9%B3/</guid>
            <description>打印沙漏  本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印  *****************  所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。
  给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。
  输入格式: 输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。
输出格式: 首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。
输入样例: 19 *输出样例: *****************2代码 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int main() { int m; char c; scanf(&amp;#34;%d %c&amp;#34;, &amp;amp;m, &amp;amp;c); int n = sqrt((m + 1) / 2.0) - 1; int surp = m - 2 * (n + 1) * (n + 1) + 1; for (int i = n; i &amp;gt;= 0; i--) { for (int j = 0; j &amp;lt; n - i; j++) putchar(&amp;#39; &amp;#39;); for (int j = 0; j &amp;lt; 2 * i + 1; j++) putchar(c); puts(&amp;#34;&amp;#34;); } for (int i = 1; i &amp;lt;= n; i++) { for (int j = 0; j &amp;lt; n - i; j++) putchar(&amp;#39; &amp;#39;); for (int j = 0; j &amp;lt; 2 * i + 1; j++) putchar(c); puts(&amp;#34;&amp;#34;); } printf(&amp;#34;%d&amp;#34;, surp); return 0; } 个位数统计 题目描述 给定一个 k 位整数，请编写程序统计每种不同的个位数字出现的次数。例如：给定 N=100311，则有 2 个 0，3 个 1，和 1 个 3。</description>
            <content type="html"><![CDATA[<h2 id="打印沙漏">打印沙漏</h2>
<ul>
<li>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印</li>
</ul>
<pre><code>*****
 ***
  *
 ***
*****
</code></pre><ul>
<li>
<p>所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。</p>
</li>
<li>
<p>给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。</p>
</li>
</ul>
<h3 id="输入格式">输入格式:</h3>
<p>输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。</p>
<h3 id="输出格式">输出格式:</h3>
<p>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。</p>
<h3 id="输入样例">输入样例:</h3>
<pre><code>19 *
</code></pre><h3 id="输出样例">输出样例:</h3>
<pre><code>*****
 ***
  *
 ***
*****
2
</code></pre><h3 id="代码">代码</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> m;
    <span style="color:#66d9ef">char</span> c;
    scanf(<span style="color:#e6db74">&#34;%d %c&#34;</span>, <span style="color:#f92672">&amp;</span>m, <span style="color:#f92672">&amp;</span>c);
    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> sqrt((m <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2.0</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">int</span> surp <span style="color:#f92672">=</span> m <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> (n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> (n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> i; j<span style="color:#f92672">++</span>)
            putchar(<span style="color:#e6db74">&#39; &#39;</span>);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; j<span style="color:#f92672">++</span>)
            putchar(c);
        puts(<span style="color:#e6db74">&#34;&#34;</span>);
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> i; j<span style="color:#f92672">++</span>)
            putchar(<span style="color:#e6db74">&#39; &#39;</span>);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; j<span style="color:#f92672">++</span>)
            putchar(c);
        puts(<span style="color:#e6db74">&#34;&#34;</span>);
    }
    printf(<span style="color:#e6db74">&#34;%d&#34;</span>, surp);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="个位数统计">个位数统计</h2>
<h3 id="题目描述">题目描述</h3>
<p>给定一个 k 位整数，请编写程序统计每种不同的个位数字出现的次数。例如：给定 N=100311，则有 2 个 0，3 个 1，和 1 个 3。</p>
<h3 id="输入格式-1">输入格式：</h3>
<p>每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 N。</p>
<h3 id="输出格式-1">输出格式：</h3>
<p>对 N 中每一种不同的个位数字，以 D:M 的格式在一行中输出该位数字 D 及其在 N 中出现的次数 M。要求按 D 的升序输出。</p>
<h3 id="输入样例-1">输入样例：</h3>
<pre><code>100311
</code></pre><h3 id="输出样例-1">输出样例：</h3>
<pre><code>0:2
1:3
3:1
</code></pre><h3 id="代码-1">代码</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    string s;
    cin <span style="color:#f92672">&gt;&gt;</span> s;
    <span style="color:#66d9ef">int</span> a[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> s.length(); i<span style="color:#f92672">++</span>)
        a[s[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>]<span style="color:#f92672">++</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">if</span> (a[i])
            printf(<span style="color:#e6db74">&#34;%d:%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, a[i]);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
    </channel>
</rss>
