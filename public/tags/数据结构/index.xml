<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据结构 on fffzlfk&#39;s Blog</title>
    <link>https://fffzlfk.gitlab.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
    <description>Recent content in 数据结构 on fffzlfk&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sun, 31 May 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://fffzlfk.gitlab.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Windows消息队列</title>
      <link>https://fffzlfk.gitlab.io/2020/05/31/windows%CF%A3/</link>
      <pubDate>Sun, 31 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2020/05/31/windows%CF%A3/</guid>
      <description>问题描述 消息队列是Windows系统的基础。对于每个进程，系统维护一个消息队列。如果在进程中有特定事件发生，如点击鼠标、文字改变等，系统将把这个消息加到队列当中。同时，如果队列不是空的，这一进程循环地从队列中按照优先级获取消息。请注意优先级值低意味着优先级高。请编辑程序模拟消息队列，将消息加到队列中以及从队列中获取消息。
题目链接
解决思路 此次可以使用优先队列来解，priority_queue是一种先入优先级高者出的队列。
输入格式: 输入首先给出正整数N（≤10^5​​），随后N行，每行给出一个指令——GET或PUT，分别表示从队列中取出消息或将消息添加到队列中。如果指令是PUT，后面就有一个消息名称、以及一个正整数表示消息的优先级，此数越小表示优先级越高。消息名称是长度不超过10个字符且不含空格的字符串；题目保证队列中消息的优先级无重复，且输入至少有一个GET。
输出格式: 对于每个GET指令，在一行中输出消息队列中优先级最高的消息的名称和参数。如果消息队列中没有消息，输出EMPTY QUEUE!。对于PUT指令则没有输出。
输入样例: 9PUT msg1 5PUT msg2 4GETPUT msg3 2PUT msg4 4GETGETGETGET输出样例: msg2msg3msg4msg1EMPTY QUEUE!AC代码 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; struct node { char s[12]; int p; friend bool operator&amp;lt;(const node &amp;amp;a, const node &amp;amp;b) { return a.p &amp;gt; b.p; } node(char *a, int b) { strcpy(s, a); p = b; } }; priority_queue&amp;lt;node&amp;gt; Q; int main() { int T; scanf(&amp;#34;%d&amp;#34;, &amp;amp;T); char tmp[4], t[12]; int p; while (T--) { scanf(&amp;#34;%s&amp;#34;, tmp); if (tmp[0] == &amp;#39;P&amp;#39;) { scanf(&amp;#34;%s %d&amp;#34;, t, &amp;amp;p); Q.</description>
    </item>
    
    <item>
      <title>两个有序序列的中位数</title>
      <link>https://fffzlfk.gitlab.io/2019/12/31/%D0%B5%CE%BB/</link>
      <pubDate>Tue, 31 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/12/31/%D0%B5%CE%BB/</guid>
      <description>问题描述 已知有两个等长的非降序序列S1, S2, 设计函数求S1与S2并集的中位数。有序序列A ​0 ​​ ,A ​1 ​​ ,⋯,A ​N−1 ​​ 的中位数指A ​(N−1)/2 ​​ 的值,即第⌊(N+1)/2⌋个数（A ​0 ​​ 为第1个数）。
输入格式: 输入分三行。第一行给出序列的公共长度N（0&amp;lt;N≤100000），随后每行输入一个序列的信息，即N个非降序排列的整数。数字用空格间隔。
输出格式: 在一行中输出两个输入序列的并集序列的中位数。
输入样例1: 51 3 5 7 92 3 4 5 6输出样例1: 4输入样例2: 6-100 -10 1 1 1 1-50 0 2 3 4 5输出样例2: 1代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; q; int main() { int n; scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); int t; for (int i = 1; i &amp;lt;= 2 * n; i++) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); q.</description>
    </item>
    
    <item>
      <title>汉诺塔问题</title>
      <link>https://fffzlfk.gitlab.io/2019/12/20/%C5%B5/</link>
      <pubDate>Fri, 20 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/12/20/%C5%B5/</guid>
      <description>问题描述 借助堆栈以非递归（循环）方式求解汉诺塔的问题（n, a, b, c），即将N个盘子从起始柱（标记为“a”）通过借助柱（标记为“b”）移动到目标柱（标记为“c”），并保证每个移动符合汉诺塔问题的要求。
输入格式: 输入为一个正整数N，即起始柱上的盘数。
输出格式: 每个操作（移动）占一行，按柱1 -&amp;gt; 柱2的格式输出。
输入样例: 3输出样例: a -&amp;gt; ca -&amp;gt; bc -&amp;gt; ba -&amp;gt; cb -&amp;gt; ab -&amp;gt; ca -&amp;gt; c代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; void move(char a, char b) { printf(&amp;#34;%c -&amp;gt; %c\n&amp;#34;, a, b); } void hanoi(int n, char a, char b, char c) { if (n == 1) move(a, c); else { hanoi(n - 1, a, c, b); move(a, c); hanoi(n - 1, b, a, c); } } int main() { int n; cin &amp;gt;&amp;gt; n; hanoi(n, &amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;); return 0; } </description>
    </item>
    
    <item>
      <title>关键活动</title>
      <link>https://fffzlfk.gitlab.io/2019/12/19/%D8%BC/</link>
      <pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/12/19/%D8%BC/</guid>
      <description>问题描述 假定一个工程项目由一组子任务构成，子任务之间有的可以并行执行，有的必须在完成了其它一些子任务后才能执行。“任务调度”包括一组子任务、以及每个子任务可以执行所依赖的子任务集。
比如完成一个专业的所有课程学习和毕业设计可以看成一个本科生要完成的一项工程，各门课程可以看成是子任务。有些课程可以同时开设，比如英语和C程序设计，它们没有必须先修哪门的约束；有些课程则不可以同时开设，因为它们有先后的依赖关系，比如C程序设计和数据结构两门课，必须先学习前者。
但是需要注意的是，对一组子任务，并不是任意的任务调度都是一个可行的方案。比如方案中存在“子任务A依赖于子任务B，子任务B依赖于子任务C，子任务C又依赖于子任务A”，那么这三个任务哪个都不能先执行，这就是一个不可行的方案。
任务调度问题中，如果还给出了完成每个子任务需要的时间，则我们可以算出完成整个工程需要的最短时间。在这些子任务中，有些任务即使推迟几天完成，也不会影响全局的工期；但是有些任务必须准时完成，否则整个项目的工期就要因此延误，这种任务就叫“关键活动”。
请编写程序判定一个给定的工程项目的任务调度是否可行；如果该调度方案可行，则计算完成整个工程项目需要的最短时间，并输出所有的关键活动。
输入格式: 输入第1行给出两个正整数N(≤100)和M，其中N是任务交接点（即衔接相互依赖的两个子任务的节点，例如：若任务2要在任务1完成后才开始，则两任务之间必有一个交接点）的数量。交接点按1~N编号，M是子任务的数量，依次编号为1~M。随后M行，每行给出了3个正整数，分别是该任务开始和完成涉及的交接点编号以及该任务所需的时间，整数间用空格分隔。
输出格式: 如果任务调度不可行，则输出0；否则第1行输出完成整个工程项目需要的时间，第2行开始输出所有关键活动，每个关键活动占一行，按格式“V-&amp;gt;W”输出，其中V和W为该任务开始和完成涉及的交接点编号。关键活动输出的顺序规则是：任务开始的交接点编号小者优先，起点编号相同时，与输入时任务的顺序相反。
输入样例: 7 81 2 41 3 32 4 53 4 34 5 14 6 65 7 56 7 2输出样例: 171-&amp;gt;22-&amp;gt;44-&amp;gt;66-&amp;gt;7代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int n, m; struct Node { int id; int len; }; vector&amp;lt;Node&amp;gt; G[105]; int ve[105]; int vl[105]; int in[105]; stack&amp;lt;int&amp;gt; S; void read() { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); int a, b, c; while (m--) { scanf(&amp;#34;%d%d%d&amp;#34;, &amp;amp;a, &amp;amp;b, &amp;amp;c); Node t; t.</description>
    </item>
    
    <item>
      <title>求前缀表达式的值</title>
      <link>https://fffzlfk.gitlab.io/2019/12/19/%C7%B0%CA%BD%D6%B5/</link>
      <pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/12/19/%C7%B0%CA%BD%D6%B5/</guid>
      <description>问题描述 算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。前缀表达式指二元运算符位于两个运算数之前，例如2+3*(7-4)+8/4的前缀表达式是：+ + 2 * 3 - 7 4 / 8 4。请设计程序计算前缀表达式的结果值。
输入格式: 输入在一行内给出不超过30个字符的前缀表达式，只包含+、-、*、/以及运算数，不同对象（运算数、运算符号）之间以空格分隔。
输出格式: 输出前缀表达式的运算结果，保留小数点后1位，或错误信息ERROR。
输入样例: + + 2 * 3 - 7 4 / 8 4输出样例: 13.0代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; float calculate(float x, float y, char t) { switch (t) { case &amp;#39;+&amp;#39;: return x + y; break; case &amp;#39;-&amp;#39;: return x - y; break; case &amp;#39;*&amp;#39;: return x * y; break; case &amp;#39;/&amp;#39;: if (y == 0.</description>
    </item>
    
    <item>
      <title>哥尼斯堡七桥问题</title>
      <link>https://fffzlfk.gitlab.io/2019/12/08/%C4%A1/</link>
      <pubDate>Sun, 08 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/12/08/%C4%A1/</guid>
      <description>问题描述 哥尼斯堡是位于普累格河上的一座城市，它包含两个岛屿及连接它们的七座桥，如下图所示。
可否走过这样的七座桥，而且每桥只走过一次？瑞士数学家欧拉(Leonhard Euler，1707—1783)最终解决了这个问题，并由此创立了拓扑学。
这个问题如今可以描述为判断欧拉回路是否存在的问题。欧拉回路是指不令笔离开纸面，可画过图中每条边仅一次，且可以回到起点的一条回路。现给定一个无向图，问是否存在欧拉回路？
输入格式: 输入第一行给出两个正整数，分别是节点数N (1≤N≤1000)和边数M；随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个节点的编号（节点从1到N编号）。
输出格式: 若欧拉回路存在则输出1，否则输出0。
样例 输入样例1: 6 101 22 33 14 55 66 41 41 63 43 6输出样例1: 1输入样例2: 5 81 21 32 32 42 55 35 43 4输出样例2: 0代码实现 使用并查集判断连通性 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int n, m; struct { int pre; int dgr = 0; } Node[1005]; int find(int i) { return Node[i].</description>
    </item>
    
    <item>
      <title>堆中的路径</title>
      <link>https://fffzlfk.gitlab.io/2019/12/05/%D0%B5/</link>
      <pubDate>Thu, 05 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/12/05/%D0%B5/</guid>
      <description>问题描述 将一系列给定数字插入一个初始为空的小顶堆H[]。随后对任意给定的下标i，打印从H[i]到根结点的路径。
输入格式: 每组测试第1行包含2个正整数N和M(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的N个要被插入一个初始为空的小顶堆的整数。最后一行给出M个下标。
输出格式: 对输入中给出的每个下标i，在一行中输出从H[i]到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。
输入样例: 5 346 23 26 24 105 4 3输出样例: 24 23 1046 23 1026 10代码实现 #include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std; int n; int m; int h[1005]; int s = 0; void add(int k) { s++; int i; for (i = s; h[i / 2] &amp;gt; k; i /= 2) h[i] = h[i / 2]; h[i] = k; } int main() { cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; int t; int N = n; h[0] = -10001; //注意h[0]要很小，否则会进入死循环  while (N--) { cin &amp;gt;&amp;gt; t; add(t); } while (m--) { cin &amp;gt;&amp;gt; t; while (t !</description>
    </item>
    
    <item>
      <title>希尔排序&amp;快排&amp;堆排序</title>
      <link>https://fffzlfk.gitlab.io/2019/12/04//</link>
      <pubDate>Wed, 04 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/12/04//</guid>
      <description>希尔排序 算法描述 代码实现 #include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std; void ShellInsert(vector&amp;lt;int&amp;gt; &amp;amp;L, int dk) { for (int i = dk; i &amp;lt; L.size(); i++) { int j; int tmp; if (L[i] &amp;lt; L[i - dk]) { tmp = L[i]; // 暂存  for (j = i - dk; j &amp;gt; 0 &amp;amp;&amp;amp; L[j] &amp;gt; tmp; j -= dk) L[j + dk] = L[j]; //向后移动到插入位置  L[j + dk] = tmp; //插入  } } } void ShellSort(vector&amp;lt;int&amp;gt; &amp;amp;L, int dlta[], int t) { for (int k = 0; k &amp;lt; t; k++) ShellInsert(L, dlta[k]); } int main(int argc, char const *argv[]) { vector&amp;lt;int&amp;gt; L = {0, 3, 1, 4, 7, 4, 2, 9}; int dlta[] = {3, 2, 1}; ShellSort(L, dlta, 3); vector&amp;lt;int&amp;gt;::iterator it = L.</description>
    </item>
    
    <item>
      <title>二叉排序树的合并</title>
      <link>https://fffzlfk.gitlab.io/2019/12/01/%CF%B2/</link>
      <pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/12/01/%CF%B2/</guid>
      <description>问题描述 试编写程序，将两棵二叉排序树合并为一棵二叉排序树。
输入格式 按照先序序列，分两行输入两棵二叉排序树各结点（结点值大于0），其中-1表示取消建立子树结点。
输出格式 按照中序序列输出合并后的二叉排序树。
输入样例 12 8 4 -1 -1 10 -1 -1 16 13 -1 -1 18 -1 -117 6 2 -1 -1 9 -1 -1 24 19 -1 -1 26 -1 -1输出样例 2 4 6 8 9 10 12 13 16 17 18 19 24 26代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; struct TreeNode { int data; TreeNode *left; TreeNode *right; TreeNode(int n) : data(n) {} }; void createBTree(TreeNode *&amp;amp;root) { int t; scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); if (t !</description>
    </item>
    
    <item>
      <title>哈希表设计</title>
      <link>https://fffzlfk.gitlab.io/2019/12/01/%CF%A3/</link>
      <pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/12/01/%CF%A3/</guid>
      <description>问题描述 针对某个集体（比如你所在的班级）中的“人名”设计一个哈希表，使得平均查找长度不超过R，完成相应的建表和查表程序。
基本要求 假设人名为中国人姓名的汉语拼音形式。待填入哈希表的人名共有30个，取平均查找长度的上限为2。哈希函数用除留余数法构造，用伪随机探测再散列发处理冲突。
代码实现 #include &amp;lt;iostream&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;using namespace std; #define M 50 struct name { char str[20]; int value; } Name[30]; struct hash { char name[20]; int key; int sum; int flag; } HashList[M]; void init() { FILE *fp; fp = fopen(&amp;#34;text.txt&amp;#34;, &amp;#34;r&amp;#34;); for (int i = 0; i &amp;lt; 30; i++) { fgets(Name[i].str, 20, fp); int j = 0; for (; Name[i].str[j] != &amp;#39;\n&amp;#39;; j++) ; Name[i].</description>
    </item>
    
    <item>
      <title>六度空间</title>
      <link>https://fffzlfk.gitlab.io/2019/11/29/%C8%BF%D5%BC/</link>
      <pubDate>Fri, 29 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/29/%C8%BF%D5%BC/</guid>
      <description>问题描述 “六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。
“六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。
假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。
输入格式: 输入第1行给出两个正整数，分别表示社交网络图的结点数N（1&amp;lt;N≤1000​ ，表示人数）、边数M≤33×N，表示社交关系数）。随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到N编号）。
输出格式: 对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。
输入样例: 10 91 22 33 44 55 66 77 88 99 10输出样例: 1: 70.00%2: 80.00%3: 90.00%4: 100.00%5: 100.00%6: 100.00%7: 100.00%8: 90.00%9: 80.00%10: 70.00%代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int n, m; int arcs[1005][1005]; int d[1005][1005]; void read() { cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; int a, b; for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= n; j++) arcs[i][j] = 2005; } while (m--) { cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; arcs[a][b] = 1; arcs[b][a] = 1; } } void solve() { for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= n; j++) { d[i][j] = arcs[i][j]; } } for (int i = 1; i &amp;lt;= n; i++) d[i][i] = 0; for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= n; j++) { for (int k = 1; k &amp;lt;= n; k++) { d[j][k] = min(d[j][i] + d[i][k], d[j][k]); } } } } void print() { for (int i = 1; i &amp;lt;= n; i++) { double count = 0; for (int j = 1; j &amp;lt;= n; j++) { if (d[i][j] &amp;lt;= 6) count++; } printf(&amp;#34;%d: %.</description>
    </item>
    
    <item>
      <title>列出可连通集</title>
      <link>https://fffzlfk.gitlab.io/2019/11/28/%D0%B3%CD%A8/</link>
      <pubDate>Thu, 28 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/28/%D0%B3%CD%A8/</guid>
      <description>问题描述 给定一个有N个顶点和E条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到N−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。
输入格式: 输入第1行给出2个整数N(0&amp;lt;N≤10)和E，分别是图的顶点数和边数。随后E行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。
输出格式: 按照如下的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。
输入样例: 8 60 70 12 04 12 43 5输出样例: { 0 1 4 2 7 }{ 3 5 }{ 6 }代码实现 DFS #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int N, E; bool visit[11]; bool arcs[11][11]; void read() { cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; E; int a, b; while (E--) { cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; arcs[a][b] = 1; arcs[b][a] = 1; } } void dfs(int v) { printf(&amp;#34; %d&amp;#34;, v); visit[v] = 1; for (int i = 0; i &amp;lt; N; i++) { if (!</description>
    </item>
    
    <item>
      <title>二叉树的遍历</title>
      <link>https://fffzlfk.gitlab.io/2019/11/26/%C4%B1/</link>
      <pubDate>Tue, 26 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/26/%C4%B1/</guid>
      <description>问题描述 二叉树的遍历 本题要求给定二叉树的4种遍历。
函数接口定义：
void InorderTraversal( BinTree BT ); void PreorderTraversal( BinTree BT ); void PostorderTraversal( BinTree BT ); void LevelorderTraversal( BinTree BT ); 其中BinTree结构定义如下：
typedef struct TNode *Position; typedef Position BinTree; struct TNode{ ElementType Data; BinTree Left; BinTree Right; }; 要求4个函数分别按照访问顺序打印出结点的内容，格式为一个空格跟着一个字符。
输出样例 （对于图中给出的树）：
Inorder: D B E F A G H C IPreorder: A B D F E C G H IPostorder: D E F B H G I C ALevelorder: A B C D F G I E H代码实现 void InorderTraversal(BinTree BT) { if (BT) { InorderTraversal(BT-&amp;gt;Left); printf(&amp;#34; %c&amp;#34;, BT-&amp;gt;Data); InorderTraversal(BT-&amp;gt;Right); } else { return; } } void PreorderTraversal(BinTree BT) { if (BT) { printf(&amp;#34; %c&amp;#34;, BT-&amp;gt;Data); PreorderTraversal(BT-&amp;gt;Left); PreorderTraversal(BT-&amp;gt;Right); } else { return; } } void PostorderTraversal(BinTree BT) { if (BT) { PostorderTraversal(BT-&amp;gt;Left); PostorderTraversal(BT-&amp;gt;Right); printf(&amp;#34; %c&amp;#34;, BT-&amp;gt;Data); } else { return; } } void LevelorderTraversal(BinTree BT) { BinTree Q[100]; int front = 0; int rear = 0; if (BT) { Q[++rear] = BT; } while (front !</description>
    </item>
    
    <item>
      <title>二叉树前序、中序、后序遍历的相互求法</title>
      <link>https://fffzlfk.gitlab.io/2019/11/24/%D7%AA/</link>
      <pubDate>Sun, 24 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/24/%D7%AA/</guid>
      <description>一、已知前序、中序、求后序遍历 例如：
前序遍历: GDAFEMHZ中序遍历: ADEFGHMZ  根据前序遍历的特点，我们知道根结点为G
  观察中序遍历ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树，G右侧的HMZ必然是root的右子树。
  观察左子树ADEF，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为D。
  同样的道理，root的右子树节点HMZ中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。
  观察发现，上面的过程是递归的。先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。该步递归的过程可以简洁表达如下：
 确定根,确定左子树，确定右子树。 在左子树中递归。 在右子树中递归。 打印当前根。    核心代码
buildTreebyPre(preorder + 1, inorder, root_idx, root-&amp;gt;left); buildTreebyPre(preorder + 1 + root_idx, inorder + root_idx + 1, length - (root_idx + 1), root-&amp;gt;right); 二、已知中序、后序遍历、求前序遍历 依然是上面的题，这次我们只给出中序和后序遍历：
中序遍历: ADEFGHMZ后序遍历: AEFDHZMG  根据后序遍历的特点，我们知道后序遍历最后一个结点即为根结点，即根结点为G。
  观察中序遍历ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树，G右侧的HMZ必然是root的右子树。
  观察左子树ADEF，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为D。
  同样的道理，root的右子树节点HMZ中的根节点也可以通过前序遍历求得。在前后序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。</description>
    </item>
    
    <item>
      <title>LeetCode-50 &amp; LeetCode-34</title>
      <link>https://fffzlfk.gitlab.io/2019/11/23/leetcode-50/</link>
      <pubDate>Sat, 23 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/23/leetcode-50/</guid>
      <description>LeetCode-50-Pow(x, n) 问题描述 实现 pow(x, n) ，即计算 x 的 n 次幂函数。
 示例 1:  输入: 2.00000, 10输出: 1024.00000 示例 2:  输入: 2.10000, 3输出: 9.26100 示例 3:  输入: 2.00000, -2输出: 0.25000 解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 &amp;lt; x &amp;lt; 100.0, n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。  代码实现 class Solution { public: double quickPow(double x, long long n) { if (n == 0) return 1.</description>
    </item>
    
    <item>
      <title>POJ-2387-Til_the_Cows_Come_Home</title>
      <link>https://fffzlfk.gitlab.io/2019/11/22/poj2387/</link>
      <pubDate>Fri, 22 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/22/poj2387/</guid>
      <description>问题描述 贝西（Bessie）在野外，想回到谷仓以尽可能多地睡觉，直到农夫约翰（John Farmer）叫醒她早上进行挤奶。贝西需要美睡，所以她想尽快回来。
农夫约翰的田地里有N（2 &amp;lt;= N &amp;lt;= 1000）个地标，唯一编号为1..N。地标1是谷仓；Bessie整日站立的苹果树丛是地标N。奶牛使用地标之间长度各异的T（1 &amp;lt;= T &amp;lt;= 2000）双向奶牛场在田间旅行。贝西对自己的导航能力不抱有信心，因此，从开始到结束，她始终保持在步道上。
给定地标之间的路径，确定Bessie返回谷仓必须行走的最小距离。可以保证存在这样的路经。
大意 题目会给你n个点，m条边，然后给你每条边又哪两个点相连，并且其中的路程是多少。我们需要找到最短路径的总路程。
样例输入 5 51 2 202 3 303 4 204 5 201 5 100样例输出 90代码实现 #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std; #define Max 0xfffffff #define N 1005 int arcs[N][N]; int visit[N]; int f[N]; int n, t; void shortestPath() { int i, j, k, min; memset(visit, 0, sizeof(visit)); for (i = 1; i &amp;lt;= n; i++) f[i] = arcs[1][i]; f[1] = 0; for (i = 1; i &amp;lt; n; i++) { min = Max; for (j = 1; j &amp;lt;= n; j++) { if (!</description>
    </item>
    
    <item>
      <title>二分查找及二叉排序树</title>
      <link>https://fffzlfk.gitlab.io/2019/11/22/%D6%B2%D2%BD%D2%B7/</link>
      <pubDate>Fri, 22 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/22/%D6%B2%D2%BD%D2%B7/</guid>
      <description>问题描述  顺序表的二分查找（折半查找),同时实现寻找左边界和右边界的算法 二叉排序树的查找、删除以及添加结点  代码实现 二分查找 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int search_bi(vector&amp;lt;int&amp;gt; nums, int target) { int low = 0; int high = nums.size() - 1; int mid; while (low &amp;lt;= high) { mid = (low + high) / 2; if (nums[mid] == target) return mid; else if (nums[mid] &amp;lt; target) { low = mid + 1; } else { high = mid - 1; } } return -1; } int search_left(vector&amp;lt;int&amp;gt; nums, int target) { // 寻找左边界  if (!</description>
    </item>
    
    <item>
      <title>最小生成树的求法</title>
      <link>https://fffzlfk.gitlab.io/2019/11/21/%D1%81/</link>
      <pubDate>Thu, 21 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/21/%D1%81/</guid>
      <description>问题描述 请对下图的无向带权图 (1)写出它的邻接矩阵，并按普里姆算法求其最小生成树； (2)写出它的邻接表，并按克鲁斯卡尔算法求其最小生成树。 问题解决 邻接矩阵 0 4 3 - - - - -4 0 5 5 9 - - -3 5 0 5 - - - 5- 5 5 0 7 6 5 4- 9 - 7 0 3 - -- - - 6 3 0 2 -- - - 5 - 2 0 6- - 5 4 - - 6 0#include &amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>105.从前序与中序遍历序列构造二叉树</title>
      <link>https://fffzlfk.gitlab.io/2019/11/17/leetcode-105-%C7%B0%D0%B9/</link>
      <pubDate>Sun, 17 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/17/leetcode-105-%C7%B0%D0%B9/</guid>
      <description>问题描述 题目链接
根据一棵树的前序遍历与中序遍历构造二叉树。
  注意: 你可以假设树中没有重复的元素。
  例如，给出
  前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树：
 3/ \9 20/ \15 7代码实现 class Solution { public: vector&amp;lt;int&amp;gt; pre_order; vector&amp;lt;int&amp;gt; in_order; map&amp;lt;int,int&amp;gt; m; int pre_idx = 0; TreeNode* help(int inleft, int inright) { if (inleft == inright) return NULL; int root_val = pre_order[pre_idx]; TreeNode *root = new TreeNode(root_val); int index = m[root_val]; pre_idx++; root-&amp;gt;left = help(inleft, index); root-&amp;gt;right = help(index + 1, inright); return root; } TreeNode* buildTree(vector&amp;lt;int&amp;gt;&amp;amp; preorder, vector&amp;lt;int&amp;gt;&amp;amp; inorder) { pre_order = preorder; in_order = inorder; for (int i = 0; i &amp;lt; (int)inorder.</description>
    </item>
    
    <item>
      <title>98.验证二叉搜索树</title>
      <link>https://fffzlfk.gitlab.io/2019/11/17/leetcode-98-%D6%A4/</link>
      <pubDate>Sun, 17 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/17/leetcode-98-%D6%A4/</guid>
      <description>问题描述 给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。
示例 示例 1:  输入:   2/ \1 3 输出: true  示例 2:  输入:   5/ \1 4/ \3 6 输出: false  解释: 输入为: [5,1,4,null,null,3,6]。  根节点的值为 5 ，但是其右子节点值为 4 。
代码实现 bool helper(struct TreeNode *root, int lower, int upper) { if (!root) return true; // printf(&amp;#34;current low:%d\ncurrent up:%d\n&amp;#34;, lower, upper); 	if (lower !</description>
    </item>
    
    <item>
      <title>无向图的遍历</title>
      <link>https://fffzlfk.gitlab.io/2019/11/15/%CD%BC%C4%B1/</link>
      <pubDate>Fri, 15 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/15/%CD%BC%C4%B1/</guid>
      <description>问题描述  分别使用邻接表和邻接矩阵存储无向图图，并设计深度优先搜索遍历算法和广度优先搜索遍历算法。 用1,2,3，&amp;hellip;，表示结点 并分别求出深度优先生成树和广度优先生成树的边集。  代码实现 邻接表 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define MAX_VERTEX_NUM 31 typedef int InfoType; typedef int VertexType; bool visited[MAX_VERTEX_NUM]; bool dfs_arc[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; bool bfs_arc[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; typedef struct ArcNode { int adjvex; ArcNode *nextarc; InfoType *info; } ArcNode; typedef struct VNode { VertexType data; ArcNode *firstarc; } VNode, AdjList[MAX_VERTEX_NUM]; typedef struct { AdjList vertices; int vexnum, arcnum; int kind; } ALGraph; //创建无向图 void Create(ALGraph &amp;amp;G) { puts(&amp;#34;输入节点数和边数&amp;#34;); scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;G.vexnum, &amp;amp;G.arcnum); for (int i = 1; i &amp;lt;= G.</description>
    </item>
    
    <item>
      <title>求元素子树深度</title>
      <link>https://fffzlfk.gitlab.io/2019/11/13/%D4%AB/</link>
      <pubDate>Wed, 13 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/13/%D4%AB/</guid>
      <description>问题描述 请设计递归算法求以元素为x根节点的子树深度
代码实现 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define OK 1 #define ERROR 0 typedef char ElemType; typedef int Status; typedef struct Node { ElemType data; Node *left; Node *right; } * BTree; Status createBTree(BTree &amp;amp;T) { ElemType c; scanf(&amp;#34;%c&amp;#34;, &amp;amp;c); getchar(); if (c == &amp;#39; &amp;#39;) T = NULL; else { if (!(T = (Node*)malloc(sizeof(Node)))) return ERROR; T-&amp;gt;data = c; printf(&amp;#34;请输入%c的左孩子\n&amp;#34;, c); createBTree(T-&amp;gt;left); printf(&amp;#34;请输入%c的右孩子\n&amp;#34;, c); createBTree(T-&amp;gt;right); } } int getDepth(BTree T) { if (T == NULL) return 0; else { return getDepth(T-&amp;gt;left) &amp;gt; getDepth(T-&amp;gt;right) ?</description>
    </item>
    
    <item>
      <title>哈夫曼编码及译码器</title>
      <link>https://fffzlfk.gitlab.io/2019/11/10/%EB%BC%B0/</link>
      <pubDate>Sun, 10 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/10/%EB%BC%B0/</guid>
      <description>问题描述 利用哈夫曼编码进行通信可以大大提高信道利用率,缩短信息传输时间,降低传输成本。但是,这要求在发送端通过一个编码系统对待传数据预先码,在接收端将传来的数据进行译码(复原)。对于双工信道(即可以双向传输信息的信道),每端需要一个完编/译码系统。试为这样的信息收发站写一个哈夫曼码的编/译码系统。
基本要求 一个完整的系统应具有以下功能:
 I :初始化(Initialization)。从终端读人字符集大小n,以及n个字符和n个权值,建立哈夫曼树,并将它存于文件 hfmTree 中。 E :编码(Encoding)。利用以建好的哈夫曼树(如不在内存,则从文件 hfmTree 中读人),对文件 ToBeTran 中的正文进行编码,然后将结果存人文件 CodeFile 中。 D :译 码(Decoding)。利用已建好的哈夫曼树将文件 CodeFile 中的代码进行译码,结果存人文件 TextFile 中。 P :印代码文件(Print)。将文件 CodeFile 以紧凑格式显示在终端上,每行50个代码。同时将此字符形式的编码文件写人文件 CodePrin。 T :打印哈夫曼树(Tree printing)。将已在内存中的哈夫曼树以直观的方式(树或凹人表形式)显示在终端上,同时将此字符形式的哈夫曼树写人文件 TreePrint 中。  代码实现 #include &amp;lt;bits/stdc++.h&amp;gt;#define INT_MAX 2147483647 #define OK 1 #define ERROR 0 typedef char ElemType; typedef int Status; typedef struct { char c; int weight; int parent; int left; int right; char *code; } HNode; HNode *T; int n; Status select(HNode *T, int pos, int *s1, int *s2) { int m1, m2; m1 = m2 = INT_MAX; for (int j = 1; j &amp;lt;= pos; j++) { if (T[j].</description>
    </item>
    
    <item>
      <title>哈夫曼树和哈夫曼编码</title>
      <link>https://fffzlfk.gitlab.io/2019/11/07//</link>
      <pubDate>Thu, 07 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/07//</guid>
      <description>概念解释 Huffman树是一种特殊结构的二叉树，由Huffman树设计的二进制前缀编码，也称为Huffman编码在通信领域有着广泛的应用。
  路径长度 路径长度指的是路径上分支的数目，在上图中，路径长度为2。
  节点的权 节点的权指的是为树中的每一个节点赋予的一个非负的值，如上图中每一个节点中的值。
  节点的带权路径长度 节点的带权路径长度指的是从根节点到该节点之间的路径长度与该节点权的乘积：如对于1节点的带权路径长度为：2。
  树的带权路径长度 树的带权路径长度指的是所有叶子节点的带权路径长度之和。
   有了如上的概念，对于Huffman树，其定义为： 给定nn权值作为nn个叶子节点，构造一棵二叉树，若这棵二叉树的带权路径长度达到最小，则称这样的二叉树为最优二叉树，也称为Huffman树。
 解决方法 重复以下的步骤：
 按照权值对每一个节点排序：D-F-T-E-R-A 选择权值最小的两个节点，此处为D和F生成新的节点，节点的权重这两个节点的权重之和，为2 直到只剩最后的根节点  代码实现 readfile #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; const int MAXSIZE = 1000; int read_file(FILE *fn, map&amp;lt;char, int&amp;gt; &amp;amp;word) { if (fn == NULL) return -1; char line[MAXSIZE]; while (fgets(line, 1024, fn)) { fprintf(stderr, &amp;#34;%s\n&amp;#34;, line); char *p = line; while (*p !</description>
    </item>
    
    <item>
      <title>约瑟夫环问题</title>
      <link>https://fffzlfk.gitlab.io/2019/11/06/%D5%AC%C9%AA/</link>
      <pubDate>Wed, 06 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/06/%D5%AC%C9%AA/</guid>
      <description>问题描述 编号为1, 2, 3,&amp;hellip;,n的n个人围成一圈，每个人持有一个密码（正整数），从初始m为上限从1开始报数，报到m为止，报m的出列，将他的密码作为下一个m值，如此下去，求出出列顺序。
解决思路 很容易想到用循环链表来解决该问题
测试样例 样例输入 7 203 1 7 2 4 8 4样例输出 6147235代码实现 Clang #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; typedef struct Node { int data; int id; Node *next; } * LinkList; void Create(LinkList &amp;amp;L, int n) { L = (Node*)malloc(sizeof(Node)); Node *node, *end; end = L; for (int i = 0; i &amp;lt; n; i++) { node = (Node*)malloc(sizeof(Node)); scanf(&amp;#34;%d&amp;#34;, &amp;amp;node-&amp;gt;data); node-&amp;gt;id = i + 1; end-&amp;gt;next = node; end = node; } end-&amp;gt;next = L-&amp;gt;next; } int solve(LinkList &amp;amp;L, int m) { if (m &amp;lt; 1) return -1; int t = m; Node *last = L-&amp;gt;next; Node *cur = L-&amp;gt;next; while (cur-&amp;gt;next !</description>
    </item>
    
    <item>
      <title>魔王语言解释</title>
      <link>https://fffzlfk.gitlab.io/2019/11/06/%C4%A7%D5%AD/</link>
      <pubDate>Wed, 06 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/11/06/%C4%A7%D5%AD/</guid>
      <description>问题描述 有一个魔王总是使用自己的一种非常精练而抽象的语言讲话，没人能听的懂。但他的语言是可以逐步解释成人能懂得语言的，因为他的语言是由以下两种形式的规则由人的语言逐 步抽象上去的：
 （1）α-&amp;gt;β1β2&amp;hellip;βn （2）(θδ1δ2&amp;hellip;δn)-&amp;gt;θδnθδn-1&amp;hellip;θδ1θ   在这两种形式中，从左到右均表示解释；从右到左表示抽象。试写一个魔王解释系统，把他的话解释成人能听懂得话。
 基本要求 用下述两条具体规则和上述规则实现。设大写字母表示魔王语言的词汇；小写字母表示人的语言词汇；希腊字母（a,b1,s,y1等）表示可以用大写或小写字母代换的变量。魔王语言可含人的词汇。
 (1) B-&amp;gt;tAdA (2) A-&amp;gt;sae  测试数据 B（ehnxgz）B 解释成tsaedsaeezegexeneietsaedsae 若将小写字母与汉字建立下表所示的对应关系，则魔王说的话是“天上一个鹅地上一个鹅鹅追鹅赶鹅下鹅蛋鹅恨鹅天上一个鹅地上一个鹅。” t d s a e z g x n i
天 地 上 一个 鹅 追 赶 下 蛋 恨
代码实现 C++ #include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;using namespace std; void solve(char c, stack&amp;lt;char&amp;gt; &amp;amp;S, string &amp;amp;str) { if (c &amp;gt;= &amp;#39;a&amp;#39; &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;z&amp;#39;) { printf(&amp;#34;%c&amp;#34;, c); str += c; } else if (c == &amp;#39;A&amp;#39;) { printf(&amp;#34;sae&amp;#34;); str += &amp;#34;sae&amp;#34;; } else if (c == &amp;#39;B&amp;#39;) { printf(&amp;#34;tsaedsae&amp;#34;); str += &amp;#34;tsaedsae&amp;#34;; } else if (c == &amp;#39;(&amp;#39;) { stack&amp;lt;char&amp;gt; SS; S.</description>
    </item>
    
    <item>
      <title>二叉树的创建和遍历</title>
      <link>https://fffzlfk.gitlab.io/2019/10/30/%C4%B5%CD%B1/</link>
      <pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/10/30/%C4%B5%CD%B1/</guid>
      <description>问题描述 用C语言实现二叉树的表示及非递归中序遍历算法（没啥说的直接上代码）
代码实现 #include &amp;lt;iostream&amp;gt;#include &amp;lt;stack&amp;gt; #define MAXSIZE 1000 #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2  typedef int Status; typedef char ElemType; using namespace std; typedef struct BiTNode { ElemType data; struct BiTNode *lchild, *rchild; } BiTNode, * BiTree; Status CreateBiTree(BiTree &amp;amp;T) { ElemType ch; scanf(&amp;#34;%c&amp;#34;, &amp;amp;ch); getchar(); if (ch == &amp;#39; &amp;#39;) T = NULL; else { if (!</description>
    </item>
    
    <item>
      <title>链栈</title>
      <link>https://fffzlfk.gitlab.io/2019/10/23/%D5%BB%CA%B5/</link>
      <pubDate>Wed, 23 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/10/23/%D5%BB%CA%B5/</guid>
      <description>简介 链栈一般用一个头指针结构top来表示，它指向栈顶元素，对于链表来说，top结构相当于它的头指针head。
代码实现 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; struct Node { int data; Node *next; }; typedef struct { Node *top; int count; } * Stack; void InitStack(Stack &amp;amp;s) { s-&amp;gt;top = (Node*)malloc(sizeof(Node)); if (!s-&amp;gt;top) { puts(&amp;#34;ERROR&amp;#34;); return; } s-&amp;gt;top = NULL; s-&amp;gt;count = 0; } void Push(Stack &amp;amp;s, int e) { Node *node = (Node*)malloc(sizeof(Node)); node-&amp;gt;data = e; node-&amp;gt;next = s-&amp;gt;top; s-&amp;gt;top = node; s-&amp;gt;count++; } int Pop(Stack &amp;amp;s) { if (s-&amp;gt;count == 0) { puts(&amp;#34;Empty&amp;#34;); exit(0); } Node *t = s-&amp;gt;top; s-&amp;gt;top = s-&amp;gt;top-&amp;gt;next; int e = t-&amp;gt;data; free(t); s-&amp;gt;count--; return e; } void ClearStack(Stack &amp;amp;s) { if (s-&amp;gt;count == 0) return; Node *p, *q; p = s-&amp;gt;top; while (p) { q = p; p = p-&amp;gt;next; free(q); } s-&amp;gt;count = 0; } int main(int argc, char const *argv[]) { Stack s; InitStack(s); for (int i = 0; i &amp;lt; 10; i++) Push(s, i); // ClearStack(s); 	printf(&amp;#34;%d\n&amp;#34;, Pop(s)); Push(s, 100); for (int i = 0; i &amp;lt; 11; i++) { printf(&amp;#34;%d\n&amp;#34;, Pop(s)); } return 0; } </description>
    </item>
    
    <item>
      <title>删除子串</title>
      <link>https://fffzlfk.gitlab.io/2019/10/21/%C9%BE%D3%B5/</link>
      <pubDate>Mon, 21 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/10/21/%C9%BE%D3%B5/</guid>
      <description>问题描述 删除s中所有与t相同的子串
 如 s = &amp;ldquo;abcdabcdabcd&amp;rdquo;, t = &amp;ldquo;cd&amp;rdquo;, 则操作后s = &amp;ldquo;ababab&amp;rdquo;
 代码实现 #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std; int* GetNext(string p) { int pLen = p.length(); int *next = new int[pLen]; next[0] = -1; int j = 0; int k = -1; while (j &amp;lt; pLen - 1) { if (k == -1 || p[j] == p[k]) { j++; k++; next[j] = k; } else { j = next[j]; } } return next; } void solve(string &amp;amp;s, string p) { int* next =GetNext(p); int sLen = s.</description>
    </item>
    
    <item>
      <title>求最长重复子串及其位置</title>
      <link>https://fffzlfk.gitlab.io/2019/10/19/%D8%B8%D3%B5%CE%BB/</link>
      <pubDate>Sat, 19 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/10/19/%D8%B8%D3%B5%CE%BB/</guid>
      <description>问题描述 给出一个线性排列的串s，求出s中出现的第一个最长重复子串及其位置；并分析时间复杂度。
 例如 s = &amp;ldquo;abcdbcd&amp;rdquo;，它的第一个出现的最长重复子串及其位置分别为：&amp;ldquo;bcd，1&amp;rdquo;。
 代码实现 #include &amp;lt;iostream&amp;gt;using namespace std; int* GetNext(string p) { int pLen = p.length(); int* next = new int[pLen]; next[0] = -1; int j = 0; int k = -1; while (j &amp;lt; pLen - 1) { if (k == -1 || p[k] == p[j]) { k++; j++; if (p[k] != p[j]) { next[j] = k; } else { next[j] = next[k]; } } else { k = next[k]; } } return next; } int KmpSearch(string s, string p) { int *next = GetNext(p); int sLen = s.</description>
    </item>
    
    <item>
      <title>KMP算法</title>
      <link>https://fffzlfk.gitlab.io/2019/10/13/kmp%E3%B7%A8/</link>
      <pubDate>Sun, 13 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/10/13/kmp%E3%B7%A8/</guid>
      <description>KMP算法描述  算法流程   设文本串匹配到i，模式串匹配到j
  若j == -1或者匹配成功(s[i] == p[j])，则i++，j++； 若j != -1且匹配不成功，则j = next[j]（相当于模式串p相对于文本串s向右移动(j - next[j])位）。  得到next数组   next数组表示当前字符之前的字符串中，有多大长度的相同前缀后缀
 对于P的前j+1个序列字符：
 若p[k] == p[j]，则next[j + 1 ] = next [j] + 1 = k + 1； 若p[k ] ≠ p[j]，如果此时p[ next[k] ] == p[j ]，则next[ j + 1 ] = next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。  代码实现 C语言 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt; #define MAXN 100  int* GetNext(char* p) { int pLen = strlen(p); int j = 0; int k = -1; int* next = new int[strlen(p)]; next[0] = -1; while (j &amp;lt; pLen - 1) { if (k == -1 || p[j] == p[k]) { j++; k++; if (p[j] !</description>
    </item>
    
    <item>
      <title>循环队列</title>
      <link>https://fffzlfk.gitlab.io/2019/10/10/%D1%AD/</link>
      <pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/10/10/%D1%AD/</guid>
      <description>问题描述 如果希望循环队列的每一个元素都能用到，需设置一个标志域tag，用tag的0或1来区分是否满队列。试写出这种结构的算法，并从时间和空间分析这两种这两种方法的适用范围。
带标志域（tag）的算法实现 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2  typedef int Status; typedef int ElemType; #define MAXSIZE 100 typedef struct { ElemType *base; int front; int rear; int tag; } SqQueue; Status InitQueue(SqQueue &amp;amp;Q) { Q.base = (ElemType*) malloc(MAXSIZE * sizeof(ElemType)); if (!Q.base) exit(OVERFLOW); Q.front = Q.rear = 0; Q.tag = 0; return OK; } int QueueLength(SqQueue Q) { return (Q.</description>
    </item>
    
    <item>
      <title>括号匹配</title>
      <link>https://fffzlfk.gitlab.io/2019/10/09/%C6%A5/</link>
      <pubDate>Wed, 09 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/10/09/%C6%A5/</guid>
      <description>问题描述 假设一个算术表达式中可以包含三种括号：圆括号&#39;(&amp;lsquo;和&amp;rsquo;)&#39;、方括号&#39;[&amp;lsquo;和 &amp;lsquo;]&amp;lsquo;以及花括号&amp;rsquo;{&amp;lsquo;和&amp;rsquo;}&#39;。编写判别所给表达式中所含括号是否正确。
解决方法 可用“期待匹配消解”的思想来设计算法，对表达式中每一个左括号都期待一个相应的右括号与之匹配，且自左至右按表达式中出现的先后论，越迟的左括号期待匹配的渴望程度越高。
代码实现 #include &amp;lt;iostream&amp;gt;#include &amp;lt;stack&amp;gt; using namespace std; bool is_march(string str) { stack&amp;lt;char&amp;gt; s; for (int i = 0; i &amp;lt; (int)str.length(); i++) { switch (str[i]) { case &amp;#39;(&amp;#39;: case &amp;#39;[&amp;#39;: case &amp;#39;{&amp;#39;: s.push(str[i]); break; case &amp;#39;)&amp;#39;: if (s.empty() || s.top() != &amp;#39;(&amp;#39;) return false; else s.pop(); break; case &amp;#39;]&amp;#39;: if (s.empty() || s.top() != &amp;#39;[&amp;#39;) return false; else s.pop(); break; case &amp;#39;}&amp;#39;: if (s.empty() || s.</description>
    </item>
    
    <item>
      <title>表达式求值</title>
      <link>https://fffzlfk.gitlab.io/2019/09/29/%CA%BD%D6%B5/</link>
      <pubDate>Sun, 29 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/09/29/%CA%BD%D6%B5/</guid>
      <description>问题描述 表达式求值是一个基本问题，是栈的一个应用。如计算： 输入&#39;#&amp;lsquo;代表结束。
算法基本思想 使用两个工作栈，一个存运算符(optr)，另一个存操作数或运算结果(opnd)。
 首先将&amp;rsquo;#&amp;lsquo;push到optr； 依次读入每个字符，若是操作数则进opnd（注意多位数情况），若为运算符则于比较optr栈顶运算符比较优先级完成相应操作。  代码实现 #include &amp;lt;iostream&amp;gt;#include &amp;lt;stack&amp;gt; using namespace std; int prec(char a, char b) { if (a == &amp;#39;+&amp;#39; || a == &amp;#39;-&amp;#39;) { if (b == &amp;#39;+&amp;#39; || b == &amp;#39;-&amp;#39; || b == &amp;#39;)&amp;#39; || b == &amp;#39;#&amp;#39;) return 1; else return -1; } else if (a == &amp;#39;*&amp;#39; || a == &amp;#39;/&amp;#39;) { if (b == &amp;#39;(&amp;#39;) return -1; else return 1; } else if (a == &amp;#39;(&amp;#39; || a == &amp;#39;#&amp;#39;) { if (a == &amp;#39;(&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;)&amp;#39;) return 0; else if (a == &amp;#39;(&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;#&amp;#39;) return -2; else if (a == &amp;#39;#&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;)&amp;#39;) return -2; else if (a == &amp;#39;#&amp;#39; &amp;amp;&amp;amp; b == &amp;#39;#&amp;#39;) return 0; else return -1; } else if (a == &amp;#39;)&amp;#39;) { if (b == &amp;#39;(&amp;#39;) return -2; else return 1; } return -2; } int Operate(int a, int b, char c) { if (c == &amp;#39;+&amp;#39;) return a + b; else if (c == &amp;#39;-&amp;#39;) return a - b; else if (c == &amp;#39;*&amp;#39;) return a * b; else if (c == &amp;#39;/&amp;#39;) return a / b; else exit(0); } int EvaluateExpression(string s) { stack&amp;lt;char&amp;gt; optr; stack&amp;lt;int&amp;gt; opnd; optr.</description>
    </item>
    
    <item>
      <title>数据结构课后作业</title>
      <link>https://fffzlfk.gitlab.io/2019/09/28/chp1%CE%BA%D2%B5/</link>
      <pubDate>Sat, 28 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/09/28/chp1%CE%BA%D2%B5/</guid>
      <description>请参考《数据结构题集（C语言版）》严慧敏版
 2.11 typedef int Status; typedef int ElemType; typedef struct { ElemType *elem; int length; int listsize; } SqList; Status InitList_Sq(SqList &amp;amp;L) { //构造一个空线性表 	L.elem = (ElemType*)malloc(LIST_INIT_SIZE * sizeof(ElemType)); if (!L.elem) exit(OVERFLOW); L.length = 0; L.listsize = LIST_INIT_SIZE; return OK; } Status ListInsert_Sq(SqList &amp;amp;L, int i, ElemType e) { //在顺序线性表L中的第i个位置之前插入新的元素e 	if (i &amp;lt; 1 || i &amp;gt; L.length + 1) return ERROR; if (L.length &amp;gt; L.listsize) { ElemType *newbase = (ElemType*) realloc(L.</description>
    </item>
    
    <item>
      <title>用C语言实现静态链表</title>
      <link>https://fffzlfk.gitlab.io/2019/09/20/c%CA%B5%CC%AC/</link>
      <pubDate>Fri, 20 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/09/20/c%CA%B5%CC%AC/</guid>
      <description>静态链表 用数组替代指针，数组中的每一项有两个域：data &amp;amp; cur；data用来存放数据，而cur则为游标，相当于链表中的next。 代码实现 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define MAXSIZE 1000 #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2  typedef int Status; typedef int ElemType; typedef struct { ElemType data; int cur; } Component, StaticLinkList[MAXSIZE]; /*将下标为k的空闲结点回收到备用链表*/ void Free_SSL(StaticLinkList space, int k) { space[k].cur = space[0].cur; space[0].cur = k; } int ListLength(StaticLinkList L) { int j = 0; int i = L[MAXSIZE-1].</description>
    </item>
    
    <item>
      <title>简单双向循环链表的表示和实现(C语言)</title>
      <link>https://fffzlfk.gitlab.io/2019/09/15/%D1%AD%C4%B1%CA%BE%CA%B5c/</link>
      <pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/09/15/%D1%AD%C4%B1%CA%BE%CA%B5c/</guid>
      <description>双向循环链表 双向链表的每一个节点有两个指针，一个是next（下一个），一个是prep（上一个），其他和单向类似；至于循环双向链表，它的结构为： 代码实现 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2  #define LIST_INIT_SIZE 100 #define LISTINCREMENT 10  typedef int Status; typedef int ElemType; typedef struct Node { ElemType value; Node* prep; Node* next; } DbLink; DbLink* CreateDbLink(int n) { DbLink *head, *node, *end; head = (DbLink*)malloc(sizeof(DbLink)); if (!head) exit(OVERFLOW); end = head; for (int i = 0; i &amp;lt; n; i++) { node = (DbLink*)malloc(sizeof(DbLink)); if (!</description>
    </item>
    
    <item>
      <title>归并两个非递减排列的线性表(C语言)</title>
      <link>https://fffzlfk.gitlab.io/2019/09/12/%E9%B2%A2%C7%B5%DD%BC%D0%B5%D5%A1c/</link>
      <pubDate>Thu, 12 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/09/12/%E9%B2%A2%C7%B5%DD%BC%D0%B5%D5%A1c/</guid>
      <description>问题 已知线性表La, Lb按非递减有序排列，现需要将La, Lb归并为一个新的非递减有序排列线性表Lc。例如
 La = (3, 5, 8, 11) Lb = (2, 6, 8, 20) 则Lc = (2, 3, 5, 6, 8, 8,11, 20)
 方法 设两个指针pa, pb分别指向La，Lb的首元素，当前应插入Lc的元素为复杂度 显然该算法为线性复杂度，即O(n)；原因是La, Lb为非递减有序排列，故lb中的每个元素不必遍历la中每个元素；而且Lc插入操作实则是通过复制完成的。
代码实现 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2  #define LIST_INIT_SIZE 100 #define LISTINCREMENT 10  typedef int Status; typedef int ElemType; typedef struct { ElemType *elem; int length; int listsize; } SqList; Status InitList_Sq(SqList &amp;amp;L) { //构造一个空线性表 	L.</description>
    </item>
    
    <item>
      <title>求两个简单链表的并集</title>
      <link>https://fffzlfk.gitlab.io/2019/09/07/%C4%BE/</link>
      <pubDate>Sat, 07 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/09/07/%C4%BE/</guid>
      <description>问题： 给出两个单向链表，求出它们的并集 例如：
 a = [1, 2, 3], b = [2, 3, 4]; 实现InterSect(a, b), 使得a = [1, 2, 3, 4]
 代码实现 #include &amp;lt;stdio.h&amp;gt; typedef struct node { int value; node *next; } LinkList; LinkList* InitList(int n) { LinkList *head, *node, *end; head = new LinkList; end = head; while (n--) { node = new LinkList; scanf(&amp;#34;%d&amp;#34;, &amp;amp;node-&amp;gt;value); end-&amp;gt;next = node; end = node; } end-&amp;gt;next = NULL; return head; } void ShowList(LinkList *h) { while (h-&amp;gt;next !</description>
    </item>
    
    <item>
      <title>线性表的顺序表示和实现(C语言)</title>
      <link>https://fffzlfk.gitlab.io/2019/09/08/%D5%A1%CA%BE%CA%B5c/</link>
      <pubDate>Sat, 07 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/09/08/%D5%A1%CA%BE%CA%B5c/</guid>
      <description>线性表的顺序表示:  线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素。 数据元素的存储位置之间满足如下关系:  一般来说:   #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2
#define LIST_INIT_SIZE 100 #define LISTINCREMENT 10
typedef int Status; typedef int ElemType; typedef struct { ElemType *elem; int length; int listsize; } SqList;
Status InitList_Sq(SqList &amp;amp;L) { //构造一个空线性表 L.elem = (ElemType*)malloc(LIST_INIT_SIZE * sizeof(ElemType)); if (!L.elem) exit(OVERFLOW); L.length = 0; L.listsize = LIST_INIT_SIZE; return OK; }</description>
    </item>
    
    <item>
      <title>一个用C实现的简单的单向链表</title>
      <link>https://fffzlfk.gitlab.io/2019/09/03/%D2%BBc%CA%B5%D6%B5%C4%BC%C4%B5-2019/</link>
      <pubDate>Wed, 04 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/09/03/%D2%BBc%CA%B5%D6%B5%C4%BC%C4%B5-2019/</guid>
      <description>typedef struct value { int v; struct value *next; } LinkList;
LinkList *create(int n) { LinkList *head, node, end; head = (LinkList)malloc(sizeof(LinkList)); end = head; for (int i = 0; i &amp;lt; n; i++) { node = (LinkList)malloc(sizeof(LinkList)); scanf(&amp;quot;%d&amp;quot;, &amp;amp;node-&amp;gt;v); end-&amp;gt;next = node; end = node; } end-&amp;gt;next = NULL; return head; }
void change(LinkList *list, int n) { LinkList *t = list; int i = 0; while(i &amp;lt; n &amp;amp;&amp;amp; t !</description>
    </item>
    
    <item>
      <title>一个简单的位运算及其复杂度分析(Sample)</title>
      <link>https://fffzlfk.gitlab.io/2019/09/03/%D2%BB%CE%BB%E3%BC%B0%E4%B8%B4%D3%B7%C8%B7sample-2019/</link>
      <pubDate>Tue, 03 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/09/03/%D2%BB%CE%BB%E3%BC%B0%E4%B8%B4%D3%B7%C8%B7sample-2019/</guid>
      <description>代码实现： #include &amp;lt;iostream&amp;gt; using namespace std; int countOnes(unsigned int n) { int ones = 0; while(n) { ones += n &amp;amp; 1; n &amp;gt;&amp;gt;= 1; } return ones; } int main() { int n; while (cin &amp;gt;&amp;gt; n) cout &amp;lt;&amp;lt; countOnes(n) &amp;lt;&amp;lt; endl; return 0; } 时间复杂度： 总的循环次数为n展开为二进制后的位数，即无论是该循环体之前、之内还是之后,均只涉及常数次(逻辑判断、位与运算、加法、右移 等)基本操作。因此,countOnes()算法的执行时间主要由循环的次数决定,亦即:  由大O记号定义,在用函数log r n界定渐进复杂度时,常底数r的具体取值无所谓，故通常不予专门标出而笼统地记作logn，比如,尽管此处底数为常数2,却可直接记作O(logn)。此类算法称作具有“对数时间复杂度”(logarithmic-time algorithm)。</description>
    </item>
    
    <item>
      <title>求k阶斐波那契第m项的值</title>
      <link>https://fffzlfk.gitlab.io/2019/09/03/k%EC%B3%B2m%D6%B5-2019/</link>
      <pubDate>Tue, 03 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fffzlfk.gitlab.io/2019/09/03/k%EC%B3%B2m%D6%B5-2019/</guid>
      <description>代码实现 #include &amp;lt;stdio.h&amp;gt;const int MAXN = 10000; long long fib(int k, int m) { long long a[MAXN]; for (int i = 0; i &amp;lt; k - 1; i++) { a[i] = 0; } a[k - 1] = 1; for (int i = k; i &amp;lt;= m; i++) { long long s = 0; for (int j = i - 1; j &amp;gt; i - 1 - k; j--) { s += a[j]; } a[i] = s; } return a[m]; } int main() { int k, m; while (scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;k, &amp;amp;m) == 2) { printf(&amp;#34;%lld\n&amp;#34;, fib(k, m)); } return 0; } 注释 该题目出现在数据结构（C语言版）题集中的1.</description>
    </item>
    
  </channel>
</rss>
